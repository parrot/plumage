
.namespace []
.sub "_block11"  :anon :subid("10_1261108632.40797")
.annotate "line", 0
    .const 'Sub' $P591 = "50_1261108632.40797" 
    capture_lex $P591
    get_hll_global $P553, ["Array"], "_block552" 
    capture_lex $P553
    get_hll_global $P478, ["Hash"], "_block477" 
    capture_lex $P478
    .const 'Sub' $P444 = "38_1261108632.40797" 
    capture_lex $P444
    .const 'Sub' $P422 = "37_1261108632.40797" 
    capture_lex $P422
    .const 'Sub' $P407 = "36_1261108632.40797" 
    capture_lex $P407
    .const 'Sub' $P379 = "35_1261108632.40797" 
    capture_lex $P379
    .const 'Sub' $P352 = "33_1261108632.40797" 
    capture_lex $P352
    .const 'Sub' $P342 = "32_1261108632.40797" 
    capture_lex $P342
    .const 'Sub' $P328 = "31_1261108632.40797" 
    capture_lex $P328
    .const 'Sub' $P292 = "29_1261108632.40797" 
    capture_lex $P292
    .const 'Sub' $P260 = "27_1261108632.40797" 
    capture_lex $P260
    .const 'Sub' $P195 = "24_1261108632.40797" 
    capture_lex $P195
    .const 'Sub' $P173 = "22_1261108632.40797" 
    capture_lex $P173
    .const 'Sub' $P166 = "21_1261108632.40797" 
    capture_lex $P166
    .const 'Sub' $P141 = "19_1261108632.40797" 
    capture_lex $P141
    .const 'Sub' $P66 = "15_1261108632.40797" 
    capture_lex $P66
    .const 'Sub' $P38 = "13_1261108632.40797" 
    capture_lex $P38
    .const 'Sub' $P13 = "11_1261108632.40797" 
    capture_lex $P13
.annotate "line", 203
    .const 'Sub' $P13 = "11_1261108632.40797" 
    capture_lex $P13
    .lex "map", $P13
.annotate "line", 223
    .const 'Sub' $P38 = "13_1261108632.40797" 
    capture_lex $P38
    .lex "grep", $P38
.annotate "line", 255
    .const 'Sub' $P66 = "15_1261108632.40797" 
    capture_lex $P66
    .lex "reduce", $P66
.annotate "line", 283
    .const 'Sub' $P141 = "19_1261108632.40797" 
    capture_lex $P141
    .lex "_reduce", $P141
.annotate "line", 311
    .const 'Sub' $P166 = "21_1261108632.40797" 
    capture_lex $P166
    .lex "hash", $P166
.annotate "line", 324
    .const 'Sub' $P173 = "22_1261108632.40797" 
    capture_lex $P173
    .lex "set_from_array", $P173
.annotate "line", 364
    .const 'Sub' $P195 = "24_1261108632.40797" 
    capture_lex $P195
    .lex "find_program", $P195
.annotate "line", 393
    .const 'Sub' $P260 = "27_1261108632.40797" 
    capture_lex $P260
    .lex "mkpath", $P260
.annotate "line", 424
    .const 'Sub' $P292 = "29_1261108632.40797" 
    capture_lex $P292
    .lex "test_dir_writable", $P292
.annotate "line", 452
    .const 'Sub' $P328 = "31_1261108632.40797" 
    capture_lex $P328
    .lex "user_home_dir", $P328
.annotate "line", 478
    .const 'Sub' $P342 = "32_1261108632.40797" 
    capture_lex $P342
    .lex "run", $P342
.annotate "line", 496
    .const 'Sub' $P352 = "33_1261108632.40797" 
    capture_lex $P352
    .lex "do_run", $P352
.annotate "line", 520
    .const 'Sub' $P379 = "35_1261108632.40797" 
    capture_lex $P379
    .lex "qx", $P379
.annotate "line", 555
    .const 'Sub' $P407 = "36_1261108632.40797" 
    capture_lex $P407
    .lex "store_dynlex_safely", $P407
.annotate "line", 675
    .const 'Sub' $P422 = "37_1261108632.40797" 
    capture_lex $P422
    .lex "replace_config_strings", $P422
.annotate "line", 687
    .const 'Sub' $P444 = "38_1261108632.40797" 
    capture_lex $P444
    .lex "config_value", $P444
.annotate "line", 67
    get_hll_global $P478, ["Hash"], "_block477" 
    capture_lex $P478
    $P478()
.annotate "line", 155
    get_hll_global $P553, ["Array"], "_block552" 
    capture_lex $P553
    $P553()
    find_lex $P574, "map"
    find_lex $P575, "grep"
    find_lex $P576, "reduce"
    find_lex $P577, "_reduce"
    find_lex $P578, "hash"
    find_lex $P579, "set_from_array"
    find_lex $P580, "find_program"
    find_lex $P581, "mkpath"
    find_lex $P582, "test_dir_writable"
    find_lex $P583, "user_home_dir"
    find_lex $P584, "run"
    find_lex $P585, "do_run"
    find_lex $P586, "qx"
    find_lex $P587, "store_dynlex_safely"
.annotate "line", 609
    find_lex $P588, "replace_config_strings"
    find_lex $P589, "config_value"
.annotate "line", 1
    .return ($P589)
.end


.namespace []
.sub "" :load :init :subid("post51") :outer("10_1261108632.40797")
.annotate "line", 0
    .const 'Sub' $P12 = "10_1261108632.40797" 
    .local pmc block
    set block, $P12
.annotate "line", 609
    .const 'Sub' $P591 = "50_1261108632.40797" 
    capture_lex $P591
    $P591()
.end


.namespace []
.sub "_block590"  :anon :subid("50_1261108632.40797") :outer("10_1261108632.40797")
.annotate "line", 612
    new $P592, "Undef"
    .lex "$interp", $P592
.annotate "line", 613
    new $P593, "ResizablePMCArray"
    .lex "@argv", $P593
.annotate "line", 614
    new $P594, "Undef"
    .lex "$config", $P594
.annotate "line", 617
    new $P595, "Hash"
    .lex "%VM", $P595
.annotate "line", 610
    load_bytecode "config.pbc"
.annotate "line", 612
    getinterp $P596
    store_lex "$interp", $P596
.annotate "line", 613
    find_lex $P597, "$interp"
    unless_null $P597, vivify_52
    new $P597, "ResizablePMCArray"
  vivify_52:
    set $P598, $P597[2]
    unless_null $P598, vivify_53
    new $P598, "Undef"
  vivify_53:
    store_lex "@argv", $P598
.annotate "line", 614
    find_lex $P599, "$interp"
    unless_null $P599, vivify_54
    new $P599, "ResizablePMCArray"
  vivify_54:
    set $P600, $P599[6]
    unless_null $P600, vivify_55
    new $P600, "Undef"
  vivify_55:
    store_lex "$config", $P600
    find_lex $P601, "%VM"
.annotate "line", 618
    find_lex $P602, "$config"
    find_lex $P603, "%VM"
    unless_null $P603, vivify_56
    new $P603, "Hash"
    store_lex "%VM", $P603
  vivify_56:
    set $P603["config"], $P602
.annotate "line", 619
    find_lex $P604, "%VM"
    "store_dynlex_safely"("%*VM", $P604)
.annotate "line", 622
    find_lex $P606, "@argv"
    if $P606, unless_605_end
    find_lex $P607, "@argv"
    $P607."unshift"("<anonymous>")
  unless_605_end:
.annotate "line", 623
    find_lex $P608, "@argv"
    $P609 = $P608."shift"()
    "store_dynlex_safely"("$*PROGRAM_NAME", $P609)
.annotate "line", 624
    find_lex $P610, "@argv"
    "store_dynlex_safely"("@*ARGS", $P610)
.annotate "line", 627
    interpinfo $S611, 19
    "store_dynlex_safely"("$*EXECUTABLE_NAME", $S611)
.annotate "line", 630
    sysinfo $S612, 4
    "store_dynlex_safely"("$*OSNAME", $S612)
.annotate "line", 631
    sysinfo $S613, 5
    "store_dynlex_safely"("%*OSVER", $S613)
.annotate "line", 634
    new $P614, "ResizablePMCArray"
    push $P614, "parrot"
    push $P614, "Env"
    root_new $P615, $P614
    "store_dynlex_safely"("%*ENV", $P615)
.annotate "line", 635
    new $P616, "ResizablePMCArray"
    push $P616, "parrot"
    push $P616, "OS"
    root_new $P617, $P616
    $P618 = "store_dynlex_safely"("$*OS", $P617)
.annotate "line", 609
    .return ($P618)
.end


.namespace []
.sub "map"  :subid("11_1261108632.40797") :outer("10_1261108632.40797")
    .param pmc param_16
    .param pmc param_17
.annotate "line", 203
    .const 'Sub' $P25 = "12_1261108632.40797" 
    capture_lex $P25
    new $P15, 'ExceptionHandler'
    set_addr $P15, control_14
    $P15."handle_types"(58)
    push_eh $P15
    .lex "&code", param_16
    .lex "@originals", param_17
.annotate "line", 204
    new $P18, "ResizablePMCArray"
    .lex "@mapped", $P18
.annotate "line", 203
    find_lex $P19, "@mapped"
.annotate "line", 206
    find_lex $P21, "@originals"
    defined $I22, $P21
    unless $I22, for_undef_57
    iter $P20, $P21
    new $P33, 'ExceptionHandler'
    set_addr $P33, loop32_handler
    $P33."handle_types"(65, 67, 66)
    push_eh $P33
  loop32_test:
    unless $P20, loop32_done
    shift $P23, $P20
  loop32_redo:
    .const 'Sub' $P25 = "12_1261108632.40797" 
    capture_lex $P25
    $P25($P23)
  loop32_next:
    goto loop32_test
  loop32_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P34, exception, 'type'
    eq $P34, 65, loop32_next
    eq $P34, 67, loop32_redo
  loop32_done:
    pop_eh 
  for_undef_57:
.annotate "line", 210
    new $P35, "Exception"
    set $P35['type'], 58
    find_lex $P36, "@mapped"
    setattribute $P35, 'payload', $P36
    throw $P35
.annotate "line", 203
    .return ()
  control_14:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P37, exception, "payload"
    .return ($P37)
.end


.namespace []
.sub "_block24"  :anon :subid("12_1261108632.40797") :outer("11_1261108632.40797")
    .param pmc param_26
.annotate "line", 206
    .lex "$_", param_26
.annotate "line", 207
    find_lex $P27, "@mapped"
    find_lex $P28, "&code"
    find_lex $P29, "$_"
    $P30 = $P28($P29)
    $P31 = $P27."push"($P30)
.annotate "line", 206
    .return ($P31)
.end


.namespace []
.sub "grep"  :subid("13_1261108632.40797") :outer("10_1261108632.40797")
    .param pmc param_41
    .param pmc param_42
.annotate "line", 223
    .const 'Sub' $P50 = "14_1261108632.40797" 
    capture_lex $P50
    new $P40, 'ExceptionHandler'
    set_addr $P40, control_39
    $P40."handle_types"(58)
    push_eh $P40
    .lex "&code", param_41
    .lex "@all", param_42
.annotate "line", 224
    new $P43, "ResizablePMCArray"
    .lex "@matches", $P43
.annotate "line", 223
    find_lex $P44, "@matches"
.annotate "line", 226
    find_lex $P46, "@all"
    defined $I47, $P46
    unless $I47, for_undef_58
    iter $P45, $P46
    new $P61, 'ExceptionHandler'
    set_addr $P61, loop60_handler
    $P61."handle_types"(65, 67, 66)
    push_eh $P61
  loop60_test:
    unless $P45, loop60_done
    shift $P48, $P45
  loop60_redo:
    .const 'Sub' $P50 = "14_1261108632.40797" 
    capture_lex $P50
    $P50($P48)
  loop60_next:
    goto loop60_test
  loop60_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P62, exception, 'type'
    eq $P62, 65, loop60_next
    eq $P62, 67, loop60_redo
  loop60_done:
    pop_eh 
  for_undef_58:
.annotate "line", 230
    new $P63, "Exception"
    set $P63['type'], 58
    find_lex $P64, "@matches"
    setattribute $P63, 'payload', $P64
    throw $P63
.annotate "line", 223
    .return ()
  control_39:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P65, exception, "payload"
    .return ($P65)
.end


.namespace []
.sub "_block49"  :anon :subid("14_1261108632.40797") :outer("13_1261108632.40797")
    .param pmc param_51
.annotate "line", 226
    .lex "$_", param_51
.annotate "line", 227
    find_lex $P54, "&code"
    find_lex $P55, "$_"
    $P56 = $P54($P55)
    if $P56, if_53
    set $P52, $P56
    goto if_53_end
  if_53:
    find_lex $P57, "@matches"
    find_lex $P58, "$_"
    $P59 = $P57."push"($P58)
    set $P52, $P59
  if_53_end:
.annotate "line", 226
    .return ($P52)
.end


.namespace []
.sub "reduce"  :subid("15_1261108632.40797") :outer("10_1261108632.40797")
    .param pmc param_69
    .param pmc param_70
    .param pmc param_71 :slurpy
.annotate "line", 255
    .const 'Sub' $P93 = "16_1261108632.40797" 
    capture_lex $P93
    new $P68, 'ExceptionHandler'
    set_addr $P68, control_67
    $P68."handle_types"(58)
    push_eh $P68
    .lex "&code", param_69
    .lex "@array", param_70
    .lex "@initial", param_71
.annotate "line", 256
    new $P72, "Undef"
    .lex "$init_elems", $P72
    find_lex $P73, "@initial"
    elements $I74, $P73
    new $P75, 'Integer'
    set $P75, $I74
    store_lex "$init_elems", $P75
.annotate "line", 257
    find_lex $P78, "$init_elems"
    set $N79, $P78
    isgt $I80, $N79, 1.0
    if $I80, if_77
.annotate "line", 260
    find_lex $P83, "$init_elems"
    set $N84, $P83
    iseq $I85, $N84, 1.0
    if $I85, if_82
.annotate "line", 263
    .const 'Sub' $P93 = "16_1261108632.40797" 
    capture_lex $P93
    $P139 = $P93()
    set $P81, $P139
.annotate "line", 260
    goto if_82_end
  if_82:
.annotate "line", 261
    new $P86, "Exception"
    set $P86['type'], 58
    find_lex $P87, "&code"
    find_lex $P88, "@array"
    find_lex $P89, "@initial"
    unless_null $P89, vivify_65
    new $P89, "ResizablePMCArray"
  vivify_65:
    set $P90, $P89[0]
    unless_null $P90, vivify_66
    new $P90, "Undef"
  vivify_66:
    $P91 = "_reduce"($P87, $P88, $P90)
    setattribute $P86, 'payload', $P91
    throw $P86
  if_82_end:
.annotate "line", 260
    set $P76, $P81
.annotate "line", 257
    goto if_77_end
  if_77:
.annotate "line", 258
    die "Only one initial value allowed in reduce()"
  if_77_end:
.annotate "line", 255
    .return ($P76)
  control_67:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P140, exception, "payload"
    .return ($P140)
.end


.namespace []
.sub "_block92"  :anon :subid("16_1261108632.40797") :outer("15_1261108632.40797")
.annotate "line", 263
    .const 'Sub' $P118 = "18_1261108632.40797" 
    capture_lex $P118
    .const 'Sub' $P104 = "17_1261108632.40797" 
    capture_lex $P104
.annotate "line", 264
    new $P94, "Undef"
    .lex "$array_elems", $P94
    find_lex $P95, "@array"
    elements $I96, $P95
    new $P97, 'Integer'
    set $P97, $I96
    store_lex "$array_elems", $P97
.annotate "line", 265
    find_lex $P100, "$array_elems"
    set $N101, $P100
    iseq $I102, $N101, 0.0
    if $I102, if_99
.annotate "line", 268
    find_lex $P111, "$array_elems"
    set $N112, $P111
    iseq $I113, $N112, 1.0
    if $I113, if_110
.annotate "line", 271
    .const 'Sub' $P118 = "18_1261108632.40797" 
    capture_lex $P118
    $P138 = $P118()
    set $P109, $P138
.annotate "line", 268
    goto if_110_end
  if_110:
.annotate "line", 269
    new $P114, "Exception"
    set $P114['type'], 58
    find_lex $P115, "@array"
    unless_null $P115, vivify_63
    new $P115, "ResizablePMCArray"
  vivify_63:
    set $P116, $P115[0]
    unless_null $P116, vivify_64
    new $P116, "Undef"
  vivify_64:
    setattribute $P114, 'payload', $P116
    throw $P114
  if_110_end:
.annotate "line", 268
    set $P98, $P109
.annotate "line", 265
    goto if_99_end
  if_99:
    .const 'Sub' $P104 = "17_1261108632.40797" 
    capture_lex $P104
    $P108 = $P104()
    set $P98, $P108
  if_99_end:
.annotate "line", 263
    .return ($P98)
.end


.namespace []
.sub "_block117"  :anon :subid("18_1261108632.40797") :outer("16_1261108632.40797")
.annotate "line", 272
    new $P119, "Undef"
    .lex "$initial", $P119
.annotate "line", 273
    new $P120, "Undef"
    .lex "$iter", $P120
.annotate "line", 272
    find_lex $P121, "&code"
    find_lex $P122, "@array"
    unless_null $P122, vivify_59
    new $P122, "ResizablePMCArray"
  vivify_59:
    set $P123, $P122[0]
    unless_null $P123, vivify_60
    new $P123, "Undef"
  vivify_60:
    find_lex $P124, "@array"
    unless_null $P124, vivify_61
    new $P124, "ResizablePMCArray"
  vivify_61:
    set $P125, $P124[1]
    unless_null $P125, vivify_62
    new $P125, "Undef"
  vivify_62:
    $P126 = $P121($P123, $P125)
    store_lex "$initial", $P126
.annotate "line", 273
    find_lex $P127, "@array"
    iter $P128, $P127
    store_lex "$iter", $P128
.annotate "line", 275
    find_lex $P129, "$iter"
    shift $P130, $P129
.annotate "line", 276
    find_lex $P131, "$iter"
    shift $P132, $P131
.annotate "line", 278
    new $P133, "Exception"
    set $P133['type'], 58
    find_lex $P134, "&code"
    find_lex $P135, "$iter"
    find_lex $P136, "$initial"
    $P137 = "_reduce"($P134, $P135, $P136)
    setattribute $P133, 'payload', $P137
    throw $P133
.annotate "line", 271
    .return ()
.end


.namespace []
.sub "_block103"  :anon :subid("17_1261108632.40797") :outer("16_1261108632.40797")
.annotate "line", 266
    new $P105, "Undef"
    .lex "$undef", $P105
    new $P106, "Exception"
    set $P106['type'], 58
    find_lex $P107, "$undef"
    setattribute $P106, 'payload', $P107
    throw $P106
.annotate "line", 265
    .return ()
.end


.namespace []
.sub "_reduce"  :subid("19_1261108632.40797") :outer("10_1261108632.40797")
    .param pmc param_144
    .param pmc param_145
    .param pmc param_146
.annotate "line", 283
    .const 'Sub' $P154 = "20_1261108632.40797" 
    capture_lex $P154
    new $P143, 'ExceptionHandler'
    set_addr $P143, control_142
    $P143."handle_types"(58)
    push_eh $P143
    .lex "&code", param_144
    .lex "$iter", param_145
    .lex "$initial", param_146
.annotate "line", 284
    new $P147, "Undef"
    .lex "$result", $P147
    find_lex $P148, "$initial"
    store_lex "$result", $P148
.annotate "line", 286
    find_lex $P150, "$iter"
    defined $I151, $P150
    unless $I151, for_undef_67
    iter $P149, $P150
    new $P161, 'ExceptionHandler'
    set_addr $P161, loop160_handler
    $P161."handle_types"(65, 67, 66)
    push_eh $P161
  loop160_test:
    unless $P149, loop160_done
    shift $P152, $P149
  loop160_redo:
    .const 'Sub' $P154 = "20_1261108632.40797" 
    capture_lex $P154
    $P154($P152)
  loop160_next:
    goto loop160_test
  loop160_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P162, exception, 'type'
    eq $P162, 65, loop160_next
    eq $P162, 67, loop160_redo
  loop160_done:
    pop_eh 
  for_undef_67:
.annotate "line", 290
    new $P163, "Exception"
    set $P163['type'], 58
    find_lex $P164, "$result"
    setattribute $P163, 'payload', $P164
    throw $P163
.annotate "line", 283
    .return ()
  control_142:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P165, exception, "payload"
    .return ($P165)
.end


.namespace []
.sub "_block153"  :anon :subid("20_1261108632.40797") :outer("19_1261108632.40797")
    .param pmc param_155
.annotate "line", 286
    .lex "$_", param_155
.annotate "line", 287
    find_lex $P156, "&code"
    find_lex $P157, "$result"
    find_lex $P158, "$_"
    $P159 = $P156($P157, $P158)
    store_lex "$result", $P159
.annotate "line", 286
    .return ($P159)
.end


.namespace []
.sub "hash"  :subid("21_1261108632.40797") :outer("10_1261108632.40797")
    .param pmc param_169 :slurpy :named
.annotate "line", 311
    new $P168, 'ExceptionHandler'
    set_addr $P168, control_167
    $P168."handle_types"(58)
    push_eh $P168
    .lex "%h", param_169
    new $P170, "Exception"
    set $P170['type'], 58
    find_lex $P171, "%h"
    setattribute $P170, 'payload', $P171
    throw $P170
    .return ()
  control_167:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P172, exception, "payload"
    .return ($P172)
.end


.namespace []
.sub "set_from_array"  :subid("22_1261108632.40797") :outer("10_1261108632.40797")
    .param pmc param_176
.annotate "line", 324
    .const 'Sub' $P184 = "23_1261108632.40797" 
    capture_lex $P184
    new $P175, 'ExceptionHandler'
    set_addr $P175, control_174
    $P175."handle_types"(58)
    push_eh $P175
    .lex "@array", param_176
.annotate "line", 325
    new $P177, "Hash"
    .lex "%set", $P177
.annotate "line", 324
    find_lex $P178, "%set"
.annotate "line", 327
    find_lex $P180, "@array"
    defined $I181, $P180
    unless $I181, for_undef_68
    iter $P179, $P180
    new $P190, 'ExceptionHandler'
    set_addr $P190, loop189_handler
    $P190."handle_types"(65, 67, 66)
    push_eh $P190
  loop189_test:
    unless $P179, loop189_done
    shift $P182, $P179
  loop189_redo:
    .const 'Sub' $P184 = "23_1261108632.40797" 
    capture_lex $P184
    $P184($P182)
  loop189_next:
    goto loop189_test
  loop189_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P191, exception, 'type'
    eq $P191, 65, loop189_next
    eq $P191, 67, loop189_redo
  loop189_done:
    pop_eh 
  for_undef_68:
.annotate "line", 331
    new $P192, "Exception"
    set $P192['type'], 58
    find_lex $P193, "%set"
    setattribute $P192, 'payload', $P193
    throw $P192
.annotate "line", 324
    .return ()
  control_174:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P194, exception, "payload"
    .return ($P194)
.end


.namespace []
.sub "_block183"  :anon :subid("23_1261108632.40797") :outer("22_1261108632.40797")
    .param pmc param_185
.annotate "line", 327
    .lex "$_", param_185
.annotate "line", 328
    new $P186, "Integer"
    assign $P186, 1
    find_lex $P187, "$_"
    find_lex $P188, "%set"
    unless_null $P188, vivify_69
    new $P188, "Hash"
    store_lex "%set", $P188
  vivify_69:
    set $P188[$P187], $P186
.annotate "line", 327
    .return ($P186)
.end


.namespace []
.sub "find_program"  :subid("24_1261108632.40797") :outer("10_1261108632.40797")
    .param pmc param_198
.annotate "line", 364
    .const 'Sub' $P227 = "25_1261108632.40797" 
    capture_lex $P227
    new $P197, 'ExceptionHandler'
    set_addr $P197, control_196
    $P197."handle_types"(58)
    push_eh $P197
    .lex "$program", param_198
.annotate "line", 365
    new $P199, "Undef"
    .lex "$path_sep", $P199
.annotate "line", 366
    new $P200, "ResizablePMCArray"
    .lex "@paths", $P200
.annotate "line", 367
    new $P201, "ResizablePMCArray"
    .lex "@exts", $P201
.annotate "line", 365
    find_dynamic_lex $P204, "$*OSNAME"
    unless_null $P204, vivify_70
    get_hll_global $P204, "$OSNAME"
    unless_null $P204, vivify_71
    die "Contextual $*OSNAME not found"
  vivify_71:
  vivify_70:
    set $S205, $P204
    iseq $I206, $S205, "MSWin32"
    if $I206, if_203
    new $P208, "String"
    assign $P208, ":"
    set $P202, $P208
    goto if_203_end
  if_203:
    new $P207, "String"
    assign $P207, ";"
    set $P202, $P207
  if_203_end:
    store_lex "$path_sep", $P202
.annotate "line", 366
    find_lex $P209, "$path_sep"
    set $S210, $P209
    find_dynamic_lex $P211, "%*ENV"
    unless_null $P211, vivify_72
    get_hll_global $P211, "%ENV"
    unless_null $P211, vivify_73
    die "Contextual %*ENV not found"
  vivify_73:
  vivify_72:
    set $P212, $P211["PATH"]
    unless_null $P212, vivify_74
    new $P212, "Undef"
  vivify_74:
    set $S213, $P212
    split $P214, $S210, $S213
    store_lex "@paths", $P214
.annotate "line", 367
    find_lex $P215, "$path_sep"
    set $S216, $P215
    find_dynamic_lex $P217, "%*ENV"
    unless_null $P217, vivify_75
    get_hll_global $P217, "%ENV"
    unless_null $P217, vivify_76
    die "Contextual %*ENV not found"
  vivify_76:
  vivify_75:
    set $P218, $P217["PATHEXT"]
    unless_null $P218, vivify_77
    new $P218, "Undef"
  vivify_77:
    set $S219, $P218
    split $P220, $S216, $S219
    store_lex "@exts", $P220
.annotate "line", 369
    find_lex $P221, "@exts"
    $P221."unshift"("")
.annotate "line", 371
    find_lex $P223, "@paths"
    defined $I224, $P223
    unless $I224, for_undef_78
    iter $P222, $P223
    new $P255, 'ExceptionHandler'
    set_addr $P255, loop254_handler
    $P255."handle_types"(65, 67, 66)
    push_eh $P255
  loop254_test:
    unless $P222, loop254_done
    shift $P225, $P222
  loop254_redo:
    .const 'Sub' $P227 = "25_1261108632.40797" 
    capture_lex $P227
    $P227($P225)
  loop254_next:
    goto loop254_test
  loop254_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P256, exception, 'type'
    eq $P256, 65, loop254_next
    eq $P256, 67, loop254_redo
  loop254_done:
    pop_eh 
  for_undef_78:
.annotate "line", 380
    new $P257, "Exception"
    set $P257['type'], 58
    new $P258, "String"
    assign $P258, ""
    setattribute $P257, 'payload', $P258
    throw $P257
.annotate "line", 364
    .return ()
  control_196:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P259, exception, "payload"
    .return ($P259)
.end


.namespace []
.sub "_block226"  :anon :subid("25_1261108632.40797") :outer("24_1261108632.40797")
    .param pmc param_228
.annotate "line", 371
    .const 'Sub' $P239 = "26_1261108632.40797" 
    capture_lex $P239
    .lex "$dir", param_228
.annotate "line", 372
    new $P229, "Undef"
    .lex "$path", $P229
    find_lex $P230, "$dir"
    new $P231, "ResizablePMCArray"
    push $P231, $P230
    find_lex $P232, "$program"
    $P233 = "fscat"($P231, $P232)
    store_lex "$path", $P233
.annotate "line", 374
    find_lex $P235, "@exts"
    defined $I236, $P235
    unless $I236, for_undef_79
    iter $P234, $P235
    new $P252, 'ExceptionHandler'
    set_addr $P252, loop251_handler
    $P252."handle_types"(65, 67, 66)
    push_eh $P252
  loop251_test:
    unless $P234, loop251_done
    shift $P237, $P234
  loop251_redo:
    .const 'Sub' $P239 = "26_1261108632.40797" 
    capture_lex $P239
    $P239($P237)
  loop251_next:
    goto loop251_test
  loop251_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P253, exception, 'type'
    eq $P253, 65, loop251_next
    eq $P253, 67, loop251_redo
  loop251_done:
    pop_eh 
  for_undef_79:
.annotate "line", 371
    .return ($P234)
.end


.namespace []
.sub "_block238"  :anon :subid("26_1261108632.40797") :outer("25_1261108632.40797")
    .param pmc param_240
.annotate "line", 374
    .lex "$ext", param_240
.annotate "line", 375
    new $P241, "Undef"
    .lex "$pathext", $P241
    find_lex $P242, "$path"
    find_lex $P243, "$ext"
    concat $P244, $P242, $P243
    store_lex "$pathext", $P244
.annotate "line", 376
    find_lex $P247, "$pathext"
    $P248 = "path_exists"($P247)
    if $P248, if_246
    set $P245, $P248
    goto if_246_end
  if_246:
    new $P249, "Exception"
    set $P249['type'], 58
    find_lex $P250, "$pathext"
    setattribute $P249, 'payload', $P250
    throw $P249
  if_246_end:
.annotate "line", 374
    .return ($P245)
.end


.namespace []
.sub "mkpath"  :subid("27_1261108632.40797") :outer("10_1261108632.40797")
    .param pmc param_263
.annotate "line", 393
    .const 'Sub' $P276 = "28_1261108632.40797" 
    capture_lex $P276
    new $P262, 'ExceptionHandler'
    set_addr $P262, control_261
    $P262."handle_types"(58)
    push_eh $P262
    .lex "$path", param_263
.annotate "line", 394
    new $P264, "ResizablePMCArray"
    .lex "@path", $P264
.annotate "line", 395
    new $P265, "Undef"
    .lex "$cur", $P265
.annotate "line", 394
    find_lex $P266, "$path"
    set $S267, $P266
    split $P268, "/", $S267
    store_lex "@path", $P268
.annotate "line", 395
    find_lex $P269, "@path"
    $P270 = $P269."shift"()
    store_lex "$cur", $P270
.annotate "line", 397
    find_lex $P272, "@path"
    defined $I273, $P272
    unless $I273, for_undef_80
    iter $P271, $P272
    new $P289, 'ExceptionHandler'
    set_addr $P289, loop288_handler
    $P289."handle_types"(65, 67, 66)
    push_eh $P289
  loop288_test:
    unless $P271, loop288_done
    shift $P274, $P271
  loop288_redo:
    .const 'Sub' $P276 = "28_1261108632.40797" 
    capture_lex $P276
    $P276($P274)
  loop288_next:
    goto loop288_test
  loop288_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P290, exception, 'type'
    eq $P290, 65, loop288_next
    eq $P290, 67, loop288_redo
  loop288_done:
    pop_eh 
  for_undef_80:
.annotate "line", 393
    .return ($P271)
  control_261:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P291, exception, "payload"
    .return ($P291)
.end


.namespace []
.sub "_block275"  :anon :subid("28_1261108632.40797") :outer("27_1261108632.40797")
    .param pmc param_277
.annotate "line", 397
    .lex "$dir", param_277
.annotate "line", 398
    find_lex $P278, "$cur"
    find_lex $P279, "$dir"
    new $P280, "ResizablePMCArray"
    push $P280, $P278
    push $P280, $P279
    $P281 = "fscat"($P280)
    store_lex "$cur", $P281
.annotate "line", 400
    find_lex $P284, "$cur"
    $P285 = "path_exists"($P284)
    unless $P285, unless_283
    set $P282, $P285
    goto unless_283_end
  unless_283:
.annotate "line", 401
    find_lex $P286, "$cur"
    $P287 = "mkdir"($P286)
.annotate "line", 400
    set $P282, $P287
  unless_283_end:
.annotate "line", 397
    .return ($P282)
.end


.namespace []
.sub "test_dir_writable"  :subid("29_1261108632.40797") :outer("10_1261108632.40797")
    .param pmc param_295
.annotate "line", 424
    .const 'Sub' $P308 = "30_1261108632.40797" 
    capture_lex $P308
    new $P294, 'ExceptionHandler'
    set_addr $P294, control_293
    $P294."handle_types"(58)
    push_eh $P294
    .lex "$dir", param_295
.annotate "line", 425
    new $P296, "Undef"
    .lex "$test_file", $P296
    find_lex $P297, "$dir"
    new $P298, "ResizablePMCArray"
    push $P298, $P297
    $P299 = "fscat"($P298, "WrItAbLe.UtL")
    store_lex "$test_file", $P299
.annotate "line", 428
    find_lex $P301, "$test_file"
    $P302 = "path_exists"($P301)
    unless $P302, if_300_end
.annotate "line", 427
    new $P303, 'String'
    set $P303, "Test file '"
    find_lex $P304, "$test_file"
    concat $P305, $P303, $P304
    concat $P306, $P305, "'\nthat should never exist already does."
    die $P306
  if_300_end:
.annotate "line", 430
    .const 'Sub' $P308 = "30_1261108632.40797" 
    capture_lex $P308
    $P308()
.annotate "line", 434
    find_lex $P320, "$test_file"
    $P321 = "path_exists"($P320)
    if $P321, if_319
.annotate "line", 439
    new $P325, "Exception"
    set $P325['type'], 58
    new $P326, "Integer"
    assign $P326, 0
    setattribute $P325, 'payload', $P326
    throw $P325
.annotate "line", 438
    goto if_319_end
  if_319:
.annotate "line", 435
    find_lex $P322, "$test_file"
    "unlink"($P322)
.annotate "line", 436
    new $P323, "Exception"
    set $P323['type'], 58
    new $P324, "Integer"
    assign $P324, 1
    setattribute $P323, 'payload', $P324
    throw $P323
  if_319_end:
.annotate "line", 424
    .return ($P318)
  control_293:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P327, exception, "payload"
    .return ($P327)
.end


.namespace []
.sub "_block307"  :anon :subid("30_1261108632.40797") :outer("29_1261108632.40797")
.annotate "line", 430
    new $P313, 'ExceptionHandler'
    set_addr $P313, control_312
    $P313."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P313
.annotate "line", 431
    find_lex $P309, "$test_file"
    $P310 = "spew"($P309, "test_dir_writable() test file.\n")
.annotate "line", 430
    pop_eh 
    goto skip_handler_311
  control_312:
    .local pmc exception 
    .get_results (exception) 
    new $P316, 'Integer'
    set $P316, 1
    set exception["handled"], $P316
    set $I317, exception["handled"]
    ne $I317, 1, nothandled_315
  handled_314:
    .return (exception)
  nothandled_315:
    rethrow exception
  skip_handler_311:
    .return ($P310)
.end


.namespace []
.sub "user_home_dir"  :subid("31_1261108632.40797") :outer("10_1261108632.40797")
.annotate "line", 452
    new $P330, 'ExceptionHandler'
    set_addr $P330, control_329
    $P330."handle_types"(58)
    push_eh $P330
.annotate "line", 453
    new $P331, "Exception"
    set $P331['type'], 58
    find_dynamic_lex $P333, "%*ENV"
    unless_null $P333, vivify_81
    get_hll_global $P333, "%ENV"
    unless_null $P333, vivify_82
    die "Contextual %*ENV not found"
  vivify_82:
  vivify_81:
    set $P334, $P333["HOMEDRIVE"]
    unless_null $P334, vivify_83
    new $P334, "Undef"
  vivify_83:
    set $P332, $P334
    defined $I336, $P332
    if $I336, default_335
    new $P337, "String"
    assign $P337, ""
    set $P332, $P337
  default_335:
    find_dynamic_lex $P338, "%*ENV"
    unless_null $P338, vivify_84
    get_hll_global $P338, "%ENV"
    unless_null $P338, vivify_85
    die "Contextual %*ENV not found"
  vivify_85:
  vivify_84:
    set $P339, $P338["HOME"]
    unless_null $P339, vivify_86
    new $P339, "Undef"
  vivify_86:
    concat $P340, $P332, $P339
    setattribute $P331, 'payload', $P340
    throw $P331
.annotate "line", 452
    .return ()
  control_329:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P341, exception, "payload"
    .return ($P341)
.end


.namespace []
.sub "run"  :subid("32_1261108632.40797") :outer("10_1261108632.40797")
    .param pmc param_345 :slurpy
.annotate "line", 478
    new $P344, 'ExceptionHandler'
    set_addr $P344, control_343
    $P344."handle_types"(58)
    push_eh $P344
    .lex "@command_and_args", param_345
.annotate "line", 479
    new $P346, "Exception"
    set $P346['type'], 58
    find_lex $P347, "@command_and_args"
    spawnw $I348, $P347
    new $P349, 'Integer'
    set $P349, $I348
    shr $P350, $P349, 8
    setattribute $P346, 'payload', $P350
    throw $P346
.annotate "line", 478
    .return ()
  control_343:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P351, exception, "payload"
    .return ($P351)
.end


.namespace []
.sub "do_run"  :subid("33_1261108632.40797") :outer("10_1261108632.40797")
    .param pmc param_355 :slurpy
.annotate "line", 496
    .const 'Sub' $P371 = "34_1261108632.40797" 
    capture_lex $P371
    new $P354, 'ExceptionHandler'
    set_addr $P354, control_353
    $P354."handle_types"(58)
    push_eh $P354
    new $P367, 'ExceptionHandler'
    set_addr $P367, control_366
    $P367."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P367
    .lex "@command_and_args", param_355
.annotate "line", 497
    find_lex $P356, "@command_and_args"
    join $S357, " ", $P356
    "say"($S357)
.annotate "line", 499
    new $P358, "Exception"
    set $P358['type'], 58
    find_lex $P361, "@command_and_args"
    spawnw $I362, $P361
    if $I362, if_360
    new $P364, "Integer"
    assign $P364, 1
    set $P359, $P364
    goto if_360_end
  if_360:
    new $P363, "Integer"
    assign $P363, 0
    set $P359, $P363
  if_360_end:
    setattribute $P358, 'payload', $P359
    throw $P358
.annotate "line", 496
    pop_eh 
    goto skip_handler_365
  control_366:
.annotate "line", 501
    .local pmc exception 
    .get_results (exception) 
    .const 'Sub' $P371 = "34_1261108632.40797" 
    capture_lex $P371
    $P371(exception)
    new $P376, 'Integer'
    set $P376, 1
    set exception["handled"], $P376
    set $I377, exception["handled"]
    ne $I377, 1, nothandled_369
  handled_368:
    .return (exception)
  nothandled_369:
    rethrow exception
  skip_handler_365:
.annotate "line", 496
    .return ()
  control_353:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P378, exception, "payload"
    .return ($P378)
.end


.namespace []
.sub "_block370"  :anon :subid("34_1261108632.40797") :outer("33_1261108632.40797")
    .param pmc param_372
.annotate "line", 501
    .lex "$_", param_372
    find_lex $P373, "$_"
    .lex "$!", $P373
.annotate "line", 502
    new $P374, "Exception"
    set $P374['type'], 58
    new $P375, "Integer"
    assign $P375, -1
    setattribute $P374, 'payload', $P375
    throw $P374
.annotate "line", 501
    .return ()
.end


.namespace []
.sub "qx"  :subid("35_1261108632.40797") :outer("10_1261108632.40797")
    .param pmc param_382 :slurpy
.annotate "line", 520
    new $P381, 'ExceptionHandler'
    set_addr $P381, control_380
    $P381."handle_types"(58)
    push_eh $P381
    .lex "@command_and_args", param_382
.annotate "line", 521
    new $P383, "Undef"
    .lex "$cmd", $P383
.annotate "line", 522
    new $P384, "Undef"
    .lex "$pipe", $P384
.annotate "line", 526
    new $P385, "Undef"
    .lex "$output", $P385
.annotate "line", 521
    find_lex $P386, "@command_and_args"
    join $S387, " ", $P386
    new $P388, 'String'
    set $P388, $S387
    store_lex "$cmd", $P388
.annotate "line", 522
    find_lex $P389, "$cmd"
    set $S390, $P389
    open $P391, $S390, "rp"
    store_lex "$pipe", $P391
.annotate "line", 523
    find_lex $P393, "$pipe"
    if $P393, unless_392_end
    new $P394, 'String'
    set $P394, "Unable to execute '"
    find_lex $P395, "$cmd"
    concat $P396, $P394, $P395
    concat $P397, $P396, "'"
    die $P397
  unless_392_end:
.annotate "line", 525
    find_lex $P398, "$pipe"
    $P398."encoding"("utf8")
.annotate "line", 526
    find_lex $P399, "$pipe"
    $P400 = $P399."readall"()
    store_lex "$output", $P400
.annotate "line", 527
    find_lex $P401, "$pipe"
    $P401."close"()
.annotate "line", 529
    find_lex $P402, "$pipe"
    $P403 = $P402."exit_status"()
    "store_dynlex_safely"("$!", $P403)
.annotate "line", 531
    new $P404, "Exception"
    set $P404['type'], 58
    find_lex $P405, "$output"
    setattribute $P404, 'payload', $P405
    throw $P404
.annotate "line", 520
    .return ()
  control_380:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P406, exception, "payload"
    .return ($P406)
.end


.namespace []
.sub "store_dynlex_safely"  :subid("36_1261108632.40797") :outer("10_1261108632.40797")
    .param pmc param_410
    .param pmc param_411
.annotate "line", 555
    new $P409, 'ExceptionHandler'
    set_addr $P409, control_408
    $P409."handle_types"(58)
    push_eh $P409
    .lex "$var_name", param_410
    .lex "$value", param_411
.annotate "line", 557
    find_lex $P414, "$var_name"
    set $S415, $P414
    find_dynamic_lex $P416, $S415
    isnull $I417, $P416
    unless $I417, unless_413
    new $P412, 'Integer'
    set $P412, $I417
    goto unless_413_end
  unless_413:
.annotate "line", 556
    find_lex $P418, "$var_name"
    set $S419, $P418
    find_lex $P420, "$value"
    store_dynamic_lex $S419, $P420
  unless_413_end:
.annotate "line", 555
    .return ($P412)
  control_408:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P421, exception, "payload"
    .return ($P421)
.end


.namespace []
.sub "replace_config_strings"  :subid("37_1261108632.40797") :outer("10_1261108632.40797")
    .param pmc param_425
.annotate "line", 675
    new $P424, 'ExceptionHandler'
    set_addr $P424, control_423
    $P424."handle_types"(58)
    push_eh $P424
    .lex "$original", param_425
.annotate "line", 676
    new $P426, "Undef"
    .lex "$new", $P426
    find_lex $P427, "$original"
    store_lex "$new", $P427
.annotate "line", 678
    new $P439, 'ExceptionHandler'
    set_addr $P439, loop438_handler
    $P439."handle_types"(65, 67, 66)
    push_eh $P439
    goto loop438_redo
  loop438_test:
.annotate "line", 682
    find_lex $P428, "$new"
    set $S429, $P428
    find_lex $P430, "$original"
    set $S431, $P430
    isne $I432, $S429, $S431
    unless $I432, loop438_done
  loop438_redo:
.annotate "line", 679
    find_lex $P433, "$new"
    store_lex "$original", $P433
.annotate "line", 680
    find_lex $P434, "$original"
    $P435 = "rx"("\\#<ident>\\#")
    get_hll_global $P436, "config_value"
    $P437 = "subst"($P434, $P435, $P436)
    store_lex "$new", $P437
  loop438_next:
.annotate "line", 678
    goto loop438_test
  loop438_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P440, exception, 'type'
    eq $P440, 65, loop438_next
    eq $P440, 67, loop438_redo
  loop438_done:
    pop_eh 
.annotate "line", 684
    new $P441, "Exception"
    set $P441['type'], 58
    find_lex $P442, "$new"
    setattribute $P441, 'payload', $P442
    throw $P441
.annotate "line", 675
    .return ()
  control_423:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P443, exception, "payload"
    .return ($P443)
.end


.namespace []
.sub "config_value"  :subid("38_1261108632.40797") :outer("10_1261108632.40797")
    .param pmc param_447
.annotate "line", 687
    new $P446, 'ExceptionHandler'
    set_addr $P446, control_445
    $P446."handle_types"(58)
    push_eh $P446
    .lex "$match", param_447
.annotate "line", 688
    new $P448, "Undef"
    .lex "$key", $P448
.annotate "line", 689
    new $P449, "Undef"
    .lex "$config", $P449
.annotate "line", 688
    find_lex $P450, "$match"
    unless_null $P450, vivify_87
    new $P450, "Hash"
  vivify_87:
    set $P451, $P450["ident"]
    unless_null $P451, vivify_88
    new $P451, "Undef"
  vivify_88:
    store_lex "$key", $P451
.annotate "line", 690
    find_lex $P460, "$key"
    find_dynamic_lex $P461, "%*CONF"
    unless_null $P461, vivify_89
    get_hll_global $P461, "%CONF"
    unless_null $P461, vivify_90
    die "Contextual %*CONF not found"
  vivify_90:
  vivify_89:
    set $P462, $P461[$P460]
    unless_null $P462, vivify_91
    new $P462, "Undef"
  vivify_91:
    unless $P462, unless_459
    set $P458, $P462
    goto unless_459_end
  unless_459:
    find_lex $P463, "$key"
    find_dynamic_lex $P464, "%*VM"
    unless_null $P464, vivify_92
    get_hll_global $P464, "%VM"
    unless_null $P464, vivify_93
    die "Contextual %*VM not found"
  vivify_93:
  vivify_92:
    set $P465, $P464["config"]
    unless_null $P465, vivify_94
    new $P465, "Hash"
  vivify_94:
    set $P466, $P465[$P463]
    unless_null $P466, vivify_95
    new $P466, "Undef"
  vivify_95:
    set $P458, $P466
  unless_459_end:
    unless $P458, unless_457
    set $P456, $P458
    goto unless_457_end
  unless_457:
    find_lex $P467, "$key"
    find_dynamic_lex $P468, "%*BIN"
    unless_null $P468, vivify_96
    get_hll_global $P468, "%BIN"
    unless_null $P468, vivify_97
    die "Contextual %*BIN not found"
  vivify_97:
  vivify_96:
    set $P469, $P468[$P467]
    unless_null $P469, vivify_98
    new $P469, "Undef"
  vivify_98:
    set $P456, $P469
  unless_457_end:
.annotate "line", 691
    unless $P456, unless_455
    set $P454, $P456
    goto unless_455_end
  unless_455:
    find_lex $P470, "$key"
    find_dynamic_lex $P471, "%*ENV"
    unless_null $P471, vivify_99
    get_hll_global $P471, "%ENV"
    unless_null $P471, vivify_100
    die "Contextual %*ENV not found"
  vivify_100:
  vivify_99:
    set $P472, $P471[$P470]
    unless_null $P472, vivify_101
    new $P472, "Undef"
  vivify_101:
    set $P454, $P472
  unless_455_end:
.annotate "line", 692
    unless $P454, unless_453
    set $P452, $P454
    goto unless_453_end
  unless_453:
    new $P473, "String"
    assign $P473, ""
    set $P452, $P473
  unless_453_end:
.annotate "line", 693
    store_lex "$config", $P452
.annotate "line", 695
    new $P474, "Exception"
    set $P474['type'], 58
    find_lex $P475, "$config"
    setattribute $P474, 'payload', $P475
    throw $P474
.annotate "line", 687
    .return ()
  control_445:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P476, exception, "payload"
    .return ($P476)
.end


.namespace ["Hash"]
.sub "_block477"  :subid("39_1261108632.40797") :outer("10_1261108632.40797")
.annotate "line", 67
    .const 'Sub' $P528 = "45_1261108632.40797" 
    capture_lex $P528
    .const 'Sub' $P507 = "43_1261108632.40797" 
    capture_lex $P507
    .const 'Sub' $P486 = "41_1261108632.40797" 
    capture_lex $P486
    .const 'Sub' $P479 = "40_1261108632.40797" 
    capture_lex $P479
.annotate "line", 130
    .const 'Sub' $P528 = "45_1261108632.40797" 
    capture_lex $P528
.annotate "line", 67
    .return ($P528)
.end


.namespace ["Hash"]
.sub "exists"  :subid("40_1261108632.40797") :method :outer("39_1261108632.40797")
    .param pmc param_482
.annotate "line", 80
    new $P481, 'ExceptionHandler'
    set_addr $P481, control_480
    $P481."handle_types"(58)
    push_eh $P481
    .lex "self", self
    .lex "$key", param_482
.annotate "line", 81
    new $P483, "Exception"
    set $P483['type'], 58

            $P1 = find_lex '$key'
            $I0 = exists self[$P1]
            $P484  = box $I0
        
    setattribute $P483, 'payload', $P484
    throw $P483
.annotate "line", 80
    .return ()
  control_480:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P485, exception, "payload"
    .return ($P485)
.end


.namespace ["Hash"]
.sub "keys"  :subid("41_1261108632.40797") :method :outer("39_1261108632.40797")
.annotate "line", 97
    .const 'Sub' $P496 = "42_1261108632.40797" 
    capture_lex $P496
    new $P488, 'ExceptionHandler'
    set_addr $P488, control_487
    $P488."handle_types"(58)
    push_eh $P488
    .lex "self", self
.annotate "line", 98
    new $P489, "ResizablePMCArray"
    .lex "@keys", $P489
.annotate "line", 97
    find_lex $P490, "@keys"
.annotate "line", 99
    find_lex $P492, "self"
    defined $I493, $P492
    unless $I493, for_undef_102
    iter $P491, $P492
    new $P503, 'ExceptionHandler'
    set_addr $P503, loop502_handler
    $P503."handle_types"(65, 67, 66)
    push_eh $P503
  loop502_test:
    unless $P491, loop502_done
    shift $P494, $P491
  loop502_redo:
    .const 'Sub' $P496 = "42_1261108632.40797" 
    capture_lex $P496
    $P496($P494)
  loop502_next:
    goto loop502_test
  loop502_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P504, exception, 'type'
    eq $P504, 65, loop502_next
    eq $P504, 67, loop502_redo
  loop502_done:
    pop_eh 
  for_undef_102:
    find_lex $P505, "@keys"
.annotate "line", 97
    .return ($P505)
  control_487:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P506, exception, "payload"
    .return ($P506)
.end


.namespace ["Hash"]
.sub "_block495"  :anon :subid("42_1261108632.40797") :outer("41_1261108632.40797")
    .param pmc param_497
.annotate "line", 99
    .lex "$_", param_497
    find_lex $P498, "@keys"
    find_lex $P499, "$_"
    $P500 = $P499."key"()
    $P501 = $P498."push"($P500)
    .return ($P501)
.end


.namespace ["Hash"]
.sub "values"  :subid("43_1261108632.40797") :method :outer("39_1261108632.40797")
.annotate "line", 112
    .const 'Sub' $P517 = "44_1261108632.40797" 
    capture_lex $P517
    new $P509, 'ExceptionHandler'
    set_addr $P509, control_508
    $P509."handle_types"(58)
    push_eh $P509
    .lex "self", self
.annotate "line", 113
    new $P510, "ResizablePMCArray"
    .lex "@values", $P510
.annotate "line", 112
    find_lex $P511, "@values"
.annotate "line", 114
    find_lex $P513, "self"
    defined $I514, $P513
    unless $I514, for_undef_103
    iter $P512, $P513
    new $P524, 'ExceptionHandler'
    set_addr $P524, loop523_handler
    $P524."handle_types"(65, 67, 66)
    push_eh $P524
  loop523_test:
    unless $P512, loop523_done
    shift $P515, $P512
  loop523_redo:
    .const 'Sub' $P517 = "44_1261108632.40797" 
    capture_lex $P517
    $P517($P515)
  loop523_next:
    goto loop523_test
  loop523_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P525, exception, 'type'
    eq $P525, 65, loop523_next
    eq $P525, 67, loop523_redo
  loop523_done:
    pop_eh 
  for_undef_103:
    find_lex $P526, "@values"
.annotate "line", 112
    .return ($P526)
  control_508:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P527, exception, "payload"
    .return ($P527)
.end


.namespace ["Hash"]
.sub "_block516"  :anon :subid("44_1261108632.40797") :outer("43_1261108632.40797")
    .param pmc param_518
.annotate "line", 114
    .lex "$_", param_518
    find_lex $P519, "@values"
    find_lex $P520, "$_"
    $P521 = $P520."value"()
    $P522 = $P519."push"($P521)
    .return ($P522)
.end


.namespace ["Hash"]
.sub "kv"  :subid("45_1261108632.40797") :method :outer("39_1261108632.40797")
.annotate "line", 130
    .const 'Sub' $P538 = "46_1261108632.40797" 
    capture_lex $P538
    new $P530, 'ExceptionHandler'
    set_addr $P530, control_529
    $P530."handle_types"(58)
    push_eh $P530
    .lex "self", self
.annotate "line", 131
    new $P531, "ResizablePMCArray"
    .lex "@kv", $P531
.annotate "line", 130
    find_lex $P532, "@kv"
.annotate "line", 132
    find_lex $P534, "self"
    defined $I535, $P534
    unless $I535, for_undef_104
    iter $P533, $P534
    new $P548, 'ExceptionHandler'
    set_addr $P548, loop547_handler
    $P548."handle_types"(65, 67, 66)
    push_eh $P548
  loop547_test:
    unless $P533, loop547_done
    shift $P536, $P533
  loop547_redo:
    .const 'Sub' $P538 = "46_1261108632.40797" 
    capture_lex $P538
    $P538($P536)
  loop547_next:
    goto loop547_test
  loop547_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P549, exception, 'type'
    eq $P549, 65, loop547_next
    eq $P549, 67, loop547_redo
  loop547_done:
    pop_eh 
  for_undef_104:
    find_lex $P550, "@kv"
.annotate "line", 130
    .return ($P550)
  control_529:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P551, exception, "payload"
    .return ($P551)
.end


.namespace ["Hash"]
.sub "_block537"  :anon :subid("46_1261108632.40797") :outer("45_1261108632.40797")
    .param pmc param_539
.annotate "line", 132
    .lex "$_", param_539
    find_lex $P540, "@kv"
    find_lex $P541, "$_"
    $P542 = $P541."key"()
    $P540."push"($P542)
    find_lex $P543, "@kv"
    find_lex $P544, "$_"
    $P545 = $P544."value"()
    $P546 = $P543."push"($P545)
    .return ($P546)
.end


.namespace ["Array"]
.sub "_block552"  :subid("47_1261108632.40797") :outer("10_1261108632.40797")
.annotate "line", 155
    .const 'Sub' $P554 = "48_1261108632.40797" 
    capture_lex $P554
.annotate "line", 168
    .const 'Sub' $P554 = "48_1261108632.40797" 
    capture_lex $P554
.annotate "line", 155
    .return ($P554)
.end


.namespace ["Array"]
.sub "reverse"  :subid("48_1261108632.40797") :method :outer("47_1261108632.40797")
.annotate "line", 168
    .const 'Sub' $P564 = "49_1261108632.40797" 
    capture_lex $P564
    new $P556, 'ExceptionHandler'
    set_addr $P556, control_555
    $P556."handle_types"(58)
    push_eh $P556
    .lex "self", self
.annotate "line", 169
    new $P557, "ResizablePMCArray"
    .lex "@reversed", $P557
.annotate "line", 168
    find_lex $P558, "@reversed"
.annotate "line", 170
    find_lex $P560, "self"
    defined $I561, $P560
    unless $I561, for_undef_105
    iter $P559, $P560
    new $P570, 'ExceptionHandler'
    set_addr $P570, loop569_handler
    $P570."handle_types"(65, 67, 66)
    push_eh $P570
  loop569_test:
    unless $P559, loop569_done
    shift $P562, $P559
  loop569_redo:
    .const 'Sub' $P564 = "49_1261108632.40797" 
    capture_lex $P564
    $P564($P562)
  loop569_next:
    goto loop569_test
  loop569_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P571, exception, 'type'
    eq $P571, 65, loop569_next
    eq $P571, 67, loop569_redo
  loop569_done:
    pop_eh 
  for_undef_105:
    find_lex $P572, "@reversed"
.annotate "line", 168
    .return ($P572)
  control_555:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P573, exception, "payload"
    .return ($P573)
.end


.namespace ["Array"]
.sub "_block563"  :anon :subid("49_1261108632.40797") :outer("48_1261108632.40797")
    .param pmc param_565
.annotate "line", 170
    .lex "$_", param_565
    find_lex $P566, "@reversed"
    find_lex $P567, "$_"
    $P568 = $P566."unshift"($P567)
    .return ($P568)
.end

