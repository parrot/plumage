
.namespace []
.sub "_block11"  :anon :subid("10_1261126889.13736")
.annotate "line", 0
    .const 'Sub' $P777 = "62_1261126889.13736" 
    capture_lex $P777
    get_hll_global $P730, ["Array"], "_block729" 
    capture_lex $P730
    get_hll_global $P655, ["Hash"], "_block654" 
    capture_lex $P655
    .const 'Sub' $P621 = "50_1261126889.13736" 
    capture_lex $P621
    .const 'Sub' $P599 = "49_1261126889.13736" 
    capture_lex $P599
    .const 'Sub' $P584 = "48_1261126889.13736" 
    capture_lex $P584
    .const 'Sub' $P563 = "47_1261126889.13736" 
    capture_lex $P563
    .const 'Sub' $P535 = "46_1261126889.13736" 
    capture_lex $P535
    .const 'Sub' $P508 = "44_1261126889.13736" 
    capture_lex $P508
    .const 'Sub' $P498 = "43_1261126889.13736" 
    capture_lex $P498
    .const 'Sub' $P464 = "41_1261126889.13736" 
    capture_lex $P464
    .const 'Sub' $P397 = "38_1261126889.13736" 
    capture_lex $P397
    .const 'Sub' $P359 = "36_1261126889.13736" 
    capture_lex $P359
    .const 'Sub' $P331 = "34_1261126889.13736" 
    capture_lex $P331
    .const 'Sub' $P306 = "32_1261126889.13736" 
    capture_lex $P306
    .const 'Sub' $P289 = "31_1261126889.13736" 
    capture_lex $P289
    .const 'Sub' $P259 = "30_1261126889.13736" 
    capture_lex $P259
    .const 'Sub' $P246 = "29_1261126889.13736" 
    capture_lex $P246
    .const 'Sub' $P233 = "28_1261126889.13736" 
    capture_lex $P233
    .const 'Sub' $P218 = "27_1261126889.13736" 
    capture_lex $P218
    .const 'Sub' $P211 = "26_1261126889.13736" 
    capture_lex $P211
    .const 'Sub' $P195 = "24_1261126889.13736" 
    capture_lex $P195
    .const 'Sub' $P173 = "22_1261126889.13736" 
    capture_lex $P173
    .const 'Sub' $P166 = "21_1261126889.13736" 
    capture_lex $P166
    .const 'Sub' $P141 = "19_1261126889.13736" 
    capture_lex $P141
    .const 'Sub' $P66 = "15_1261126889.13736" 
    capture_lex $P66
    .const 'Sub' $P38 = "13_1261126889.13736" 
    capture_lex $P38
    .const 'Sub' $P13 = "11_1261126889.13736" 
    capture_lex $P13
.annotate "line", 216
    .const 'Sub' $P13 = "11_1261126889.13736" 
    capture_lex $P13
    .lex "map", $P13
.annotate "line", 236
    .const 'Sub' $P38 = "13_1261126889.13736" 
    capture_lex $P38
    .lex "grep", $P38
.annotate "line", 268
    .const 'Sub' $P66 = "15_1261126889.13736" 
    capture_lex $P66
    .lex "reduce", $P66
.annotate "line", 296
    .const 'Sub' $P141 = "19_1261126889.13736" 
    capture_lex $P141
    .lex "_reduce", $P141
.annotate "line", 324
    .const 'Sub' $P166 = "21_1261126889.13736" 
    capture_lex $P166
    .lex "hash", $P166
.annotate "line", 337
    .const 'Sub' $P173 = "22_1261126889.13736" 
    capture_lex $P173
    .lex "set_from_array", $P173
.annotate "line", 365
    .const 'Sub' $P195 = "24_1261126889.13736" 
    capture_lex $P195
    .lex "print", $P195
.annotate "line", 380
    .const 'Sub' $P211 = "26_1261126889.13736" 
    capture_lex $P211
    .lex "say", $P211
.annotate "line", 393
    .const 'Sub' $P218 = "27_1261126889.13736" 
    capture_lex $P218
    .lex "slurp", $P218
.annotate "line", 410
    .const 'Sub' $P233 = "28_1261126889.13736" 
    capture_lex $P233
    .lex "spew", $P233
.annotate "line", 425
    .const 'Sub' $P246 = "29_1261126889.13736" 
    capture_lex $P246
    .lex "append", $P246
.annotate "line", 453
    .const 'Sub' $P259 = "30_1261126889.13736" 
    capture_lex $P259
    .lex "fscat", $P259
.annotate "line", 473
    .const 'Sub' $P289 = "31_1261126889.13736" 
    capture_lex $P289
    .lex "user_home_dir", $P289
.annotate "line", 488
    .const 'Sub' $P306 = "32_1261126889.13736" 
    capture_lex $P306
    .lex "path_exists", $P306
.annotate "line", 507
    .const 'Sub' $P331 = "34_1261126889.13736" 
    capture_lex $P331
    .lex "is_dir", $P331
.annotate "line", 534
    .const 'Sub' $P359 = "36_1261126889.13736" 
    capture_lex $P359
    .lex "test_dir_writable", $P359
.annotate "line", 573
    .const 'Sub' $P397 = "38_1261126889.13736" 
    capture_lex $P397
    .lex "find_program", $P397
.annotate "line", 603
    .const 'Sub' $P464 = "41_1261126889.13736" 
    capture_lex $P464
    .lex "mkpath", $P464
.annotate "line", 638
    .const 'Sub' $P498 = "43_1261126889.13736" 
    capture_lex $P498
    .lex "run", $P498
.annotate "line", 656
    .const 'Sub' $P508 = "44_1261126889.13736" 
    capture_lex $P508
    .lex "do_run", $P508
.annotate "line", 680
    .const 'Sub' $P535 = "46_1261126889.13736" 
    capture_lex $P535
    .lex "qx", $P535
.annotate "line", 714
    .const 'Sub' $P563 = "47_1261126889.13736" 
    capture_lex $P563
    .lex "eval", $P563
.annotate "line", 744
    .const 'Sub' $P584 = "48_1261126889.13736" 
    capture_lex $P584
    .lex "store_dynlex_safely", $P584
.annotate "line", 864
    .const 'Sub' $P599 = "49_1261126889.13736" 
    capture_lex $P599
    .lex "replace_config_strings", $P599
.annotate "line", 876
    .const 'Sub' $P621 = "50_1261126889.13736" 
    capture_lex $P621
    .lex "config_value", $P621
.annotate "line", 80
    get_hll_global $P655, ["Hash"], "_block654" 
    capture_lex $P655
    $P655()
.annotate "line", 168
    get_hll_global $P730, ["Array"], "_block729" 
    capture_lex $P730
    $P730()
    find_lex $P751, "map"
    find_lex $P752, "grep"
    find_lex $P753, "reduce"
    find_lex $P754, "_reduce"
    find_lex $P755, "hash"
    find_lex $P756, "set_from_array"
    find_lex $P757, "print"
    find_lex $P758, "say"
    find_lex $P759, "slurp"
    find_lex $P760, "spew"
    find_lex $P761, "append"
    find_lex $P762, "fscat"
    find_lex $P763, "user_home_dir"
    find_lex $P764, "path_exists"
    find_lex $P765, "is_dir"
    find_lex $P766, "test_dir_writable"
    find_lex $P767, "find_program"
    find_lex $P768, "mkpath"
    find_lex $P769, "run"
    find_lex $P770, "do_run"
    find_lex $P771, "qx"
    find_lex $P772, "eval"
    find_lex $P773, "store_dynlex_safely"
.annotate "line", 798
    find_lex $P774, "replace_config_strings"
    find_lex $P775, "config_value"
.annotate "line", 1
    .return ($P775)
.end


.namespace []
.sub "" :load :init :subid("post63") :outer("10_1261126889.13736")
.annotate "line", 0
    .const 'Sub' $P12 = "10_1261126889.13736" 
    .local pmc block
    set block, $P12
.annotate "line", 798
    .const 'Sub' $P777 = "62_1261126889.13736" 
    capture_lex $P777
    $P777()
.end


.namespace []
.sub "_block776"  :anon :subid("62_1261126889.13736") :outer("10_1261126889.13736")
.annotate "line", 801
    new $P778, "Undef"
    .lex "$interp", $P778
.annotate "line", 802
    new $P779, "ResizablePMCArray"
    .lex "@argv", $P779
.annotate "line", 803
    new $P780, "Undef"
    .lex "$config", $P780
.annotate "line", 806
    new $P781, "Hash"
    .lex "%vm", $P781
.annotate "line", 799
    load_bytecode "config.pbc"
.annotate "line", 801
    getinterp $P782
    store_lex "$interp", $P782
.annotate "line", 802
    find_lex $P783, "$interp"
    unless_null $P783, vivify_64
    new $P783, "ResizablePMCArray"
  vivify_64:
    set $P784, $P783[2]
    unless_null $P784, vivify_65
    new $P784, "Undef"
  vivify_65:
    store_lex "@argv", $P784
.annotate "line", 803
    find_lex $P785, "$interp"
    unless_null $P785, vivify_66
    new $P785, "ResizablePMCArray"
  vivify_66:
    set $P786, $P785[6]
    unless_null $P786, vivify_67
    new $P786, "Undef"
  vivify_67:
    store_lex "$config", $P786
    find_lex $P787, "%vm"
.annotate "line", 807
    find_lex $P788, "$config"
    find_lex $P789, "%vm"
    unless_null $P789, vivify_68
    new $P789, "Hash"
    store_lex "%vm", $P789
  vivify_68:
    set $P789["config"], $P788
.annotate "line", 808
    find_lex $P790, "%vm"
    "store_dynlex_safely"("%*VM", $P790)
.annotate "line", 811
    find_lex $P792, "@argv"
    if $P792, unless_791_end
    find_lex $P793, "@argv"
    $P793."unshift"("<anonymous>")
  unless_791_end:
.annotate "line", 812
    find_lex $P794, "@argv"
    $P795 = $P794."shift"()
    "store_dynlex_safely"("$*PROGRAM_NAME", $P795)
.annotate "line", 813
    find_lex $P796, "@argv"
    "store_dynlex_safely"("@*ARGS", $P796)
.annotate "line", 816
    interpinfo $S797, 19
    "store_dynlex_safely"("$*EXECUTABLE_NAME", $S797)
.annotate "line", 819
    sysinfo $S798, 4
    "store_dynlex_safely"("$*OSNAME", $S798)
.annotate "line", 820
    sysinfo $S799, 5
    "store_dynlex_safely"("%*OSVER", $S799)
.annotate "line", 823
    new $P800, "ResizablePMCArray"
    push $P800, "parrot"
    push $P800, "Env"
    root_new $P801, $P800
    "store_dynlex_safely"("%*ENV", $P801)
.annotate "line", 824
    new $P802, "ResizablePMCArray"
    push $P802, "parrot"
    push $P802, "OS"
    root_new $P803, $P802
    $P804 = "store_dynlex_safely"("$*OS", $P803)
.annotate "line", 798
    .return ($P804)
.end


.namespace []
.sub "map"  :subid("11_1261126889.13736") :outer("10_1261126889.13736")
    .param pmc param_16
    .param pmc param_17
.annotate "line", 216
    .const 'Sub' $P25 = "12_1261126889.13736" 
    capture_lex $P25
    new $P15, 'ExceptionHandler'
    set_addr $P15, control_14
    $P15."handle_types"(58)
    push_eh $P15
    .lex "&code", param_16
    .lex "@originals", param_17
.annotate "line", 217
    new $P18, "ResizablePMCArray"
    .lex "@mapped", $P18
.annotate "line", 216
    find_lex $P19, "@mapped"
.annotate "line", 219
    find_lex $P21, "@originals"
    defined $I22, $P21
    unless $I22, for_undef_69
    iter $P20, $P21
    new $P33, 'ExceptionHandler'
    set_addr $P33, loop32_handler
    $P33."handle_types"(65, 67, 66)
    push_eh $P33
  loop32_test:
    unless $P20, loop32_done
    shift $P23, $P20
  loop32_redo:
    .const 'Sub' $P25 = "12_1261126889.13736" 
    capture_lex $P25
    $P25($P23)
  loop32_next:
    goto loop32_test
  loop32_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P34, exception, 'type'
    eq $P34, 65, loop32_next
    eq $P34, 67, loop32_redo
  loop32_done:
    pop_eh 
  for_undef_69:
.annotate "line", 223
    new $P35, "Exception"
    set $P35['type'], 58
    find_lex $P36, "@mapped"
    setattribute $P35, 'payload', $P36
    throw $P35
.annotate "line", 216
    .return ()
  control_14:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P37, exception, "payload"
    .return ($P37)
.end


.namespace []
.sub "_block24"  :anon :subid("12_1261126889.13736") :outer("11_1261126889.13736")
    .param pmc param_26
.annotate "line", 219
    .lex "$_", param_26
.annotate "line", 220
    find_lex $P27, "@mapped"
    find_lex $P28, "&code"
    find_lex $P29, "$_"
    $P30 = $P28($P29)
    $P31 = $P27."push"($P30)
.annotate "line", 219
    .return ($P31)
.end


.namespace []
.sub "grep"  :subid("13_1261126889.13736") :outer("10_1261126889.13736")
    .param pmc param_41
    .param pmc param_42
.annotate "line", 236
    .const 'Sub' $P50 = "14_1261126889.13736" 
    capture_lex $P50
    new $P40, 'ExceptionHandler'
    set_addr $P40, control_39
    $P40."handle_types"(58)
    push_eh $P40
    .lex "&code", param_41
    .lex "@all", param_42
.annotate "line", 237
    new $P43, "ResizablePMCArray"
    .lex "@matches", $P43
.annotate "line", 236
    find_lex $P44, "@matches"
.annotate "line", 239
    find_lex $P46, "@all"
    defined $I47, $P46
    unless $I47, for_undef_70
    iter $P45, $P46
    new $P61, 'ExceptionHandler'
    set_addr $P61, loop60_handler
    $P61."handle_types"(65, 67, 66)
    push_eh $P61
  loop60_test:
    unless $P45, loop60_done
    shift $P48, $P45
  loop60_redo:
    .const 'Sub' $P50 = "14_1261126889.13736" 
    capture_lex $P50
    $P50($P48)
  loop60_next:
    goto loop60_test
  loop60_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P62, exception, 'type'
    eq $P62, 65, loop60_next
    eq $P62, 67, loop60_redo
  loop60_done:
    pop_eh 
  for_undef_70:
.annotate "line", 243
    new $P63, "Exception"
    set $P63['type'], 58
    find_lex $P64, "@matches"
    setattribute $P63, 'payload', $P64
    throw $P63
.annotate "line", 236
    .return ()
  control_39:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P65, exception, "payload"
    .return ($P65)
.end


.namespace []
.sub "_block49"  :anon :subid("14_1261126889.13736") :outer("13_1261126889.13736")
    .param pmc param_51
.annotate "line", 239
    .lex "$_", param_51
.annotate "line", 240
    find_lex $P54, "&code"
    find_lex $P55, "$_"
    $P56 = $P54($P55)
    if $P56, if_53
    set $P52, $P56
    goto if_53_end
  if_53:
    find_lex $P57, "@matches"
    find_lex $P58, "$_"
    $P59 = $P57."push"($P58)
    set $P52, $P59
  if_53_end:
.annotate "line", 239
    .return ($P52)
.end


.namespace []
.sub "reduce"  :subid("15_1261126889.13736") :outer("10_1261126889.13736")
    .param pmc param_69
    .param pmc param_70
    .param pmc param_71 :slurpy
.annotate "line", 268
    .const 'Sub' $P93 = "16_1261126889.13736" 
    capture_lex $P93
    new $P68, 'ExceptionHandler'
    set_addr $P68, control_67
    $P68."handle_types"(58)
    push_eh $P68
    .lex "&code", param_69
    .lex "@array", param_70
    .lex "@initial", param_71
.annotate "line", 269
    new $P72, "Undef"
    .lex "$init_elems", $P72
    find_lex $P73, "@initial"
    elements $I74, $P73
    new $P75, 'Integer'
    set $P75, $I74
    store_lex "$init_elems", $P75
.annotate "line", 270
    find_lex $P78, "$init_elems"
    set $N79, $P78
    isgt $I80, $N79, 1.0
    if $I80, if_77
.annotate "line", 273
    find_lex $P83, "$init_elems"
    set $N84, $P83
    iseq $I85, $N84, 1.0
    if $I85, if_82
.annotate "line", 276
    .const 'Sub' $P93 = "16_1261126889.13736" 
    capture_lex $P93
    $P139 = $P93()
    set $P81, $P139
.annotate "line", 273
    goto if_82_end
  if_82:
.annotate "line", 274
    new $P86, "Exception"
    set $P86['type'], 58
    find_lex $P87, "&code"
    find_lex $P88, "@array"
    find_lex $P89, "@initial"
    unless_null $P89, vivify_77
    new $P89, "ResizablePMCArray"
  vivify_77:
    set $P90, $P89[0]
    unless_null $P90, vivify_78
    new $P90, "Undef"
  vivify_78:
    $P91 = "_reduce"($P87, $P88, $P90)
    setattribute $P86, 'payload', $P91
    throw $P86
  if_82_end:
.annotate "line", 273
    set $P76, $P81
.annotate "line", 270
    goto if_77_end
  if_77:
.annotate "line", 271
    die "Only one initial value allowed in reduce()"
  if_77_end:
.annotate "line", 268
    .return ($P76)
  control_67:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P140, exception, "payload"
    .return ($P140)
.end


.namespace []
.sub "_block92"  :anon :subid("16_1261126889.13736") :outer("15_1261126889.13736")
.annotate "line", 276
    .const 'Sub' $P118 = "18_1261126889.13736" 
    capture_lex $P118
    .const 'Sub' $P104 = "17_1261126889.13736" 
    capture_lex $P104
.annotate "line", 277
    new $P94, "Undef"
    .lex "$array_elems", $P94
    find_lex $P95, "@array"
    elements $I96, $P95
    new $P97, 'Integer'
    set $P97, $I96
    store_lex "$array_elems", $P97
.annotate "line", 278
    find_lex $P100, "$array_elems"
    set $N101, $P100
    iseq $I102, $N101, 0.0
    if $I102, if_99
.annotate "line", 281
    find_lex $P111, "$array_elems"
    set $N112, $P111
    iseq $I113, $N112, 1.0
    if $I113, if_110
.annotate "line", 284
    .const 'Sub' $P118 = "18_1261126889.13736" 
    capture_lex $P118
    $P138 = $P118()
    set $P109, $P138
.annotate "line", 281
    goto if_110_end
  if_110:
.annotate "line", 282
    new $P114, "Exception"
    set $P114['type'], 58
    find_lex $P115, "@array"
    unless_null $P115, vivify_75
    new $P115, "ResizablePMCArray"
  vivify_75:
    set $P116, $P115[0]
    unless_null $P116, vivify_76
    new $P116, "Undef"
  vivify_76:
    setattribute $P114, 'payload', $P116
    throw $P114
  if_110_end:
.annotate "line", 281
    set $P98, $P109
.annotate "line", 278
    goto if_99_end
  if_99:
    .const 'Sub' $P104 = "17_1261126889.13736" 
    capture_lex $P104
    $P108 = $P104()
    set $P98, $P108
  if_99_end:
.annotate "line", 276
    .return ($P98)
.end


.namespace []
.sub "_block117"  :anon :subid("18_1261126889.13736") :outer("16_1261126889.13736")
.annotate "line", 285
    new $P119, "Undef"
    .lex "$initial", $P119
.annotate "line", 286
    new $P120, "Undef"
    .lex "$iter", $P120
.annotate "line", 285
    find_lex $P121, "&code"
    find_lex $P122, "@array"
    unless_null $P122, vivify_71
    new $P122, "ResizablePMCArray"
  vivify_71:
    set $P123, $P122[0]
    unless_null $P123, vivify_72
    new $P123, "Undef"
  vivify_72:
    find_lex $P124, "@array"
    unless_null $P124, vivify_73
    new $P124, "ResizablePMCArray"
  vivify_73:
    set $P125, $P124[1]
    unless_null $P125, vivify_74
    new $P125, "Undef"
  vivify_74:
    $P126 = $P121($P123, $P125)
    store_lex "$initial", $P126
.annotate "line", 286
    find_lex $P127, "@array"
    iter $P128, $P127
    store_lex "$iter", $P128
.annotate "line", 288
    find_lex $P129, "$iter"
    shift $P130, $P129
.annotate "line", 289
    find_lex $P131, "$iter"
    shift $P132, $P131
.annotate "line", 291
    new $P133, "Exception"
    set $P133['type'], 58
    find_lex $P134, "&code"
    find_lex $P135, "$iter"
    find_lex $P136, "$initial"
    $P137 = "_reduce"($P134, $P135, $P136)
    setattribute $P133, 'payload', $P137
    throw $P133
.annotate "line", 284
    .return ()
.end


.namespace []
.sub "_block103"  :anon :subid("17_1261126889.13736") :outer("16_1261126889.13736")
.annotate "line", 279
    new $P105, "Undef"
    .lex "$undef", $P105
    new $P106, "Exception"
    set $P106['type'], 58
    find_lex $P107, "$undef"
    setattribute $P106, 'payload', $P107
    throw $P106
.annotate "line", 278
    .return ()
.end


.namespace []
.sub "_reduce"  :subid("19_1261126889.13736") :outer("10_1261126889.13736")
    .param pmc param_144
    .param pmc param_145
    .param pmc param_146
.annotate "line", 296
    .const 'Sub' $P154 = "20_1261126889.13736" 
    capture_lex $P154
    new $P143, 'ExceptionHandler'
    set_addr $P143, control_142
    $P143."handle_types"(58)
    push_eh $P143
    .lex "&code", param_144
    .lex "$iter", param_145
    .lex "$initial", param_146
.annotate "line", 297
    new $P147, "Undef"
    .lex "$result", $P147
    find_lex $P148, "$initial"
    store_lex "$result", $P148
.annotate "line", 299
    find_lex $P150, "$iter"
    defined $I151, $P150
    unless $I151, for_undef_79
    iter $P149, $P150
    new $P161, 'ExceptionHandler'
    set_addr $P161, loop160_handler
    $P161."handle_types"(65, 67, 66)
    push_eh $P161
  loop160_test:
    unless $P149, loop160_done
    shift $P152, $P149
  loop160_redo:
    .const 'Sub' $P154 = "20_1261126889.13736" 
    capture_lex $P154
    $P154($P152)
  loop160_next:
    goto loop160_test
  loop160_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P162, exception, 'type'
    eq $P162, 65, loop160_next
    eq $P162, 67, loop160_redo
  loop160_done:
    pop_eh 
  for_undef_79:
.annotate "line", 303
    new $P163, "Exception"
    set $P163['type'], 58
    find_lex $P164, "$result"
    setattribute $P163, 'payload', $P164
    throw $P163
.annotate "line", 296
    .return ()
  control_142:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P165, exception, "payload"
    .return ($P165)
.end


.namespace []
.sub "_block153"  :anon :subid("20_1261126889.13736") :outer("19_1261126889.13736")
    .param pmc param_155
.annotate "line", 299
    .lex "$_", param_155
.annotate "line", 300
    find_lex $P156, "&code"
    find_lex $P157, "$result"
    find_lex $P158, "$_"
    $P159 = $P156($P157, $P158)
    store_lex "$result", $P159
.annotate "line", 299
    .return ($P159)
.end


.namespace []
.sub "hash"  :subid("21_1261126889.13736") :outer("10_1261126889.13736")
    .param pmc param_169 :slurpy :named
.annotate "line", 324
    new $P168, 'ExceptionHandler'
    set_addr $P168, control_167
    $P168."handle_types"(58)
    push_eh $P168
    .lex "%h", param_169
    new $P170, "Exception"
    set $P170['type'], 58
    find_lex $P171, "%h"
    setattribute $P170, 'payload', $P171
    throw $P170
    .return ()
  control_167:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P172, exception, "payload"
    .return ($P172)
.end


.namespace []
.sub "set_from_array"  :subid("22_1261126889.13736") :outer("10_1261126889.13736")
    .param pmc param_176
.annotate "line", 337
    .const 'Sub' $P184 = "23_1261126889.13736" 
    capture_lex $P184
    new $P175, 'ExceptionHandler'
    set_addr $P175, control_174
    $P175."handle_types"(58)
    push_eh $P175
    .lex "@array", param_176
.annotate "line", 338
    new $P177, "Hash"
    .lex "%set", $P177
.annotate "line", 337
    find_lex $P178, "%set"
.annotate "line", 340
    find_lex $P180, "@array"
    defined $I181, $P180
    unless $I181, for_undef_80
    iter $P179, $P180
    new $P190, 'ExceptionHandler'
    set_addr $P190, loop189_handler
    $P190."handle_types"(65, 67, 66)
    push_eh $P190
  loop189_test:
    unless $P179, loop189_done
    shift $P182, $P179
  loop189_redo:
    .const 'Sub' $P184 = "23_1261126889.13736" 
    capture_lex $P184
    $P184($P182)
  loop189_next:
    goto loop189_test
  loop189_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P191, exception, 'type'
    eq $P191, 65, loop189_next
    eq $P191, 67, loop189_redo
  loop189_done:
    pop_eh 
  for_undef_80:
.annotate "line", 344
    new $P192, "Exception"
    set $P192['type'], 58
    find_lex $P193, "%set"
    setattribute $P192, 'payload', $P193
    throw $P192
.annotate "line", 337
    .return ()
  control_174:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P194, exception, "payload"
    .return ($P194)
.end


.namespace []
.sub "_block183"  :anon :subid("23_1261126889.13736") :outer("22_1261126889.13736")
    .param pmc param_185
.annotate "line", 340
    .lex "$_", param_185
.annotate "line", 341
    new $P186, "Integer"
    assign $P186, 1
    find_lex $P187, "$_"
    find_lex $P188, "%set"
    unless_null $P188, vivify_81
    new $P188, "Hash"
    store_lex "%set", $P188
  vivify_81:
    set $P188[$P187], $P186
.annotate "line", 340
    .return ($P186)
.end


.namespace []
.sub "print"  :subid("24_1261126889.13736") :outer("10_1261126889.13736")
    .param pmc param_198 :slurpy
.annotate "line", 365
    .const 'Sub' $P204 = "25_1261126889.13736" 
    capture_lex $P204
    new $P197, 'ExceptionHandler'
    set_addr $P197, control_196
    $P197."handle_types"(58)
    push_eh $P197
    .lex "@strings", param_198
.annotate "line", 366
    find_lex $P200, "@strings"
    defined $I201, $P200
    unless $I201, for_undef_82
    iter $P199, $P200
    new $P208, 'ExceptionHandler'
    set_addr $P208, loop207_handler
    $P208."handle_types"(65, 67, 66)
    push_eh $P208
  loop207_test:
    unless $P199, loop207_done
    shift $P202, $P199
  loop207_redo:
    .const 'Sub' $P204 = "25_1261126889.13736" 
    capture_lex $P204
    $P204($P202)
  loop207_next:
    goto loop207_test
  loop207_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P209, exception, 'type'
    eq $P209, 65, loop207_next
    eq $P209, 67, loop207_redo
  loop207_done:
    pop_eh 
  for_undef_82:
.annotate "line", 365
    .return ($P199)
  control_196:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P210, exception, "payload"
    .return ($P210)
.end


.namespace []
.sub "_block203"  :anon :subid("25_1261126889.13736") :outer("24_1261126889.13736")
    .param pmc param_205
.annotate "line", 366
    .lex "$_", param_205
.annotate "line", 367
    find_lex $P206, "$_"
    print $P206
.annotate "line", 366
    .return ()
.end


.namespace []
.sub "say"  :subid("26_1261126889.13736") :outer("10_1261126889.13736")
    .param pmc param_214 :slurpy
.annotate "line", 380
    new $P213, 'ExceptionHandler'
    set_addr $P213, control_212
    $P213."handle_types"(58)
    push_eh $P213
    .lex "@strings", param_214
.annotate "line", 381
    find_lex $P215, "@strings"
    $P216 = "print"($P215 :flat, "\n")
.annotate "line", 380
    .return ($P216)
  control_212:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P217, exception, "payload"
    .return ($P217)
.end


.namespace []
.sub "slurp"  :subid("27_1261126889.13736") :outer("10_1261126889.13736")
    .param pmc param_221
.annotate "line", 393
    new $P220, 'ExceptionHandler'
    set_addr $P220, control_219
    $P220."handle_types"(58)
    push_eh $P220
    .lex "$filename", param_221
.annotate "line", 394
    new $P222, "Undef"
    .lex "$fh", $P222
.annotate "line", 395
    new $P223, "Undef"
    .lex "$contents", $P223
.annotate "line", 394
    find_lex $P224, "$filename"
    set $S225, $P224
    open $P226, $S225, "r"
    store_lex "$fh", $P226
.annotate "line", 395
    find_lex $P227, "$fh"
    $P228 = $P227."readall"()
    store_lex "$contents", $P228
.annotate "line", 396
    find_lex $P229, "$fh"
    close $P229
.annotate "line", 398
    new $P230, "Exception"
    set $P230['type'], 58
    find_lex $P231, "$contents"
    setattribute $P230, 'payload', $P231
    throw $P230
.annotate "line", 393
    .return ()
  control_219:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P232, exception, "payload"
    .return ($P232)
.end


.namespace []
.sub "spew"  :subid("28_1261126889.13736") :outer("10_1261126889.13736")
    .param pmc param_236
    .param pmc param_237
.annotate "line", 410
    new $P235, 'ExceptionHandler'
    set_addr $P235, control_234
    $P235."handle_types"(58)
    push_eh $P235
    .lex "$filename", param_236
    .lex "$contents", param_237
.annotate "line", 411
    new $P238, "Undef"
    .lex "$fh", $P238
    find_lex $P239, "$filename"
    set $S240, $P239
    open $P241, $S240, "w"
    store_lex "$fh", $P241
.annotate "line", 412
    find_lex $P242, "$fh"
    find_lex $P243, "$contents"
    $P242."print"($P243)
.annotate "line", 413
    find_lex $P244, "$fh"
    close $P244
.annotate "line", 410
    .return ()
  control_234:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P245, exception, "payload"
    .return ($P245)
.end


.namespace []
.sub "append"  :subid("29_1261126889.13736") :outer("10_1261126889.13736")
    .param pmc param_249
    .param pmc param_250
.annotate "line", 425
    new $P248, 'ExceptionHandler'
    set_addr $P248, control_247
    $P248."handle_types"(58)
    push_eh $P248
    .lex "$filename", param_249
    .lex "$contents", param_250
.annotate "line", 426
    new $P251, "Undef"
    .lex "$fh", $P251
    find_lex $P252, "$filename"
    set $S253, $P252
    open $P254, $S253, "a"
    store_lex "$fh", $P254
.annotate "line", 427
    find_lex $P255, "$fh"
    find_lex $P256, "$contents"
    $P255."print"($P256)
.annotate "line", 428
    find_lex $P257, "$fh"
    close $P257
.annotate "line", 425
    .return ()
  control_247:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P258, exception, "payload"
    .return ($P258)
.end


.namespace []
.sub "fscat"  :subid("30_1261126889.13736") :outer("10_1261126889.13736")
    .param pmc param_262
    .param pmc param_263 :slurpy
.annotate "line", 453
    new $P261, 'ExceptionHandler'
    set_addr $P261, control_260
    $P261."handle_types"(58)
    push_eh $P261
    .lex "@path_parts", param_262
    .lex "@filename", param_263
.annotate "line", 457
    new $P264, "Undef"
    .lex "$sep", $P264
.annotate "line", 458
    new $P265, "Undef"
    .lex "$joined", $P265
.annotate "line", 455
    find_lex $P267, "@filename"
    set $N268, $P267
    isgt $I269, $N268, 1.0
    unless $I269, if_266_end
.annotate "line", 454
    die "Only one filename allowed in fscat()"
  if_266_end:
.annotate "line", 457
    getinterp $P270
    set $P271, $P270[6]
    unless_null $P271, vivify_83
    new $P271, "Hash"
  vivify_83:
    set $P272, $P271["slash"]
    unless_null $P272, vivify_84
    new $P272, "Undef"
  vivify_84:
    store_lex "$sep", $P272
.annotate "line", 458
    find_lex $P273, "$sep"
    set $S274, $P273
    find_lex $P275, "@path_parts"
    join $S276, $S274, $P275
    new $P277, 'String'
    set $P277, $S276
    store_lex "$joined", $P277
.annotate "line", 459
    find_lex $P279, "@filename"
    unless $P279, if_278_end
    find_lex $P280, "$joined"
    find_lex $P281, "$sep"
    concat $P282, $P280, $P281
    find_lex $P283, "@filename"
    unless_null $P283, vivify_85
    new $P283, "ResizablePMCArray"
  vivify_85:
    set $P284, $P283[0]
    unless_null $P284, vivify_86
    new $P284, "Undef"
  vivify_86:
    concat $P285, $P282, $P284
    store_lex "$joined", $P285
  if_278_end:
.annotate "line", 461
    new $P286, "Exception"
    set $P286['type'], 58
    find_lex $P287, "$joined"
    setattribute $P286, 'payload', $P287
    throw $P286
.annotate "line", 453
    .return ()
  control_260:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P288, exception, "payload"
    .return ($P288)
.end


.namespace []
.sub "user_home_dir"  :subid("31_1261126889.13736") :outer("10_1261126889.13736")
.annotate "line", 473
    new $P291, 'ExceptionHandler'
    set_addr $P291, control_290
    $P291."handle_types"(58)
    push_eh $P291
.annotate "line", 474
    new $P292, "Hash"
    .lex "%env", $P292
    new $P293, "ResizablePMCArray"
    push $P293, "parrot"
    push $P293, "Env"
    root_new $P294, $P293
    store_lex "%env", $P294
.annotate "line", 475
    new $P295, "Exception"
    set $P295['type'], 58
    find_lex $P297, "%env"
    unless_null $P297, vivify_87
    new $P297, "Hash"
  vivify_87:
    set $P298, $P297["HOMEDRIVE"]
    unless_null $P298, vivify_88
    new $P298, "Undef"
  vivify_88:
    set $P296, $P298
    defined $I300, $P296
    if $I300, default_299
    new $P301, "String"
    assign $P301, ""
    set $P296, $P301
  default_299:
    find_lex $P302, "%env"
    unless_null $P302, vivify_89
    new $P302, "Hash"
  vivify_89:
    set $P303, $P302["HOME"]
    unless_null $P303, vivify_90
    new $P303, "Undef"
  vivify_90:
    concat $P304, $P296, $P303
    setattribute $P295, 'payload', $P304
    throw $P295
.annotate "line", 473
    .return ()
  control_290:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P305, exception, "payload"
    .return ($P305)
.end


.namespace []
.sub "path_exists"  :subid("32_1261126889.13736") :outer("10_1261126889.13736")
    .param pmc param_309
.annotate "line", 488
    .const 'Sub' $P323 = "33_1261126889.13736" 
    capture_lex $P323
    new $P308, 'ExceptionHandler'
    set_addr $P308, control_307
    $P308."handle_types"(58)
    push_eh $P308
    new $P319, 'ExceptionHandler'
    set_addr $P319, control_318
    $P319."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P319
    .lex "$path", param_309
.annotate "line", 489
    new $P310, "ResizablePMCArray"
    .lex "@stat", $P310
    new $P311, "ResizablePMCArray"
    push $P311, "parrot"
    push $P311, "OS"
    root_new $P312, $P311
    find_lex $P313, "$path"
    $P314 = $P312."stat"($P313)
    store_lex "@stat", $P314
.annotate "line", 490
    new $P315, "Exception"
    set $P315['type'], 58
    new $P316, "Integer"
    assign $P316, 1
    setattribute $P315, 'payload', $P316
    throw $P315
.annotate "line", 488
    pop_eh 
    goto skip_handler_317
  control_318:
.annotate "line", 492
    .local pmc exception 
    .get_results (exception) 
    .const 'Sub' $P323 = "33_1261126889.13736" 
    capture_lex $P323
    $P323(exception)
    new $P328, 'Integer'
    set $P328, 1
    set exception["handled"], $P328
    set $I329, exception["handled"]
    ne $I329, 1, nothandled_321
  handled_320:
    .return (exception)
  nothandled_321:
    rethrow exception
  skip_handler_317:
.annotate "line", 488
    .return ()
  control_307:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P330, exception, "payload"
    .return ($P330)
.end


.namespace []
.sub "_block322"  :anon :subid("33_1261126889.13736") :outer("32_1261126889.13736")
    .param pmc param_324
.annotate "line", 492
    .lex "$_", param_324
    find_lex $P325, "$_"
    .lex "$!", $P325
.annotate "line", 493
    new $P326, "Exception"
    set $P326['type'], 58
    new $P327, "Integer"
    assign $P327, 0
    setattribute $P326, 'payload', $P327
    throw $P326
.annotate "line", 492
    .return ()
.end


.namespace []
.sub "is_dir"  :subid("34_1261126889.13736") :outer("10_1261126889.13736")
    .param pmc param_334
.annotate "line", 507
    .const 'Sub' $P351 = "35_1261126889.13736" 
    capture_lex $P351
    new $P333, 'ExceptionHandler'
    set_addr $P333, control_332
    $P333."handle_types"(58)
    push_eh $P333
    new $P347, 'ExceptionHandler'
    set_addr $P347, control_346
    $P347."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P347
    .lex "$path", param_334
.annotate "line", 508
    new $P335, "ResizablePMCArray"
    .lex "@stat", $P335
    new $P336, "ResizablePMCArray"
    push $P336, "parrot"
    push $P336, "OS"
    root_new $P337, $P336
    find_lex $P338, "$path"
    $P339 = $P337."stat"($P338)
    store_lex "@stat", $P339
.annotate "line", 509
    new $P340, "Exception"
    set $P340['type'], 58
    find_lex $P341, "$path"
    set $S342, $P341
    stat $I343, $S342, 2
    new $P344, 'Integer'
    set $P344, $I343
    setattribute $P340, 'payload', $P344
    throw $P340
.annotate "line", 507
    pop_eh 
    goto skip_handler_345
  control_346:
.annotate "line", 511
    .local pmc exception 
    .get_results (exception) 
    .const 'Sub' $P351 = "35_1261126889.13736" 
    capture_lex $P351
    $P351(exception)
    new $P356, 'Integer'
    set $P356, 1
    set exception["handled"], $P356
    set $I357, exception["handled"]
    ne $I357, 1, nothandled_349
  handled_348:
    .return (exception)
  nothandled_349:
    rethrow exception
  skip_handler_345:
.annotate "line", 507
    .return ()
  control_332:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P358, exception, "payload"
    .return ($P358)
.end


.namespace []
.sub "_block350"  :anon :subid("35_1261126889.13736") :outer("34_1261126889.13736")
    .param pmc param_352
.annotate "line", 511
    .lex "$_", param_352
    find_lex $P353, "$_"
    .lex "$!", $P353
.annotate "line", 512
    new $P354, "Exception"
    set $P354['type'], 58
    new $P355, "Integer"
    assign $P355, 0
    setattribute $P354, 'payload', $P355
    throw $P354
.annotate "line", 511
    .return ()
.end


.namespace []
.sub "test_dir_writable"  :subid("36_1261126889.13736") :outer("10_1261126889.13736")
    .param pmc param_362
.annotate "line", 534
    .const 'Sub' $P375 = "37_1261126889.13736" 
    capture_lex $P375
    new $P361, 'ExceptionHandler'
    set_addr $P361, control_360
    $P361."handle_types"(58)
    push_eh $P361
    .lex "$dir", param_362
.annotate "line", 535
    new $P363, "Undef"
    .lex "$test_file", $P363
    find_lex $P364, "$dir"
    new $P365, "ResizablePMCArray"
    push $P365, $P364
    $P366 = "fscat"($P365, "WrItAbLe.UtL")
    store_lex "$test_file", $P366
.annotate "line", 538
    find_lex $P368, "$test_file"
    $P369 = "path_exists"($P368)
    unless $P369, if_367_end
.annotate "line", 537
    new $P370, 'String'
    set $P370, "Test file '"
    find_lex $P371, "$test_file"
    concat $P372, $P370, $P371
    concat $P373, $P372, "'\nthat should never exist already does."
    die $P373
  if_367_end:
.annotate "line", 540
    .const 'Sub' $P375 = "37_1261126889.13736" 
    capture_lex $P375
    $P375()
.annotate "line", 544
    find_lex $P387, "$test_file"
    $P388 = "path_exists"($P387)
    if $P388, if_386
.annotate "line", 549
    new $P394, "Exception"
    set $P394['type'], 58
    new $P395, "Integer"
    assign $P395, 0
    setattribute $P394, 'payload', $P395
    throw $P394
.annotate "line", 548
    goto if_386_end
  if_386:
.annotate "line", 545
    new $P389, "ResizablePMCArray"
    push $P389, "parrot"
    push $P389, "OS"
    root_new $P390, $P389
    find_lex $P391, "$test_file"
    $P390."rm"($P391)
.annotate "line", 546
    new $P392, "Exception"
    set $P392['type'], 58
    new $P393, "Integer"
    assign $P393, 1
    setattribute $P392, 'payload', $P393
    throw $P392
  if_386_end:
.annotate "line", 534
    .return ($P385)
  control_360:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P396, exception, "payload"
    .return ($P396)
.end


.namespace []
.sub "_block374"  :anon :subid("37_1261126889.13736") :outer("36_1261126889.13736")
.annotate "line", 540
    new $P380, 'ExceptionHandler'
    set_addr $P380, control_379
    $P380."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P380
.annotate "line", 541
    find_lex $P376, "$test_file"
    $P377 = "spew"($P376, "test_dir_writable() test file.\n")
.annotate "line", 540
    pop_eh 
    goto skip_handler_378
  control_379:
    .local pmc exception 
    .get_results (exception) 
    new $P383, 'Integer'
    set $P383, 1
    set exception["handled"], $P383
    set $I384, exception["handled"]
    ne $I384, 1, nothandled_382
  handled_381:
    .return (exception)
  nothandled_382:
    rethrow exception
  skip_handler_378:
    .return ($P377)
.end


.namespace []
.sub "find_program"  :subid("38_1261126889.13736") :outer("10_1261126889.13736")
    .param pmc param_400
.annotate "line", 573
    .const 'Sub' $P431 = "39_1261126889.13736" 
    capture_lex $P431
    new $P399, 'ExceptionHandler'
    set_addr $P399, control_398
    $P399."handle_types"(58)
    push_eh $P399
    .lex "$program", param_400
.annotate "line", 574
    new $P401, "Undef"
    .lex "$path_sep", $P401
.annotate "line", 575
    new $P402, "Hash"
    .lex "%env", $P402
.annotate "line", 576
    new $P403, "ResizablePMCArray"
    .lex "@paths", $P403
.annotate "line", 577
    new $P404, "ResizablePMCArray"
    .lex "@exts", $P404
.annotate "line", 574
    sysinfo $S407, 4
    iseq $I408, $S407, "MSWin32"
    if $I408, if_406
    new $P410, "String"
    assign $P410, ":"
    set $P405, $P410
    goto if_406_end
  if_406:
    new $P409, "String"
    assign $P409, ";"
    set $P405, $P409
  if_406_end:
    store_lex "$path_sep", $P405
.annotate "line", 575
    new $P411, "ResizablePMCArray"
    push $P411, "parrot"
    push $P411, "Env"
    root_new $P412, $P411
    store_lex "%env", $P412
.annotate "line", 576
    find_lex $P413, "$path_sep"
    set $S414, $P413
    find_lex $P415, "%env"
    unless_null $P415, vivify_91
    new $P415, "Hash"
  vivify_91:
    set $P416, $P415["PATH"]
    unless_null $P416, vivify_92
    new $P416, "Undef"
  vivify_92:
    set $S417, $P416
    split $P418, $S414, $S417
    store_lex "@paths", $P418
.annotate "line", 577
    find_lex $P419, "$path_sep"
    set $S420, $P419
    find_lex $P421, "%env"
    unless_null $P421, vivify_93
    new $P421, "Hash"
  vivify_93:
    set $P422, $P421["PATHEXT"]
    unless_null $P422, vivify_94
    new $P422, "Undef"
  vivify_94:
    set $S423, $P422
    split $P424, $S420, $S423
    store_lex "@exts", $P424
.annotate "line", 579
    find_lex $P425, "@exts"
    $P425."unshift"("")
.annotate "line", 581
    find_lex $P427, "@paths"
    defined $I428, $P427
    unless $I428, for_undef_95
    iter $P426, $P427
    new $P459, 'ExceptionHandler'
    set_addr $P459, loop458_handler
    $P459."handle_types"(65, 67, 66)
    push_eh $P459
  loop458_test:
    unless $P426, loop458_done
    shift $P429, $P426
  loop458_redo:
    .const 'Sub' $P431 = "39_1261126889.13736" 
    capture_lex $P431
    $P431($P429)
  loop458_next:
    goto loop458_test
  loop458_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P460, exception, 'type'
    eq $P460, 65, loop458_next
    eq $P460, 67, loop458_redo
  loop458_done:
    pop_eh 
  for_undef_95:
.annotate "line", 590
    new $P461, "Exception"
    set $P461['type'], 58
    new $P462, "String"
    assign $P462, ""
    setattribute $P461, 'payload', $P462
    throw $P461
.annotate "line", 573
    .return ()
  control_398:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P463, exception, "payload"
    .return ($P463)
.end


.namespace []
.sub "_block430"  :anon :subid("39_1261126889.13736") :outer("38_1261126889.13736")
    .param pmc param_432
.annotate "line", 581
    .const 'Sub' $P443 = "40_1261126889.13736" 
    capture_lex $P443
    .lex "$dir", param_432
.annotate "line", 582
    new $P433, "Undef"
    .lex "$path", $P433
    find_lex $P434, "$dir"
    new $P435, "ResizablePMCArray"
    push $P435, $P434
    find_lex $P436, "$program"
    $P437 = "fscat"($P435, $P436)
    store_lex "$path", $P437
.annotate "line", 584
    find_lex $P439, "@exts"
    defined $I440, $P439
    unless $I440, for_undef_96
    iter $P438, $P439
    new $P456, 'ExceptionHandler'
    set_addr $P456, loop455_handler
    $P456."handle_types"(65, 67, 66)
    push_eh $P456
  loop455_test:
    unless $P438, loop455_done
    shift $P441, $P438
  loop455_redo:
    .const 'Sub' $P443 = "40_1261126889.13736" 
    capture_lex $P443
    $P443($P441)
  loop455_next:
    goto loop455_test
  loop455_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P457, exception, 'type'
    eq $P457, 65, loop455_next
    eq $P457, 67, loop455_redo
  loop455_done:
    pop_eh 
  for_undef_96:
.annotate "line", 581
    .return ($P438)
.end


.namespace []
.sub "_block442"  :anon :subid("40_1261126889.13736") :outer("39_1261126889.13736")
    .param pmc param_444
.annotate "line", 584
    .lex "$ext", param_444
.annotate "line", 585
    new $P445, "Undef"
    .lex "$pathext", $P445
    find_lex $P446, "$path"
    find_lex $P447, "$ext"
    concat $P448, $P446, $P447
    store_lex "$pathext", $P448
.annotate "line", 586
    find_lex $P451, "$pathext"
    $P452 = "path_exists"($P451)
    if $P452, if_450
    set $P449, $P452
    goto if_450_end
  if_450:
    new $P453, "Exception"
    set $P453['type'], 58
    find_lex $P454, "$pathext"
    setattribute $P453, 'payload', $P454
    throw $P453
  if_450_end:
.annotate "line", 584
    .return ($P449)
.end


.namespace []
.sub "mkpath"  :subid("41_1261126889.13736") :outer("10_1261126889.13736")
    .param pmc param_467
.annotate "line", 603
    .const 'Sub' $P480 = "42_1261126889.13736" 
    capture_lex $P480
    new $P466, 'ExceptionHandler'
    set_addr $P466, control_465
    $P466."handle_types"(58)
    push_eh $P466
    .lex "$path", param_467
.annotate "line", 604
    new $P468, "ResizablePMCArray"
    .lex "@path", $P468
.annotate "line", 605
    new $P469, "Undef"
    .lex "$cur", $P469
.annotate "line", 604
    find_lex $P470, "$path"
    set $S471, $P470
    split $P472, "/", $S471
    store_lex "@path", $P472
.annotate "line", 605
    find_lex $P473, "@path"
    $P474 = $P473."shift"()
    store_lex "$cur", $P474
.annotate "line", 607
    find_lex $P476, "@path"
    defined $I477, $P476
    unless $I477, for_undef_97
    iter $P475, $P476
    new $P495, 'ExceptionHandler'
    set_addr $P495, loop494_handler
    $P495."handle_types"(65, 67, 66)
    push_eh $P495
  loop494_test:
    unless $P475, loop494_done
    shift $P478, $P475
  loop494_redo:
    .const 'Sub' $P480 = "42_1261126889.13736" 
    capture_lex $P480
    $P480($P478)
  loop494_next:
    goto loop494_test
  loop494_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P496, exception, 'type'
    eq $P496, 65, loop494_next
    eq $P496, 67, loop494_redo
  loop494_done:
    pop_eh 
  for_undef_97:
.annotate "line", 603
    .return ($P475)
  control_465:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P497, exception, "payload"
    .return ($P497)
.end


.namespace []
.sub "_block479"  :anon :subid("42_1261126889.13736") :outer("41_1261126889.13736")
    .param pmc param_481
.annotate "line", 607
    .lex "$dir", param_481
.annotate "line", 608
    find_lex $P482, "$cur"
    find_lex $P483, "$dir"
    new $P484, "ResizablePMCArray"
    push $P484, $P482
    push $P484, $P483
    $P485 = "fscat"($P484)
    store_lex "$cur", $P485
.annotate "line", 610
    find_lex $P488, "$cur"
    $P489 = "path_exists"($P488)
    unless $P489, unless_487
    set $P486, $P489
    goto unless_487_end
  unless_487:
.annotate "line", 611
    new $P490, "ResizablePMCArray"
    push $P490, "parrot"
    push $P490, "OS"
    root_new $P491, $P490
    find_lex $P492, "$cur"
    $P493 = $P491."mkdir"($P492, 511)
.annotate "line", 610
    set $P486, $P493
  unless_487_end:
.annotate "line", 607
    .return ($P486)
.end


.namespace []
.sub "run"  :subid("43_1261126889.13736") :outer("10_1261126889.13736")
    .param pmc param_501 :slurpy
.annotate "line", 638
    new $P500, 'ExceptionHandler'
    set_addr $P500, control_499
    $P500."handle_types"(58)
    push_eh $P500
    .lex "@command_and_args", param_501
.annotate "line", 639
    new $P502, "Exception"
    set $P502['type'], 58
    find_lex $P503, "@command_and_args"
    spawnw $I504, $P503
    new $P505, 'Integer'
    set $P505, $I504
    shr $P506, $P505, 8
    setattribute $P502, 'payload', $P506
    throw $P502
.annotate "line", 638
    .return ()
  control_499:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P507, exception, "payload"
    .return ($P507)
.end


.namespace []
.sub "do_run"  :subid("44_1261126889.13736") :outer("10_1261126889.13736")
    .param pmc param_511 :slurpy
.annotate "line", 656
    .const 'Sub' $P527 = "45_1261126889.13736" 
    capture_lex $P527
    new $P510, 'ExceptionHandler'
    set_addr $P510, control_509
    $P510."handle_types"(58)
    push_eh $P510
    new $P523, 'ExceptionHandler'
    set_addr $P523, control_522
    $P523."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P523
    .lex "@command_and_args", param_511
.annotate "line", 657
    find_lex $P512, "@command_and_args"
    join $S513, " ", $P512
    "say"($S513)
.annotate "line", 659
    new $P514, "Exception"
    set $P514['type'], 58
    find_lex $P517, "@command_and_args"
    spawnw $I518, $P517
    if $I518, if_516
    new $P520, "Integer"
    assign $P520, 1
    set $P515, $P520
    goto if_516_end
  if_516:
    new $P519, "Integer"
    assign $P519, 0
    set $P515, $P519
  if_516_end:
    setattribute $P514, 'payload', $P515
    throw $P514
.annotate "line", 656
    pop_eh 
    goto skip_handler_521
  control_522:
.annotate "line", 661
    .local pmc exception 
    .get_results (exception) 
    .const 'Sub' $P527 = "45_1261126889.13736" 
    capture_lex $P527
    $P527(exception)
    new $P532, 'Integer'
    set $P532, 1
    set exception["handled"], $P532
    set $I533, exception["handled"]
    ne $I533, 1, nothandled_525
  handled_524:
    .return (exception)
  nothandled_525:
    rethrow exception
  skip_handler_521:
.annotate "line", 656
    .return ()
  control_509:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P534, exception, "payload"
    .return ($P534)
.end


.namespace []
.sub "_block526"  :anon :subid("45_1261126889.13736") :outer("44_1261126889.13736")
    .param pmc param_528
.annotate "line", 661
    .lex "$_", param_528
    find_lex $P529, "$_"
    .lex "$!", $P529
.annotate "line", 662
    new $P530, "Exception"
    set $P530['type'], 58
    new $P531, "Integer"
    assign $P531, -1
    setattribute $P530, 'payload', $P531
    throw $P530
.annotate "line", 661
    .return ()
.end


.namespace []
.sub "qx"  :subid("46_1261126889.13736") :outer("10_1261126889.13736")
    .param pmc param_538 :slurpy
.annotate "line", 680
    new $P537, 'ExceptionHandler'
    set_addr $P537, control_536
    $P537."handle_types"(58)
    push_eh $P537
    .lex "@command_and_args", param_538
.annotate "line", 681
    new $P539, "Undef"
    .lex "$cmd", $P539
.annotate "line", 682
    new $P540, "Undef"
    .lex "$pipe", $P540
.annotate "line", 686
    new $P541, "Undef"
    .lex "$output", $P541
.annotate "line", 681
    find_lex $P542, "@command_and_args"
    join $S543, " ", $P542
    new $P544, 'String'
    set $P544, $S543
    store_lex "$cmd", $P544
.annotate "line", 682
    find_lex $P545, "$cmd"
    set $S546, $P545
    open $P547, $S546, "rp"
    store_lex "$pipe", $P547
.annotate "line", 683
    find_lex $P549, "$pipe"
    if $P549, unless_548_end
    new $P550, 'String'
    set $P550, "Unable to execute '"
    find_lex $P551, "$cmd"
    concat $P552, $P550, $P551
    concat $P553, $P552, "'"
    die $P553
  unless_548_end:
.annotate "line", 685
    find_lex $P554, "$pipe"
    $P554."encoding"("utf8")
.annotate "line", 686
    find_lex $P555, "$pipe"
    $P556 = $P555."readall"()
    store_lex "$output", $P556
.annotate "line", 687
    find_lex $P557, "$pipe"
    $P557."close"()
.annotate "line", 689
    find_lex $P558, "$pipe"
    $P559 = $P558."exit_status"()
    "store_dynlex_safely"("$!", $P559)
.annotate "line", 691
    new $P560, "Exception"
    set $P560['type'], 58
    find_lex $P561, "$output"
    setattribute $P560, 'payload', $P561
    throw $P560
.annotate "line", 680
    .return ()
  control_536:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P562, exception, "payload"
    .return ($P562)
.end


.namespace []
.sub "eval"  :subid("47_1261126889.13736") :outer("10_1261126889.13736")
    .param pmc param_566
    .param pmc param_567
.annotate "line", 714
    new $P565, 'ExceptionHandler'
    set_addr $P565, control_564
    $P565."handle_types"(58)
    push_eh $P565
    .lex "$source_code", param_566
    .lex "$language", param_567
.annotate "line", 718
    new $P568, "Undef"
    .lex "$compiler", $P568
.annotate "line", 715
    find_lex $P569, "$language"
    set $S570, $P569
    downcase $S571, $S570
    new $P572, 'String'
    set $P572, $S571
    store_lex "$language", $P572
.annotate "line", 717
    find_lex $P573, "$language"
    set $S574, $P573
    load_language $S574
.annotate "line", 718
    find_lex $P575, "$language"
    set $S576, $P575
    compreg $P577, $S576
    store_lex "$compiler", $P577
.annotate "line", 720
    new $P578, "Exception"
    set $P578['type'], 58
    find_lex $P579, "$compiler"
    find_lex $P580, "$source_code"
    $P581 = $P579."compile"($P580)
    $P582 = $P581()
    setattribute $P578, 'payload', $P582
    throw $P578
.annotate "line", 714
    .return ()
  control_564:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P583, exception, "payload"
    .return ($P583)
.end


.namespace []
.sub "store_dynlex_safely"  :subid("48_1261126889.13736") :outer("10_1261126889.13736")
    .param pmc param_587
    .param pmc param_588
.annotate "line", 744
    new $P586, 'ExceptionHandler'
    set_addr $P586, control_585
    $P586."handle_types"(58)
    push_eh $P586
    .lex "$var_name", param_587
    .lex "$value", param_588
.annotate "line", 746
    find_lex $P591, "$var_name"
    set $S592, $P591
    find_dynamic_lex $P593, $S592
    isnull $I594, $P593
    unless $I594, unless_590
    new $P589, 'Integer'
    set $P589, $I594
    goto unless_590_end
  unless_590:
.annotate "line", 745
    find_lex $P595, "$var_name"
    set $S596, $P595
    find_lex $P597, "$value"
    store_dynamic_lex $S596, $P597
  unless_590_end:
.annotate "line", 744
    .return ($P589)
  control_585:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P598, exception, "payload"
    .return ($P598)
.end


.namespace []
.sub "replace_config_strings"  :subid("49_1261126889.13736") :outer("10_1261126889.13736")
    .param pmc param_602
.annotate "line", 864
    new $P601, 'ExceptionHandler'
    set_addr $P601, control_600
    $P601."handle_types"(58)
    push_eh $P601
    .lex "$original", param_602
.annotate "line", 865
    new $P603, "Undef"
    .lex "$new", $P603
    find_lex $P604, "$original"
    store_lex "$new", $P604
.annotate "line", 867
    new $P616, 'ExceptionHandler'
    set_addr $P616, loop615_handler
    $P616."handle_types"(65, 67, 66)
    push_eh $P616
    goto loop615_redo
  loop615_test:
.annotate "line", 871
    find_lex $P605, "$new"
    set $S606, $P605
    find_lex $P607, "$original"
    set $S608, $P607
    isne $I609, $S606, $S608
    unless $I609, loop615_done
  loop615_redo:
.annotate "line", 868
    find_lex $P610, "$new"
    store_lex "$original", $P610
.annotate "line", 869
    find_lex $P611, "$original"
    $P612 = "rx"("\\#<ident>\\#")
    get_hll_global $P613, "config_value"
    $P614 = "subst"($P611, $P612, $P613)
    store_lex "$new", $P614
  loop615_next:
.annotate "line", 867
    goto loop615_test
  loop615_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P617, exception, 'type'
    eq $P617, 65, loop615_next
    eq $P617, 67, loop615_redo
  loop615_done:
    pop_eh 
.annotate "line", 873
    new $P618, "Exception"
    set $P618['type'], 58
    find_lex $P619, "$new"
    setattribute $P618, 'payload', $P619
    throw $P618
.annotate "line", 864
    .return ()
  control_600:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P620, exception, "payload"
    .return ($P620)
.end


.namespace []
.sub "config_value"  :subid("50_1261126889.13736") :outer("10_1261126889.13736")
    .param pmc param_624
.annotate "line", 876
    new $P623, 'ExceptionHandler'
    set_addr $P623, control_622
    $P623."handle_types"(58)
    push_eh $P623
    .lex "$match", param_624
.annotate "line", 877
    new $P625, "Undef"
    .lex "$key", $P625
.annotate "line", 878
    new $P626, "Undef"
    .lex "$config", $P626
.annotate "line", 877
    find_lex $P627, "$match"
    unless_null $P627, vivify_98
    new $P627, "Hash"
  vivify_98:
    set $P628, $P627["ident"]
    unless_null $P628, vivify_99
    new $P628, "Undef"
  vivify_99:
    store_lex "$key", $P628
.annotate "line", 879
    find_lex $P637, "$key"
    find_dynamic_lex $P638, "%*CONF"
    unless_null $P638, vivify_100
    get_hll_global $P638, "%CONF"
    unless_null $P638, vivify_101
    die "Contextual %*CONF not found"
  vivify_101:
  vivify_100:
    set $P639, $P638[$P637]
    unless_null $P639, vivify_102
    new $P639, "Undef"
  vivify_102:
    unless $P639, unless_636
    set $P635, $P639
    goto unless_636_end
  unless_636:
    find_lex $P640, "$key"
    find_dynamic_lex $P641, "%*VM"
    unless_null $P641, vivify_103
    get_hll_global $P641, "%VM"
    unless_null $P641, vivify_104
    die "Contextual %*VM not found"
  vivify_104:
  vivify_103:
    set $P642, $P641["config"]
    unless_null $P642, vivify_105
    new $P642, "Hash"
  vivify_105:
    set $P643, $P642[$P640]
    unless_null $P643, vivify_106
    new $P643, "Undef"
  vivify_106:
    set $P635, $P643
  unless_636_end:
    unless $P635, unless_634
    set $P633, $P635
    goto unless_634_end
  unless_634:
    find_lex $P644, "$key"
    find_dynamic_lex $P645, "%*BIN"
    unless_null $P645, vivify_107
    get_hll_global $P645, "%BIN"
    unless_null $P645, vivify_108
    die "Contextual %*BIN not found"
  vivify_108:
  vivify_107:
    set $P646, $P645[$P644]
    unless_null $P646, vivify_109
    new $P646, "Undef"
  vivify_109:
    set $P633, $P646
  unless_634_end:
.annotate "line", 880
    unless $P633, unless_632
    set $P631, $P633
    goto unless_632_end
  unless_632:
    find_lex $P647, "$key"
    find_dynamic_lex $P648, "%*ENV"
    unless_null $P648, vivify_110
    get_hll_global $P648, "%ENV"
    unless_null $P648, vivify_111
    die "Contextual %*ENV not found"
  vivify_111:
  vivify_110:
    set $P649, $P648[$P647]
    unless_null $P649, vivify_112
    new $P649, "Undef"
  vivify_112:
    set $P631, $P649
  unless_632_end:
.annotate "line", 881
    unless $P631, unless_630
    set $P629, $P631
    goto unless_630_end
  unless_630:
    new $P650, "String"
    assign $P650, ""
    set $P629, $P650
  unless_630_end:
.annotate "line", 882
    store_lex "$config", $P629
.annotate "line", 884
    new $P651, "Exception"
    set $P651['type'], 58
    find_lex $P652, "$config"
    setattribute $P651, 'payload', $P652
    throw $P651
.annotate "line", 876
    .return ()
  control_622:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P653, exception, "payload"
    .return ($P653)
.end


.namespace ["Hash"]
.sub "_block654"  :subid("51_1261126889.13736") :outer("10_1261126889.13736")
.annotate "line", 80
    .const 'Sub' $P705 = "57_1261126889.13736" 
    capture_lex $P705
    .const 'Sub' $P684 = "55_1261126889.13736" 
    capture_lex $P684
    .const 'Sub' $P663 = "53_1261126889.13736" 
    capture_lex $P663
    .const 'Sub' $P656 = "52_1261126889.13736" 
    capture_lex $P656
.annotate "line", 143
    .const 'Sub' $P705 = "57_1261126889.13736" 
    capture_lex $P705
.annotate "line", 80
    .return ($P705)
.end


.namespace ["Hash"]
.sub "exists"  :subid("52_1261126889.13736") :method :outer("51_1261126889.13736")
    .param pmc param_659
.annotate "line", 93
    new $P658, 'ExceptionHandler'
    set_addr $P658, control_657
    $P658."handle_types"(58)
    push_eh $P658
    .lex "self", self
    .lex "$key", param_659
.annotate "line", 94
    new $P660, "Exception"
    set $P660['type'], 58

            $P1 = find_lex '$key'
            $I0 = exists self[$P1]
            $P661  = box $I0
        
    setattribute $P660, 'payload', $P661
    throw $P660
.annotate "line", 93
    .return ()
  control_657:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P662, exception, "payload"
    .return ($P662)
.end


.namespace ["Hash"]
.sub "keys"  :subid("53_1261126889.13736") :method :outer("51_1261126889.13736")
.annotate "line", 110
    .const 'Sub' $P673 = "54_1261126889.13736" 
    capture_lex $P673
    new $P665, 'ExceptionHandler'
    set_addr $P665, control_664
    $P665."handle_types"(58)
    push_eh $P665
    .lex "self", self
.annotate "line", 111
    new $P666, "ResizablePMCArray"
    .lex "@keys", $P666
.annotate "line", 110
    find_lex $P667, "@keys"
.annotate "line", 112
    find_lex $P669, "self"
    defined $I670, $P669
    unless $I670, for_undef_113
    iter $P668, $P669
    new $P680, 'ExceptionHandler'
    set_addr $P680, loop679_handler
    $P680."handle_types"(65, 67, 66)
    push_eh $P680
  loop679_test:
    unless $P668, loop679_done
    shift $P671, $P668
  loop679_redo:
    .const 'Sub' $P673 = "54_1261126889.13736" 
    capture_lex $P673
    $P673($P671)
  loop679_next:
    goto loop679_test
  loop679_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P681, exception, 'type'
    eq $P681, 65, loop679_next
    eq $P681, 67, loop679_redo
  loop679_done:
    pop_eh 
  for_undef_113:
    find_lex $P682, "@keys"
.annotate "line", 110
    .return ($P682)
  control_664:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P683, exception, "payload"
    .return ($P683)
.end


.namespace ["Hash"]
.sub "_block672"  :anon :subid("54_1261126889.13736") :outer("53_1261126889.13736")
    .param pmc param_674
.annotate "line", 112
    .lex "$_", param_674
    find_lex $P675, "@keys"
    find_lex $P676, "$_"
    $P677 = $P676."key"()
    $P678 = $P675."push"($P677)
    .return ($P678)
.end


.namespace ["Hash"]
.sub "values"  :subid("55_1261126889.13736") :method :outer("51_1261126889.13736")
.annotate "line", 125
    .const 'Sub' $P694 = "56_1261126889.13736" 
    capture_lex $P694
    new $P686, 'ExceptionHandler'
    set_addr $P686, control_685
    $P686."handle_types"(58)
    push_eh $P686
    .lex "self", self
.annotate "line", 126
    new $P687, "ResizablePMCArray"
    .lex "@values", $P687
.annotate "line", 125
    find_lex $P688, "@values"
.annotate "line", 127
    find_lex $P690, "self"
    defined $I691, $P690
    unless $I691, for_undef_114
    iter $P689, $P690
    new $P701, 'ExceptionHandler'
    set_addr $P701, loop700_handler
    $P701."handle_types"(65, 67, 66)
    push_eh $P701
  loop700_test:
    unless $P689, loop700_done
    shift $P692, $P689
  loop700_redo:
    .const 'Sub' $P694 = "56_1261126889.13736" 
    capture_lex $P694
    $P694($P692)
  loop700_next:
    goto loop700_test
  loop700_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P702, exception, 'type'
    eq $P702, 65, loop700_next
    eq $P702, 67, loop700_redo
  loop700_done:
    pop_eh 
  for_undef_114:
    find_lex $P703, "@values"
.annotate "line", 125
    .return ($P703)
  control_685:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P704, exception, "payload"
    .return ($P704)
.end


.namespace ["Hash"]
.sub "_block693"  :anon :subid("56_1261126889.13736") :outer("55_1261126889.13736")
    .param pmc param_695
.annotate "line", 127
    .lex "$_", param_695
    find_lex $P696, "@values"
    find_lex $P697, "$_"
    $P698 = $P697."value"()
    $P699 = $P696."push"($P698)
    .return ($P699)
.end


.namespace ["Hash"]
.sub "kv"  :subid("57_1261126889.13736") :method :outer("51_1261126889.13736")
.annotate "line", 143
    .const 'Sub' $P715 = "58_1261126889.13736" 
    capture_lex $P715
    new $P707, 'ExceptionHandler'
    set_addr $P707, control_706
    $P707."handle_types"(58)
    push_eh $P707
    .lex "self", self
.annotate "line", 144
    new $P708, "ResizablePMCArray"
    .lex "@kv", $P708
.annotate "line", 143
    find_lex $P709, "@kv"
.annotate "line", 145
    find_lex $P711, "self"
    defined $I712, $P711
    unless $I712, for_undef_115
    iter $P710, $P711
    new $P725, 'ExceptionHandler'
    set_addr $P725, loop724_handler
    $P725."handle_types"(65, 67, 66)
    push_eh $P725
  loop724_test:
    unless $P710, loop724_done
    shift $P713, $P710
  loop724_redo:
    .const 'Sub' $P715 = "58_1261126889.13736" 
    capture_lex $P715
    $P715($P713)
  loop724_next:
    goto loop724_test
  loop724_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P726, exception, 'type'
    eq $P726, 65, loop724_next
    eq $P726, 67, loop724_redo
  loop724_done:
    pop_eh 
  for_undef_115:
    find_lex $P727, "@kv"
.annotate "line", 143
    .return ($P727)
  control_706:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P728, exception, "payload"
    .return ($P728)
.end


.namespace ["Hash"]
.sub "_block714"  :anon :subid("58_1261126889.13736") :outer("57_1261126889.13736")
    .param pmc param_716
.annotate "line", 145
    .lex "$_", param_716
    find_lex $P717, "@kv"
    find_lex $P718, "$_"
    $P719 = $P718."key"()
    $P717."push"($P719)
    find_lex $P720, "@kv"
    find_lex $P721, "$_"
    $P722 = $P721."value"()
    $P723 = $P720."push"($P722)
    .return ($P723)
.end


.namespace ["Array"]
.sub "_block729"  :subid("59_1261126889.13736") :outer("10_1261126889.13736")
.annotate "line", 168
    .const 'Sub' $P731 = "60_1261126889.13736" 
    capture_lex $P731
.annotate "line", 181
    .const 'Sub' $P731 = "60_1261126889.13736" 
    capture_lex $P731
.annotate "line", 168
    .return ($P731)
.end


.namespace ["Array"]
.sub "reverse"  :subid("60_1261126889.13736") :method :outer("59_1261126889.13736")
.annotate "line", 181
    .const 'Sub' $P741 = "61_1261126889.13736" 
    capture_lex $P741
    new $P733, 'ExceptionHandler'
    set_addr $P733, control_732
    $P733."handle_types"(58)
    push_eh $P733
    .lex "self", self
.annotate "line", 182
    new $P734, "ResizablePMCArray"
    .lex "@reversed", $P734
.annotate "line", 181
    find_lex $P735, "@reversed"
.annotate "line", 183
    find_lex $P737, "self"
    defined $I738, $P737
    unless $I738, for_undef_116
    iter $P736, $P737
    new $P747, 'ExceptionHandler'
    set_addr $P747, loop746_handler
    $P747."handle_types"(65, 67, 66)
    push_eh $P747
  loop746_test:
    unless $P736, loop746_done
    shift $P739, $P736
  loop746_redo:
    .const 'Sub' $P741 = "61_1261126889.13736" 
    capture_lex $P741
    $P741($P739)
  loop746_next:
    goto loop746_test
  loop746_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P748, exception, 'type'
    eq $P748, 65, loop746_next
    eq $P748, 67, loop746_redo
  loop746_done:
    pop_eh 
  for_undef_116:
    find_lex $P749, "@reversed"
.annotate "line", 181
    .return ($P749)
  control_732:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P750, exception, "payload"
    .return ($P750)
.end


.namespace ["Array"]
.sub "_block740"  :anon :subid("61_1261126889.13736") :outer("60_1261126889.13736")
    .param pmc param_742
.annotate "line", 183
    .lex "$_", param_742
    find_lex $P743, "@reversed"
    find_lex $P744, "$_"
    $P745 = $P743."unshift"($P744)
    .return ($P745)
.end

