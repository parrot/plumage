
.namespace []
.sub "_block11"  :anon :subid("10_1261126406.73119")
.annotate "line", 0
    .const 'Sub' $P755 = "61_1261126406.73119" 
    capture_lex $P755
    get_hll_global $P709, ["Array"], "_block708" 
    capture_lex $P709
    get_hll_global $P634, ["Hash"], "_block633" 
    capture_lex $P634
    .const 'Sub' $P600 = "49_1261126406.73119" 
    capture_lex $P600
    .const 'Sub' $P578 = "48_1261126406.73119" 
    capture_lex $P578
    .const 'Sub' $P563 = "47_1261126406.73119" 
    capture_lex $P563
    .const 'Sub' $P535 = "46_1261126406.73119" 
    capture_lex $P535
    .const 'Sub' $P508 = "44_1261126406.73119" 
    capture_lex $P508
    .const 'Sub' $P498 = "43_1261126406.73119" 
    capture_lex $P498
    .const 'Sub' $P464 = "41_1261126406.73119" 
    capture_lex $P464
    .const 'Sub' $P397 = "38_1261126406.73119" 
    capture_lex $P397
    .const 'Sub' $P359 = "36_1261126406.73119" 
    capture_lex $P359
    .const 'Sub' $P331 = "34_1261126406.73119" 
    capture_lex $P331
    .const 'Sub' $P306 = "32_1261126406.73119" 
    capture_lex $P306
    .const 'Sub' $P289 = "31_1261126406.73119" 
    capture_lex $P289
    .const 'Sub' $P259 = "30_1261126406.73119" 
    capture_lex $P259
    .const 'Sub' $P246 = "29_1261126406.73119" 
    capture_lex $P246
    .const 'Sub' $P233 = "28_1261126406.73119" 
    capture_lex $P233
    .const 'Sub' $P218 = "27_1261126406.73119" 
    capture_lex $P218
    .const 'Sub' $P211 = "26_1261126406.73119" 
    capture_lex $P211
    .const 'Sub' $P195 = "24_1261126406.73119" 
    capture_lex $P195
    .const 'Sub' $P173 = "22_1261126406.73119" 
    capture_lex $P173
    .const 'Sub' $P166 = "21_1261126406.73119" 
    capture_lex $P166
    .const 'Sub' $P141 = "19_1261126406.73119" 
    capture_lex $P141
    .const 'Sub' $P66 = "15_1261126406.73119" 
    capture_lex $P66
    .const 'Sub' $P38 = "13_1261126406.73119" 
    capture_lex $P38
    .const 'Sub' $P13 = "11_1261126406.73119" 
    capture_lex $P13
.annotate "line", 213
    .const 'Sub' $P13 = "11_1261126406.73119" 
    capture_lex $P13
    .lex "map", $P13
.annotate "line", 233
    .const 'Sub' $P38 = "13_1261126406.73119" 
    capture_lex $P38
    .lex "grep", $P38
.annotate "line", 265
    .const 'Sub' $P66 = "15_1261126406.73119" 
    capture_lex $P66
    .lex "reduce", $P66
.annotate "line", 293
    .const 'Sub' $P141 = "19_1261126406.73119" 
    capture_lex $P141
    .lex "_reduce", $P141
.annotate "line", 321
    .const 'Sub' $P166 = "21_1261126406.73119" 
    capture_lex $P166
    .lex "hash", $P166
.annotate "line", 334
    .const 'Sub' $P173 = "22_1261126406.73119" 
    capture_lex $P173
    .lex "set_from_array", $P173
.annotate "line", 362
    .const 'Sub' $P195 = "24_1261126406.73119" 
    capture_lex $P195
    .lex "print", $P195
.annotate "line", 377
    .const 'Sub' $P211 = "26_1261126406.73119" 
    capture_lex $P211
    .lex "say", $P211
.annotate "line", 390
    .const 'Sub' $P218 = "27_1261126406.73119" 
    capture_lex $P218
    .lex "slurp", $P218
.annotate "line", 407
    .const 'Sub' $P233 = "28_1261126406.73119" 
    capture_lex $P233
    .lex "spew", $P233
.annotate "line", 422
    .const 'Sub' $P246 = "29_1261126406.73119" 
    capture_lex $P246
    .lex "append", $P246
.annotate "line", 450
    .const 'Sub' $P259 = "30_1261126406.73119" 
    capture_lex $P259
    .lex "fscat", $P259
.annotate "line", 470
    .const 'Sub' $P289 = "31_1261126406.73119" 
    capture_lex $P289
    .lex "user_home_dir", $P289
.annotate "line", 485
    .const 'Sub' $P306 = "32_1261126406.73119" 
    capture_lex $P306
    .lex "path_exists", $P306
.annotate "line", 504
    .const 'Sub' $P331 = "34_1261126406.73119" 
    capture_lex $P331
    .lex "is_dir", $P331
.annotate "line", 531
    .const 'Sub' $P359 = "36_1261126406.73119" 
    capture_lex $P359
    .lex "test_dir_writable", $P359
.annotate "line", 570
    .const 'Sub' $P397 = "38_1261126406.73119" 
    capture_lex $P397
    .lex "find_program", $P397
.annotate "line", 600
    .const 'Sub' $P464 = "41_1261126406.73119" 
    capture_lex $P464
    .lex "mkpath", $P464
.annotate "line", 635
    .const 'Sub' $P498 = "43_1261126406.73119" 
    capture_lex $P498
    .lex "run", $P498
.annotate "line", 653
    .const 'Sub' $P508 = "44_1261126406.73119" 
    capture_lex $P508
    .lex "do_run", $P508
.annotate "line", 677
    .const 'Sub' $P535 = "46_1261126406.73119" 
    capture_lex $P535
    .lex "qx", $P535
.annotate "line", 712
    .const 'Sub' $P563 = "47_1261126406.73119" 
    capture_lex $P563
    .lex "store_dynlex_safely", $P563
.annotate "line", 832
    .const 'Sub' $P578 = "48_1261126406.73119" 
    capture_lex $P578
    .lex "replace_config_strings", $P578
.annotate "line", 844
    .const 'Sub' $P600 = "49_1261126406.73119" 
    capture_lex $P600
    .lex "config_value", $P600
.annotate "line", 77
    get_hll_global $P634, ["Hash"], "_block633" 
    capture_lex $P634
    $P634()
.annotate "line", 165
    get_hll_global $P709, ["Array"], "_block708" 
    capture_lex $P709
    $P709()
    find_lex $P730, "map"
    find_lex $P731, "grep"
    find_lex $P732, "reduce"
    find_lex $P733, "_reduce"
    find_lex $P734, "hash"
    find_lex $P735, "set_from_array"
    find_lex $P736, "print"
    find_lex $P737, "say"
    find_lex $P738, "slurp"
    find_lex $P739, "spew"
    find_lex $P740, "append"
    find_lex $P741, "fscat"
    find_lex $P742, "user_home_dir"
    find_lex $P743, "path_exists"
    find_lex $P744, "is_dir"
    find_lex $P745, "test_dir_writable"
    find_lex $P746, "find_program"
    find_lex $P747, "mkpath"
    find_lex $P748, "run"
    find_lex $P749, "do_run"
    find_lex $P750, "qx"
    find_lex $P751, "store_dynlex_safely"
.annotate "line", 766
    find_lex $P752, "replace_config_strings"
    find_lex $P753, "config_value"
.annotate "line", 1
    .return ($P753)
.end


.namespace []
.sub "" :load :init :subid("post62") :outer("10_1261126406.73119")
.annotate "line", 0
    .const 'Sub' $P12 = "10_1261126406.73119" 
    .local pmc block
    set block, $P12
.annotate "line", 766
    .const 'Sub' $P755 = "61_1261126406.73119" 
    capture_lex $P755
    $P755()
.end


.namespace []
.sub "_block754"  :anon :subid("61_1261126406.73119") :outer("10_1261126406.73119")
.annotate "line", 769
    new $P756, "Undef"
    .lex "$interp", $P756
.annotate "line", 770
    new $P757, "ResizablePMCArray"
    .lex "@argv", $P757
.annotate "line", 771
    new $P758, "Undef"
    .lex "$config", $P758
.annotate "line", 774
    new $P759, "Hash"
    .lex "%vm", $P759
.annotate "line", 767
    load_bytecode "config.pbc"
.annotate "line", 769
    getinterp $P760
    store_lex "$interp", $P760
.annotate "line", 770
    find_lex $P761, "$interp"
    unless_null $P761, vivify_63
    new $P761, "ResizablePMCArray"
  vivify_63:
    set $P762, $P761[2]
    unless_null $P762, vivify_64
    new $P762, "Undef"
  vivify_64:
    store_lex "@argv", $P762
.annotate "line", 771
    find_lex $P763, "$interp"
    unless_null $P763, vivify_65
    new $P763, "ResizablePMCArray"
  vivify_65:
    set $P764, $P763[6]
    unless_null $P764, vivify_66
    new $P764, "Undef"
  vivify_66:
    store_lex "$config", $P764
    find_lex $P765, "%vm"
.annotate "line", 775
    find_lex $P766, "$config"
    find_lex $P767, "%vm"
    unless_null $P767, vivify_67
    new $P767, "Hash"
    store_lex "%vm", $P767
  vivify_67:
    set $P767["config"], $P766
.annotate "line", 776
    find_lex $P768, "%vm"
    "store_dynlex_safely"("%*VM", $P768)
.annotate "line", 779
    find_lex $P770, "@argv"
    if $P770, unless_769_end
    find_lex $P771, "@argv"
    $P771."unshift"("<anonymous>")
  unless_769_end:
.annotate "line", 780
    find_lex $P772, "@argv"
    $P773 = $P772."shift"()
    "store_dynlex_safely"("$*PROGRAM_NAME", $P773)
.annotate "line", 781
    find_lex $P774, "@argv"
    "store_dynlex_safely"("@*ARGS", $P774)
.annotate "line", 784
    interpinfo $S775, 19
    "store_dynlex_safely"("$*EXECUTABLE_NAME", $S775)
.annotate "line", 787
    sysinfo $S776, 4
    "store_dynlex_safely"("$*OSNAME", $S776)
.annotate "line", 788
    sysinfo $S777, 5
    "store_dynlex_safely"("%*OSVER", $S777)
.annotate "line", 791
    new $P778, "ResizablePMCArray"
    push $P778, "parrot"
    push $P778, "Env"
    root_new $P779, $P778
    "store_dynlex_safely"("%*ENV", $P779)
.annotate "line", 792
    new $P780, "ResizablePMCArray"
    push $P780, "parrot"
    push $P780, "OS"
    root_new $P781, $P780
    $P782 = "store_dynlex_safely"("$*OS", $P781)
.annotate "line", 766
    .return ($P782)
.end


.namespace []
.sub "map"  :subid("11_1261126406.73119") :outer("10_1261126406.73119")
    .param pmc param_16
    .param pmc param_17
.annotate "line", 213
    .const 'Sub' $P25 = "12_1261126406.73119" 
    capture_lex $P25
    new $P15, 'ExceptionHandler'
    set_addr $P15, control_14
    $P15."handle_types"(58)
    push_eh $P15
    .lex "&code", param_16
    .lex "@originals", param_17
.annotate "line", 214
    new $P18, "ResizablePMCArray"
    .lex "@mapped", $P18
.annotate "line", 213
    find_lex $P19, "@mapped"
.annotate "line", 216
    find_lex $P21, "@originals"
    defined $I22, $P21
    unless $I22, for_undef_68
    iter $P20, $P21
    new $P33, 'ExceptionHandler'
    set_addr $P33, loop32_handler
    $P33."handle_types"(65, 67, 66)
    push_eh $P33
  loop32_test:
    unless $P20, loop32_done
    shift $P23, $P20
  loop32_redo:
    .const 'Sub' $P25 = "12_1261126406.73119" 
    capture_lex $P25
    $P25($P23)
  loop32_next:
    goto loop32_test
  loop32_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P34, exception, 'type'
    eq $P34, 65, loop32_next
    eq $P34, 67, loop32_redo
  loop32_done:
    pop_eh 
  for_undef_68:
.annotate "line", 220
    new $P35, "Exception"
    set $P35['type'], 58
    find_lex $P36, "@mapped"
    setattribute $P35, 'payload', $P36
    throw $P35
.annotate "line", 213
    .return ()
  control_14:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P37, exception, "payload"
    .return ($P37)
.end


.namespace []
.sub "_block24"  :anon :subid("12_1261126406.73119") :outer("11_1261126406.73119")
    .param pmc param_26
.annotate "line", 216
    .lex "$_", param_26
.annotate "line", 217
    find_lex $P27, "@mapped"
    find_lex $P28, "&code"
    find_lex $P29, "$_"
    $P30 = $P28($P29)
    $P31 = $P27."push"($P30)
.annotate "line", 216
    .return ($P31)
.end


.namespace []
.sub "grep"  :subid("13_1261126406.73119") :outer("10_1261126406.73119")
    .param pmc param_41
    .param pmc param_42
.annotate "line", 233
    .const 'Sub' $P50 = "14_1261126406.73119" 
    capture_lex $P50
    new $P40, 'ExceptionHandler'
    set_addr $P40, control_39
    $P40."handle_types"(58)
    push_eh $P40
    .lex "&code", param_41
    .lex "@all", param_42
.annotate "line", 234
    new $P43, "ResizablePMCArray"
    .lex "@matches", $P43
.annotate "line", 233
    find_lex $P44, "@matches"
.annotate "line", 236
    find_lex $P46, "@all"
    defined $I47, $P46
    unless $I47, for_undef_69
    iter $P45, $P46
    new $P61, 'ExceptionHandler'
    set_addr $P61, loop60_handler
    $P61."handle_types"(65, 67, 66)
    push_eh $P61
  loop60_test:
    unless $P45, loop60_done
    shift $P48, $P45
  loop60_redo:
    .const 'Sub' $P50 = "14_1261126406.73119" 
    capture_lex $P50
    $P50($P48)
  loop60_next:
    goto loop60_test
  loop60_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P62, exception, 'type'
    eq $P62, 65, loop60_next
    eq $P62, 67, loop60_redo
  loop60_done:
    pop_eh 
  for_undef_69:
.annotate "line", 240
    new $P63, "Exception"
    set $P63['type'], 58
    find_lex $P64, "@matches"
    setattribute $P63, 'payload', $P64
    throw $P63
.annotate "line", 233
    .return ()
  control_39:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P65, exception, "payload"
    .return ($P65)
.end


.namespace []
.sub "_block49"  :anon :subid("14_1261126406.73119") :outer("13_1261126406.73119")
    .param pmc param_51
.annotate "line", 236
    .lex "$_", param_51
.annotate "line", 237
    find_lex $P54, "&code"
    find_lex $P55, "$_"
    $P56 = $P54($P55)
    if $P56, if_53
    set $P52, $P56
    goto if_53_end
  if_53:
    find_lex $P57, "@matches"
    find_lex $P58, "$_"
    $P59 = $P57."push"($P58)
    set $P52, $P59
  if_53_end:
.annotate "line", 236
    .return ($P52)
.end


.namespace []
.sub "reduce"  :subid("15_1261126406.73119") :outer("10_1261126406.73119")
    .param pmc param_69
    .param pmc param_70
    .param pmc param_71 :slurpy
.annotate "line", 265
    .const 'Sub' $P93 = "16_1261126406.73119" 
    capture_lex $P93
    new $P68, 'ExceptionHandler'
    set_addr $P68, control_67
    $P68."handle_types"(58)
    push_eh $P68
    .lex "&code", param_69
    .lex "@array", param_70
    .lex "@initial", param_71
.annotate "line", 266
    new $P72, "Undef"
    .lex "$init_elems", $P72
    find_lex $P73, "@initial"
    elements $I74, $P73
    new $P75, 'Integer'
    set $P75, $I74
    store_lex "$init_elems", $P75
.annotate "line", 267
    find_lex $P78, "$init_elems"
    set $N79, $P78
    isgt $I80, $N79, 1.0
    if $I80, if_77
.annotate "line", 270
    find_lex $P83, "$init_elems"
    set $N84, $P83
    iseq $I85, $N84, 1.0
    if $I85, if_82
.annotate "line", 273
    .const 'Sub' $P93 = "16_1261126406.73119" 
    capture_lex $P93
    $P139 = $P93()
    set $P81, $P139
.annotate "line", 270
    goto if_82_end
  if_82:
.annotate "line", 271
    new $P86, "Exception"
    set $P86['type'], 58
    find_lex $P87, "&code"
    find_lex $P88, "@array"
    find_lex $P89, "@initial"
    unless_null $P89, vivify_76
    new $P89, "ResizablePMCArray"
  vivify_76:
    set $P90, $P89[0]
    unless_null $P90, vivify_77
    new $P90, "Undef"
  vivify_77:
    $P91 = "_reduce"($P87, $P88, $P90)
    setattribute $P86, 'payload', $P91
    throw $P86
  if_82_end:
.annotate "line", 270
    set $P76, $P81
.annotate "line", 267
    goto if_77_end
  if_77:
.annotate "line", 268
    die "Only one initial value allowed in reduce()"
  if_77_end:
.annotate "line", 265
    .return ($P76)
  control_67:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P140, exception, "payload"
    .return ($P140)
.end


.namespace []
.sub "_block92"  :anon :subid("16_1261126406.73119") :outer("15_1261126406.73119")
.annotate "line", 273
    .const 'Sub' $P118 = "18_1261126406.73119" 
    capture_lex $P118
    .const 'Sub' $P104 = "17_1261126406.73119" 
    capture_lex $P104
.annotate "line", 274
    new $P94, "Undef"
    .lex "$array_elems", $P94
    find_lex $P95, "@array"
    elements $I96, $P95
    new $P97, 'Integer'
    set $P97, $I96
    store_lex "$array_elems", $P97
.annotate "line", 275
    find_lex $P100, "$array_elems"
    set $N101, $P100
    iseq $I102, $N101, 0.0
    if $I102, if_99
.annotate "line", 278
    find_lex $P111, "$array_elems"
    set $N112, $P111
    iseq $I113, $N112, 1.0
    if $I113, if_110
.annotate "line", 281
    .const 'Sub' $P118 = "18_1261126406.73119" 
    capture_lex $P118
    $P138 = $P118()
    set $P109, $P138
.annotate "line", 278
    goto if_110_end
  if_110:
.annotate "line", 279
    new $P114, "Exception"
    set $P114['type'], 58
    find_lex $P115, "@array"
    unless_null $P115, vivify_74
    new $P115, "ResizablePMCArray"
  vivify_74:
    set $P116, $P115[0]
    unless_null $P116, vivify_75
    new $P116, "Undef"
  vivify_75:
    setattribute $P114, 'payload', $P116
    throw $P114
  if_110_end:
.annotate "line", 278
    set $P98, $P109
.annotate "line", 275
    goto if_99_end
  if_99:
    .const 'Sub' $P104 = "17_1261126406.73119" 
    capture_lex $P104
    $P108 = $P104()
    set $P98, $P108
  if_99_end:
.annotate "line", 273
    .return ($P98)
.end


.namespace []
.sub "_block117"  :anon :subid("18_1261126406.73119") :outer("16_1261126406.73119")
.annotate "line", 282
    new $P119, "Undef"
    .lex "$initial", $P119
.annotate "line", 283
    new $P120, "Undef"
    .lex "$iter", $P120
.annotate "line", 282
    find_lex $P121, "&code"
    find_lex $P122, "@array"
    unless_null $P122, vivify_70
    new $P122, "ResizablePMCArray"
  vivify_70:
    set $P123, $P122[0]
    unless_null $P123, vivify_71
    new $P123, "Undef"
  vivify_71:
    find_lex $P124, "@array"
    unless_null $P124, vivify_72
    new $P124, "ResizablePMCArray"
  vivify_72:
    set $P125, $P124[1]
    unless_null $P125, vivify_73
    new $P125, "Undef"
  vivify_73:
    $P126 = $P121($P123, $P125)
    store_lex "$initial", $P126
.annotate "line", 283
    find_lex $P127, "@array"
    iter $P128, $P127
    store_lex "$iter", $P128
.annotate "line", 285
    find_lex $P129, "$iter"
    shift $P130, $P129
.annotate "line", 286
    find_lex $P131, "$iter"
    shift $P132, $P131
.annotate "line", 288
    new $P133, "Exception"
    set $P133['type'], 58
    find_lex $P134, "&code"
    find_lex $P135, "$iter"
    find_lex $P136, "$initial"
    $P137 = "_reduce"($P134, $P135, $P136)
    setattribute $P133, 'payload', $P137
    throw $P133
.annotate "line", 281
    .return ()
.end


.namespace []
.sub "_block103"  :anon :subid("17_1261126406.73119") :outer("16_1261126406.73119")
.annotate "line", 276
    new $P105, "Undef"
    .lex "$undef", $P105
    new $P106, "Exception"
    set $P106['type'], 58
    find_lex $P107, "$undef"
    setattribute $P106, 'payload', $P107
    throw $P106
.annotate "line", 275
    .return ()
.end


.namespace []
.sub "_reduce"  :subid("19_1261126406.73119") :outer("10_1261126406.73119")
    .param pmc param_144
    .param pmc param_145
    .param pmc param_146
.annotate "line", 293
    .const 'Sub' $P154 = "20_1261126406.73119" 
    capture_lex $P154
    new $P143, 'ExceptionHandler'
    set_addr $P143, control_142
    $P143."handle_types"(58)
    push_eh $P143
    .lex "&code", param_144
    .lex "$iter", param_145
    .lex "$initial", param_146
.annotate "line", 294
    new $P147, "Undef"
    .lex "$result", $P147
    find_lex $P148, "$initial"
    store_lex "$result", $P148
.annotate "line", 296
    find_lex $P150, "$iter"
    defined $I151, $P150
    unless $I151, for_undef_78
    iter $P149, $P150
    new $P161, 'ExceptionHandler'
    set_addr $P161, loop160_handler
    $P161."handle_types"(65, 67, 66)
    push_eh $P161
  loop160_test:
    unless $P149, loop160_done
    shift $P152, $P149
  loop160_redo:
    .const 'Sub' $P154 = "20_1261126406.73119" 
    capture_lex $P154
    $P154($P152)
  loop160_next:
    goto loop160_test
  loop160_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P162, exception, 'type'
    eq $P162, 65, loop160_next
    eq $P162, 67, loop160_redo
  loop160_done:
    pop_eh 
  for_undef_78:
.annotate "line", 300
    new $P163, "Exception"
    set $P163['type'], 58
    find_lex $P164, "$result"
    setattribute $P163, 'payload', $P164
    throw $P163
.annotate "line", 293
    .return ()
  control_142:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P165, exception, "payload"
    .return ($P165)
.end


.namespace []
.sub "_block153"  :anon :subid("20_1261126406.73119") :outer("19_1261126406.73119")
    .param pmc param_155
.annotate "line", 296
    .lex "$_", param_155
.annotate "line", 297
    find_lex $P156, "&code"
    find_lex $P157, "$result"
    find_lex $P158, "$_"
    $P159 = $P156($P157, $P158)
    store_lex "$result", $P159
.annotate "line", 296
    .return ($P159)
.end


.namespace []
.sub "hash"  :subid("21_1261126406.73119") :outer("10_1261126406.73119")
    .param pmc param_169 :slurpy :named
.annotate "line", 321
    new $P168, 'ExceptionHandler'
    set_addr $P168, control_167
    $P168."handle_types"(58)
    push_eh $P168
    .lex "%h", param_169
    new $P170, "Exception"
    set $P170['type'], 58
    find_lex $P171, "%h"
    setattribute $P170, 'payload', $P171
    throw $P170
    .return ()
  control_167:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P172, exception, "payload"
    .return ($P172)
.end


.namespace []
.sub "set_from_array"  :subid("22_1261126406.73119") :outer("10_1261126406.73119")
    .param pmc param_176
.annotate "line", 334
    .const 'Sub' $P184 = "23_1261126406.73119" 
    capture_lex $P184
    new $P175, 'ExceptionHandler'
    set_addr $P175, control_174
    $P175."handle_types"(58)
    push_eh $P175
    .lex "@array", param_176
.annotate "line", 335
    new $P177, "Hash"
    .lex "%set", $P177
.annotate "line", 334
    find_lex $P178, "%set"
.annotate "line", 337
    find_lex $P180, "@array"
    defined $I181, $P180
    unless $I181, for_undef_79
    iter $P179, $P180
    new $P190, 'ExceptionHandler'
    set_addr $P190, loop189_handler
    $P190."handle_types"(65, 67, 66)
    push_eh $P190
  loop189_test:
    unless $P179, loop189_done
    shift $P182, $P179
  loop189_redo:
    .const 'Sub' $P184 = "23_1261126406.73119" 
    capture_lex $P184
    $P184($P182)
  loop189_next:
    goto loop189_test
  loop189_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P191, exception, 'type'
    eq $P191, 65, loop189_next
    eq $P191, 67, loop189_redo
  loop189_done:
    pop_eh 
  for_undef_79:
.annotate "line", 341
    new $P192, "Exception"
    set $P192['type'], 58
    find_lex $P193, "%set"
    setattribute $P192, 'payload', $P193
    throw $P192
.annotate "line", 334
    .return ()
  control_174:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P194, exception, "payload"
    .return ($P194)
.end


.namespace []
.sub "_block183"  :anon :subid("23_1261126406.73119") :outer("22_1261126406.73119")
    .param pmc param_185
.annotate "line", 337
    .lex "$_", param_185
.annotate "line", 338
    new $P186, "Integer"
    assign $P186, 1
    find_lex $P187, "$_"
    find_lex $P188, "%set"
    unless_null $P188, vivify_80
    new $P188, "Hash"
    store_lex "%set", $P188
  vivify_80:
    set $P188[$P187], $P186
.annotate "line", 337
    .return ($P186)
.end


.namespace []
.sub "print"  :subid("24_1261126406.73119") :outer("10_1261126406.73119")
    .param pmc param_198 :slurpy
.annotate "line", 362
    .const 'Sub' $P204 = "25_1261126406.73119" 
    capture_lex $P204
    new $P197, 'ExceptionHandler'
    set_addr $P197, control_196
    $P197."handle_types"(58)
    push_eh $P197
    .lex "@strings", param_198
.annotate "line", 363
    find_lex $P200, "@strings"
    defined $I201, $P200
    unless $I201, for_undef_81
    iter $P199, $P200
    new $P208, 'ExceptionHandler'
    set_addr $P208, loop207_handler
    $P208."handle_types"(65, 67, 66)
    push_eh $P208
  loop207_test:
    unless $P199, loop207_done
    shift $P202, $P199
  loop207_redo:
    .const 'Sub' $P204 = "25_1261126406.73119" 
    capture_lex $P204
    $P204($P202)
  loop207_next:
    goto loop207_test
  loop207_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P209, exception, 'type'
    eq $P209, 65, loop207_next
    eq $P209, 67, loop207_redo
  loop207_done:
    pop_eh 
  for_undef_81:
.annotate "line", 362
    .return ($P199)
  control_196:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P210, exception, "payload"
    .return ($P210)
.end


.namespace []
.sub "_block203"  :anon :subid("25_1261126406.73119") :outer("24_1261126406.73119")
    .param pmc param_205
.annotate "line", 363
    .lex "$_", param_205
.annotate "line", 364
    find_lex $P206, "$_"
    print $P206
.annotate "line", 363
    .return ()
.end


.namespace []
.sub "say"  :subid("26_1261126406.73119") :outer("10_1261126406.73119")
    .param pmc param_214 :slurpy
.annotate "line", 377
    new $P213, 'ExceptionHandler'
    set_addr $P213, control_212
    $P213."handle_types"(58)
    push_eh $P213
    .lex "@strings", param_214
.annotate "line", 378
    find_lex $P215, "@strings"
    $P216 = "print"($P215 :flat, "\n")
.annotate "line", 377
    .return ($P216)
  control_212:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P217, exception, "payload"
    .return ($P217)
.end


.namespace []
.sub "slurp"  :subid("27_1261126406.73119") :outer("10_1261126406.73119")
    .param pmc param_221
.annotate "line", 390
    new $P220, 'ExceptionHandler'
    set_addr $P220, control_219
    $P220."handle_types"(58)
    push_eh $P220
    .lex "$filename", param_221
.annotate "line", 391
    new $P222, "Undef"
    .lex "$fh", $P222
.annotate "line", 392
    new $P223, "Undef"
    .lex "$contents", $P223
.annotate "line", 391
    find_lex $P224, "$filename"
    set $S225, $P224
    open $P226, $S225, "r"
    store_lex "$fh", $P226
.annotate "line", 392
    find_lex $P227, "$fh"
    $P228 = $P227."readall"()
    store_lex "$contents", $P228
.annotate "line", 393
    find_lex $P229, "$fh"
    close $P229
.annotate "line", 395
    new $P230, "Exception"
    set $P230['type'], 58
    find_lex $P231, "$contents"
    setattribute $P230, 'payload', $P231
    throw $P230
.annotate "line", 390
    .return ()
  control_219:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P232, exception, "payload"
    .return ($P232)
.end


.namespace []
.sub "spew"  :subid("28_1261126406.73119") :outer("10_1261126406.73119")
    .param pmc param_236
    .param pmc param_237
.annotate "line", 407
    new $P235, 'ExceptionHandler'
    set_addr $P235, control_234
    $P235."handle_types"(58)
    push_eh $P235
    .lex "$filename", param_236
    .lex "$contents", param_237
.annotate "line", 408
    new $P238, "Undef"
    .lex "$fh", $P238
    find_lex $P239, "$filename"
    set $S240, $P239
    open $P241, $S240, "w"
    store_lex "$fh", $P241
.annotate "line", 409
    find_lex $P242, "$fh"
    find_lex $P243, "$contents"
    $P242."print"($P243)
.annotate "line", 410
    find_lex $P244, "$fh"
    close $P244
.annotate "line", 407
    .return ()
  control_234:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P245, exception, "payload"
    .return ($P245)
.end


.namespace []
.sub "append"  :subid("29_1261126406.73119") :outer("10_1261126406.73119")
    .param pmc param_249
    .param pmc param_250
.annotate "line", 422
    new $P248, 'ExceptionHandler'
    set_addr $P248, control_247
    $P248."handle_types"(58)
    push_eh $P248
    .lex "$filename", param_249
    .lex "$contents", param_250
.annotate "line", 423
    new $P251, "Undef"
    .lex "$fh", $P251
    find_lex $P252, "$filename"
    set $S253, $P252
    open $P254, $S253, "a"
    store_lex "$fh", $P254
.annotate "line", 424
    find_lex $P255, "$fh"
    find_lex $P256, "$contents"
    $P255."print"($P256)
.annotate "line", 425
    find_lex $P257, "$fh"
    close $P257
.annotate "line", 422
    .return ()
  control_247:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P258, exception, "payload"
    .return ($P258)
.end


.namespace []
.sub "fscat"  :subid("30_1261126406.73119") :outer("10_1261126406.73119")
    .param pmc param_262
    .param pmc param_263 :slurpy
.annotate "line", 450
    new $P261, 'ExceptionHandler'
    set_addr $P261, control_260
    $P261."handle_types"(58)
    push_eh $P261
    .lex "@path_parts", param_262
    .lex "@filename", param_263
.annotate "line", 454
    new $P264, "Undef"
    .lex "$sep", $P264
.annotate "line", 455
    new $P265, "Undef"
    .lex "$joined", $P265
.annotate "line", 452
    find_lex $P267, "@filename"
    set $N268, $P267
    isgt $I269, $N268, 1.0
    unless $I269, if_266_end
.annotate "line", 451
    die "Only one filename allowed in fscat()"
  if_266_end:
.annotate "line", 454
    getinterp $P270
    set $P271, $P270[6]
    unless_null $P271, vivify_82
    new $P271, "Hash"
  vivify_82:
    set $P272, $P271["slash"]
    unless_null $P272, vivify_83
    new $P272, "Undef"
  vivify_83:
    store_lex "$sep", $P272
.annotate "line", 455
    find_lex $P273, "$sep"
    set $S274, $P273
    find_lex $P275, "@path_parts"
    join $S276, $S274, $P275
    new $P277, 'String'
    set $P277, $S276
    store_lex "$joined", $P277
.annotate "line", 456
    find_lex $P279, "@filename"
    unless $P279, if_278_end
    find_lex $P280, "$joined"
    find_lex $P281, "$sep"
    concat $P282, $P280, $P281
    find_lex $P283, "@filename"
    unless_null $P283, vivify_84
    new $P283, "ResizablePMCArray"
  vivify_84:
    set $P284, $P283[0]
    unless_null $P284, vivify_85
    new $P284, "Undef"
  vivify_85:
    concat $P285, $P282, $P284
    store_lex "$joined", $P285
  if_278_end:
.annotate "line", 458
    new $P286, "Exception"
    set $P286['type'], 58
    find_lex $P287, "$joined"
    setattribute $P286, 'payload', $P287
    throw $P286
.annotate "line", 450
    .return ()
  control_260:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P288, exception, "payload"
    .return ($P288)
.end


.namespace []
.sub "user_home_dir"  :subid("31_1261126406.73119") :outer("10_1261126406.73119")
.annotate "line", 470
    new $P291, 'ExceptionHandler'
    set_addr $P291, control_290
    $P291."handle_types"(58)
    push_eh $P291
.annotate "line", 471
    new $P292, "Hash"
    .lex "%env", $P292
    new $P293, "ResizablePMCArray"
    push $P293, "parrot"
    push $P293, "Env"
    root_new $P294, $P293
    store_lex "%env", $P294
.annotate "line", 472
    new $P295, "Exception"
    set $P295['type'], 58
    find_lex $P297, "%env"
    unless_null $P297, vivify_86
    new $P297, "Hash"
  vivify_86:
    set $P298, $P297["HOMEDRIVE"]
    unless_null $P298, vivify_87
    new $P298, "Undef"
  vivify_87:
    set $P296, $P298
    defined $I300, $P296
    if $I300, default_299
    new $P301, "String"
    assign $P301, ""
    set $P296, $P301
  default_299:
    find_lex $P302, "%env"
    unless_null $P302, vivify_88
    new $P302, "Hash"
  vivify_88:
    set $P303, $P302["HOME"]
    unless_null $P303, vivify_89
    new $P303, "Undef"
  vivify_89:
    concat $P304, $P296, $P303
    setattribute $P295, 'payload', $P304
    throw $P295
.annotate "line", 470
    .return ()
  control_290:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P305, exception, "payload"
    .return ($P305)
.end


.namespace []
.sub "path_exists"  :subid("32_1261126406.73119") :outer("10_1261126406.73119")
    .param pmc param_309
.annotate "line", 485
    .const 'Sub' $P323 = "33_1261126406.73119" 
    capture_lex $P323
    new $P308, 'ExceptionHandler'
    set_addr $P308, control_307
    $P308."handle_types"(58)
    push_eh $P308
    new $P319, 'ExceptionHandler'
    set_addr $P319, control_318
    $P319."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P319
    .lex "$path", param_309
.annotate "line", 486
    new $P310, "ResizablePMCArray"
    .lex "@stat", $P310
    new $P311, "ResizablePMCArray"
    push $P311, "parrot"
    push $P311, "OS"
    root_new $P312, $P311
    find_lex $P313, "$path"
    $P314 = $P312."stat"($P313)
    store_lex "@stat", $P314
.annotate "line", 487
    new $P315, "Exception"
    set $P315['type'], 58
    new $P316, "Integer"
    assign $P316, 1
    setattribute $P315, 'payload', $P316
    throw $P315
.annotate "line", 485
    pop_eh 
    goto skip_handler_317
  control_318:
.annotate "line", 489
    .local pmc exception 
    .get_results (exception) 
    .const 'Sub' $P323 = "33_1261126406.73119" 
    capture_lex $P323
    $P323(exception)
    new $P328, 'Integer'
    set $P328, 1
    set exception["handled"], $P328
    set $I329, exception["handled"]
    ne $I329, 1, nothandled_321
  handled_320:
    .return (exception)
  nothandled_321:
    rethrow exception
  skip_handler_317:
.annotate "line", 485
    .return ()
  control_307:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P330, exception, "payload"
    .return ($P330)
.end


.namespace []
.sub "_block322"  :anon :subid("33_1261126406.73119") :outer("32_1261126406.73119")
    .param pmc param_324
.annotate "line", 489
    .lex "$_", param_324
    find_lex $P325, "$_"
    .lex "$!", $P325
.annotate "line", 490
    new $P326, "Exception"
    set $P326['type'], 58
    new $P327, "Integer"
    assign $P327, 0
    setattribute $P326, 'payload', $P327
    throw $P326
.annotate "line", 489
    .return ()
.end


.namespace []
.sub "is_dir"  :subid("34_1261126406.73119") :outer("10_1261126406.73119")
    .param pmc param_334
.annotate "line", 504
    .const 'Sub' $P351 = "35_1261126406.73119" 
    capture_lex $P351
    new $P333, 'ExceptionHandler'
    set_addr $P333, control_332
    $P333."handle_types"(58)
    push_eh $P333
    new $P347, 'ExceptionHandler'
    set_addr $P347, control_346
    $P347."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P347
    .lex "$path", param_334
.annotate "line", 505
    new $P335, "ResizablePMCArray"
    .lex "@stat", $P335
    new $P336, "ResizablePMCArray"
    push $P336, "parrot"
    push $P336, "OS"
    root_new $P337, $P336
    find_lex $P338, "$path"
    $P339 = $P337."stat"($P338)
    store_lex "@stat", $P339
.annotate "line", 506
    new $P340, "Exception"
    set $P340['type'], 58
    find_lex $P341, "$path"
    set $S342, $P341
    stat $I343, $S342, 2
    new $P344, 'Integer'
    set $P344, $I343
    setattribute $P340, 'payload', $P344
    throw $P340
.annotate "line", 504
    pop_eh 
    goto skip_handler_345
  control_346:
.annotate "line", 508
    .local pmc exception 
    .get_results (exception) 
    .const 'Sub' $P351 = "35_1261126406.73119" 
    capture_lex $P351
    $P351(exception)
    new $P356, 'Integer'
    set $P356, 1
    set exception["handled"], $P356
    set $I357, exception["handled"]
    ne $I357, 1, nothandled_349
  handled_348:
    .return (exception)
  nothandled_349:
    rethrow exception
  skip_handler_345:
.annotate "line", 504
    .return ()
  control_332:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P358, exception, "payload"
    .return ($P358)
.end


.namespace []
.sub "_block350"  :anon :subid("35_1261126406.73119") :outer("34_1261126406.73119")
    .param pmc param_352
.annotate "line", 508
    .lex "$_", param_352
    find_lex $P353, "$_"
    .lex "$!", $P353
.annotate "line", 509
    new $P354, "Exception"
    set $P354['type'], 58
    new $P355, "Integer"
    assign $P355, 0
    setattribute $P354, 'payload', $P355
    throw $P354
.annotate "line", 508
    .return ()
.end


.namespace []
.sub "test_dir_writable"  :subid("36_1261126406.73119") :outer("10_1261126406.73119")
    .param pmc param_362
.annotate "line", 531
    .const 'Sub' $P375 = "37_1261126406.73119" 
    capture_lex $P375
    new $P361, 'ExceptionHandler'
    set_addr $P361, control_360
    $P361."handle_types"(58)
    push_eh $P361
    .lex "$dir", param_362
.annotate "line", 532
    new $P363, "Undef"
    .lex "$test_file", $P363
    find_lex $P364, "$dir"
    new $P365, "ResizablePMCArray"
    push $P365, $P364
    $P366 = "fscat"($P365, "WrItAbLe.UtL")
    store_lex "$test_file", $P366
.annotate "line", 535
    find_lex $P368, "$test_file"
    $P369 = "path_exists"($P368)
    unless $P369, if_367_end
.annotate "line", 534
    new $P370, 'String'
    set $P370, "Test file '"
    find_lex $P371, "$test_file"
    concat $P372, $P370, $P371
    concat $P373, $P372, "'\nthat should never exist already does."
    die $P373
  if_367_end:
.annotate "line", 537
    .const 'Sub' $P375 = "37_1261126406.73119" 
    capture_lex $P375
    $P375()
.annotate "line", 541
    find_lex $P387, "$test_file"
    $P388 = "path_exists"($P387)
    if $P388, if_386
.annotate "line", 546
    new $P394, "Exception"
    set $P394['type'], 58
    new $P395, "Integer"
    assign $P395, 0
    setattribute $P394, 'payload', $P395
    throw $P394
.annotate "line", 545
    goto if_386_end
  if_386:
.annotate "line", 542
    new $P389, "ResizablePMCArray"
    push $P389, "parrot"
    push $P389, "OS"
    root_new $P390, $P389
    find_lex $P391, "$test_file"
    $P390."rm"($P391)
.annotate "line", 543
    new $P392, "Exception"
    set $P392['type'], 58
    new $P393, "Integer"
    assign $P393, 1
    setattribute $P392, 'payload', $P393
    throw $P392
  if_386_end:
.annotate "line", 531
    .return ($P385)
  control_360:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P396, exception, "payload"
    .return ($P396)
.end


.namespace []
.sub "_block374"  :anon :subid("37_1261126406.73119") :outer("36_1261126406.73119")
.annotate "line", 537
    new $P380, 'ExceptionHandler'
    set_addr $P380, control_379
    $P380."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P380
.annotate "line", 538
    find_lex $P376, "$test_file"
    $P377 = "spew"($P376, "test_dir_writable() test file.\n")
.annotate "line", 537
    pop_eh 
    goto skip_handler_378
  control_379:
    .local pmc exception 
    .get_results (exception) 
    new $P383, 'Integer'
    set $P383, 1
    set exception["handled"], $P383
    set $I384, exception["handled"]
    ne $I384, 1, nothandled_382
  handled_381:
    .return (exception)
  nothandled_382:
    rethrow exception
  skip_handler_378:
    .return ($P377)
.end


.namespace []
.sub "find_program"  :subid("38_1261126406.73119") :outer("10_1261126406.73119")
    .param pmc param_400
.annotate "line", 570
    .const 'Sub' $P431 = "39_1261126406.73119" 
    capture_lex $P431
    new $P399, 'ExceptionHandler'
    set_addr $P399, control_398
    $P399."handle_types"(58)
    push_eh $P399
    .lex "$program", param_400
.annotate "line", 571
    new $P401, "Undef"
    .lex "$path_sep", $P401
.annotate "line", 572
    new $P402, "Hash"
    .lex "%env", $P402
.annotate "line", 573
    new $P403, "ResizablePMCArray"
    .lex "@paths", $P403
.annotate "line", 574
    new $P404, "ResizablePMCArray"
    .lex "@exts", $P404
.annotate "line", 571
    sysinfo $S407, 4
    iseq $I408, $S407, "MSWin32"
    if $I408, if_406
    new $P410, "String"
    assign $P410, ":"
    set $P405, $P410
    goto if_406_end
  if_406:
    new $P409, "String"
    assign $P409, ";"
    set $P405, $P409
  if_406_end:
    store_lex "$path_sep", $P405
.annotate "line", 572
    new $P411, "ResizablePMCArray"
    push $P411, "parrot"
    push $P411, "Env"
    root_new $P412, $P411
    store_lex "%env", $P412
.annotate "line", 573
    find_lex $P413, "$path_sep"
    set $S414, $P413
    find_lex $P415, "%env"
    unless_null $P415, vivify_90
    new $P415, "Hash"
  vivify_90:
    set $P416, $P415["PATH"]
    unless_null $P416, vivify_91
    new $P416, "Undef"
  vivify_91:
    set $S417, $P416
    split $P418, $S414, $S417
    store_lex "@paths", $P418
.annotate "line", 574
    find_lex $P419, "$path_sep"
    set $S420, $P419
    find_lex $P421, "%env"
    unless_null $P421, vivify_92
    new $P421, "Hash"
  vivify_92:
    set $P422, $P421["PATHEXT"]
    unless_null $P422, vivify_93
    new $P422, "Undef"
  vivify_93:
    set $S423, $P422
    split $P424, $S420, $S423
    store_lex "@exts", $P424
.annotate "line", 576
    find_lex $P425, "@exts"
    $P425."unshift"("")
.annotate "line", 578
    find_lex $P427, "@paths"
    defined $I428, $P427
    unless $I428, for_undef_94
    iter $P426, $P427
    new $P459, 'ExceptionHandler'
    set_addr $P459, loop458_handler
    $P459."handle_types"(65, 67, 66)
    push_eh $P459
  loop458_test:
    unless $P426, loop458_done
    shift $P429, $P426
  loop458_redo:
    .const 'Sub' $P431 = "39_1261126406.73119" 
    capture_lex $P431
    $P431($P429)
  loop458_next:
    goto loop458_test
  loop458_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P460, exception, 'type'
    eq $P460, 65, loop458_next
    eq $P460, 67, loop458_redo
  loop458_done:
    pop_eh 
  for_undef_94:
.annotate "line", 587
    new $P461, "Exception"
    set $P461['type'], 58
    new $P462, "String"
    assign $P462, ""
    setattribute $P461, 'payload', $P462
    throw $P461
.annotate "line", 570
    .return ()
  control_398:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P463, exception, "payload"
    .return ($P463)
.end


.namespace []
.sub "_block430"  :anon :subid("39_1261126406.73119") :outer("38_1261126406.73119")
    .param pmc param_432
.annotate "line", 578
    .const 'Sub' $P443 = "40_1261126406.73119" 
    capture_lex $P443
    .lex "$dir", param_432
.annotate "line", 579
    new $P433, "Undef"
    .lex "$path", $P433
    find_lex $P434, "$dir"
    new $P435, "ResizablePMCArray"
    push $P435, $P434
    find_lex $P436, "$program"
    $P437 = "fscat"($P435, $P436)
    store_lex "$path", $P437
.annotate "line", 581
    find_lex $P439, "@exts"
    defined $I440, $P439
    unless $I440, for_undef_95
    iter $P438, $P439
    new $P456, 'ExceptionHandler'
    set_addr $P456, loop455_handler
    $P456."handle_types"(65, 67, 66)
    push_eh $P456
  loop455_test:
    unless $P438, loop455_done
    shift $P441, $P438
  loop455_redo:
    .const 'Sub' $P443 = "40_1261126406.73119" 
    capture_lex $P443
    $P443($P441)
  loop455_next:
    goto loop455_test
  loop455_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P457, exception, 'type'
    eq $P457, 65, loop455_next
    eq $P457, 67, loop455_redo
  loop455_done:
    pop_eh 
  for_undef_95:
.annotate "line", 578
    .return ($P438)
.end


.namespace []
.sub "_block442"  :anon :subid("40_1261126406.73119") :outer("39_1261126406.73119")
    .param pmc param_444
.annotate "line", 581
    .lex "$ext", param_444
.annotate "line", 582
    new $P445, "Undef"
    .lex "$pathext", $P445
    find_lex $P446, "$path"
    find_lex $P447, "$ext"
    concat $P448, $P446, $P447
    store_lex "$pathext", $P448
.annotate "line", 583
    find_lex $P451, "$pathext"
    $P452 = "path_exists"($P451)
    if $P452, if_450
    set $P449, $P452
    goto if_450_end
  if_450:
    new $P453, "Exception"
    set $P453['type'], 58
    find_lex $P454, "$pathext"
    setattribute $P453, 'payload', $P454
    throw $P453
  if_450_end:
.annotate "line", 581
    .return ($P449)
.end


.namespace []
.sub "mkpath"  :subid("41_1261126406.73119") :outer("10_1261126406.73119")
    .param pmc param_467
.annotate "line", 600
    .const 'Sub' $P480 = "42_1261126406.73119" 
    capture_lex $P480
    new $P466, 'ExceptionHandler'
    set_addr $P466, control_465
    $P466."handle_types"(58)
    push_eh $P466
    .lex "$path", param_467
.annotate "line", 601
    new $P468, "ResizablePMCArray"
    .lex "@path", $P468
.annotate "line", 602
    new $P469, "Undef"
    .lex "$cur", $P469
.annotate "line", 601
    find_lex $P470, "$path"
    set $S471, $P470
    split $P472, "/", $S471
    store_lex "@path", $P472
.annotate "line", 602
    find_lex $P473, "@path"
    $P474 = $P473."shift"()
    store_lex "$cur", $P474
.annotate "line", 604
    find_lex $P476, "@path"
    defined $I477, $P476
    unless $I477, for_undef_96
    iter $P475, $P476
    new $P495, 'ExceptionHandler'
    set_addr $P495, loop494_handler
    $P495."handle_types"(65, 67, 66)
    push_eh $P495
  loop494_test:
    unless $P475, loop494_done
    shift $P478, $P475
  loop494_redo:
    .const 'Sub' $P480 = "42_1261126406.73119" 
    capture_lex $P480
    $P480($P478)
  loop494_next:
    goto loop494_test
  loop494_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P496, exception, 'type'
    eq $P496, 65, loop494_next
    eq $P496, 67, loop494_redo
  loop494_done:
    pop_eh 
  for_undef_96:
.annotate "line", 600
    .return ($P475)
  control_465:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P497, exception, "payload"
    .return ($P497)
.end


.namespace []
.sub "_block479"  :anon :subid("42_1261126406.73119") :outer("41_1261126406.73119")
    .param pmc param_481
.annotate "line", 604
    .lex "$dir", param_481
.annotate "line", 605
    find_lex $P482, "$cur"
    find_lex $P483, "$dir"
    new $P484, "ResizablePMCArray"
    push $P484, $P482
    push $P484, $P483
    $P485 = "fscat"($P484)
    store_lex "$cur", $P485
.annotate "line", 607
    find_lex $P488, "$cur"
    $P489 = "path_exists"($P488)
    unless $P489, unless_487
    set $P486, $P489
    goto unless_487_end
  unless_487:
.annotate "line", 608
    new $P490, "ResizablePMCArray"
    push $P490, "parrot"
    push $P490, "OS"
    root_new $P491, $P490
    find_lex $P492, "$cur"
    $P493 = $P491."mkdir"($P492, 511)
.annotate "line", 607
    set $P486, $P493
  unless_487_end:
.annotate "line", 604
    .return ($P486)
.end


.namespace []
.sub "run"  :subid("43_1261126406.73119") :outer("10_1261126406.73119")
    .param pmc param_501 :slurpy
.annotate "line", 635
    new $P500, 'ExceptionHandler'
    set_addr $P500, control_499
    $P500."handle_types"(58)
    push_eh $P500
    .lex "@command_and_args", param_501
.annotate "line", 636
    new $P502, "Exception"
    set $P502['type'], 58
    find_lex $P503, "@command_and_args"
    spawnw $I504, $P503
    new $P505, 'Integer'
    set $P505, $I504
    shr $P506, $P505, 8
    setattribute $P502, 'payload', $P506
    throw $P502
.annotate "line", 635
    .return ()
  control_499:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P507, exception, "payload"
    .return ($P507)
.end


.namespace []
.sub "do_run"  :subid("44_1261126406.73119") :outer("10_1261126406.73119")
    .param pmc param_511 :slurpy
.annotate "line", 653
    .const 'Sub' $P527 = "45_1261126406.73119" 
    capture_lex $P527
    new $P510, 'ExceptionHandler'
    set_addr $P510, control_509
    $P510."handle_types"(58)
    push_eh $P510
    new $P523, 'ExceptionHandler'
    set_addr $P523, control_522
    $P523."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P523
    .lex "@command_and_args", param_511
.annotate "line", 654
    find_lex $P512, "@command_and_args"
    join $S513, " ", $P512
    "say"($S513)
.annotate "line", 656
    new $P514, "Exception"
    set $P514['type'], 58
    find_lex $P517, "@command_and_args"
    spawnw $I518, $P517
    if $I518, if_516
    new $P520, "Integer"
    assign $P520, 1
    set $P515, $P520
    goto if_516_end
  if_516:
    new $P519, "Integer"
    assign $P519, 0
    set $P515, $P519
  if_516_end:
    setattribute $P514, 'payload', $P515
    throw $P514
.annotate "line", 653
    pop_eh 
    goto skip_handler_521
  control_522:
.annotate "line", 658
    .local pmc exception 
    .get_results (exception) 
    .const 'Sub' $P527 = "45_1261126406.73119" 
    capture_lex $P527
    $P527(exception)
    new $P532, 'Integer'
    set $P532, 1
    set exception["handled"], $P532
    set $I533, exception["handled"]
    ne $I533, 1, nothandled_525
  handled_524:
    .return (exception)
  nothandled_525:
    rethrow exception
  skip_handler_521:
.annotate "line", 653
    .return ()
  control_509:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P534, exception, "payload"
    .return ($P534)
.end


.namespace []
.sub "_block526"  :anon :subid("45_1261126406.73119") :outer("44_1261126406.73119")
    .param pmc param_528
.annotate "line", 658
    .lex "$_", param_528
    find_lex $P529, "$_"
    .lex "$!", $P529
.annotate "line", 659
    new $P530, "Exception"
    set $P530['type'], 58
    new $P531, "Integer"
    assign $P531, -1
    setattribute $P530, 'payload', $P531
    throw $P530
.annotate "line", 658
    .return ()
.end


.namespace []
.sub "qx"  :subid("46_1261126406.73119") :outer("10_1261126406.73119")
    .param pmc param_538 :slurpy
.annotate "line", 677
    new $P537, 'ExceptionHandler'
    set_addr $P537, control_536
    $P537."handle_types"(58)
    push_eh $P537
    .lex "@command_and_args", param_538
.annotate "line", 678
    new $P539, "Undef"
    .lex "$cmd", $P539
.annotate "line", 679
    new $P540, "Undef"
    .lex "$pipe", $P540
.annotate "line", 683
    new $P541, "Undef"
    .lex "$output", $P541
.annotate "line", 678
    find_lex $P542, "@command_and_args"
    join $S543, " ", $P542
    new $P544, 'String'
    set $P544, $S543
    store_lex "$cmd", $P544
.annotate "line", 679
    find_lex $P545, "$cmd"
    set $S546, $P545
    open $P547, $S546, "rp"
    store_lex "$pipe", $P547
.annotate "line", 680
    find_lex $P549, "$pipe"
    if $P549, unless_548_end
    new $P550, 'String'
    set $P550, "Unable to execute '"
    find_lex $P551, "$cmd"
    concat $P552, $P550, $P551
    concat $P553, $P552, "'"
    die $P553
  unless_548_end:
.annotate "line", 682
    find_lex $P554, "$pipe"
    $P554."encoding"("utf8")
.annotate "line", 683
    find_lex $P555, "$pipe"
    $P556 = $P555."readall"()
    store_lex "$output", $P556
.annotate "line", 684
    find_lex $P557, "$pipe"
    $P557."close"()
.annotate "line", 686
    find_lex $P558, "$pipe"
    $P559 = $P558."exit_status"()
    "store_dynlex_safely"("$!", $P559)
.annotate "line", 688
    new $P560, "Exception"
    set $P560['type'], 58
    find_lex $P561, "$output"
    setattribute $P560, 'payload', $P561
    throw $P560
.annotate "line", 677
    .return ()
  control_536:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P562, exception, "payload"
    .return ($P562)
.end


.namespace []
.sub "store_dynlex_safely"  :subid("47_1261126406.73119") :outer("10_1261126406.73119")
    .param pmc param_566
    .param pmc param_567
.annotate "line", 712
    new $P565, 'ExceptionHandler'
    set_addr $P565, control_564
    $P565."handle_types"(58)
    push_eh $P565
    .lex "$var_name", param_566
    .lex "$value", param_567
.annotate "line", 714
    find_lex $P570, "$var_name"
    set $S571, $P570
    find_dynamic_lex $P572, $S571
    isnull $I573, $P572
    unless $I573, unless_569
    new $P568, 'Integer'
    set $P568, $I573
    goto unless_569_end
  unless_569:
.annotate "line", 713
    find_lex $P574, "$var_name"
    set $S575, $P574
    find_lex $P576, "$value"
    store_dynamic_lex $S575, $P576
  unless_569_end:
.annotate "line", 712
    .return ($P568)
  control_564:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P577, exception, "payload"
    .return ($P577)
.end


.namespace []
.sub "replace_config_strings"  :subid("48_1261126406.73119") :outer("10_1261126406.73119")
    .param pmc param_581
.annotate "line", 832
    new $P580, 'ExceptionHandler'
    set_addr $P580, control_579
    $P580."handle_types"(58)
    push_eh $P580
    .lex "$original", param_581
.annotate "line", 833
    new $P582, "Undef"
    .lex "$new", $P582
    find_lex $P583, "$original"
    store_lex "$new", $P583
.annotate "line", 835
    new $P595, 'ExceptionHandler'
    set_addr $P595, loop594_handler
    $P595."handle_types"(65, 67, 66)
    push_eh $P595
    goto loop594_redo
  loop594_test:
.annotate "line", 839
    find_lex $P584, "$new"
    set $S585, $P584
    find_lex $P586, "$original"
    set $S587, $P586
    isne $I588, $S585, $S587
    unless $I588, loop594_done
  loop594_redo:
.annotate "line", 836
    find_lex $P589, "$new"
    store_lex "$original", $P589
.annotate "line", 837
    find_lex $P590, "$original"
    $P591 = "rx"("\\#<ident>\\#")
    get_hll_global $P592, "config_value"
    $P593 = "subst"($P590, $P591, $P592)
    store_lex "$new", $P593
  loop594_next:
.annotate "line", 835
    goto loop594_test
  loop594_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P596, exception, 'type'
    eq $P596, 65, loop594_next
    eq $P596, 67, loop594_redo
  loop594_done:
    pop_eh 
.annotate "line", 841
    new $P597, "Exception"
    set $P597['type'], 58
    find_lex $P598, "$new"
    setattribute $P597, 'payload', $P598
    throw $P597
.annotate "line", 832
    .return ()
  control_579:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P599, exception, "payload"
    .return ($P599)
.end


.namespace []
.sub "config_value"  :subid("49_1261126406.73119") :outer("10_1261126406.73119")
    .param pmc param_603
.annotate "line", 844
    new $P602, 'ExceptionHandler'
    set_addr $P602, control_601
    $P602."handle_types"(58)
    push_eh $P602
    .lex "$match", param_603
.annotate "line", 845
    new $P604, "Undef"
    .lex "$key", $P604
.annotate "line", 846
    new $P605, "Undef"
    .lex "$config", $P605
.annotate "line", 845
    find_lex $P606, "$match"
    unless_null $P606, vivify_97
    new $P606, "Hash"
  vivify_97:
    set $P607, $P606["ident"]
    unless_null $P607, vivify_98
    new $P607, "Undef"
  vivify_98:
    store_lex "$key", $P607
.annotate "line", 847
    find_lex $P616, "$key"
    find_dynamic_lex $P617, "%*CONF"
    unless_null $P617, vivify_99
    get_hll_global $P617, "%CONF"
    unless_null $P617, vivify_100
    die "Contextual %*CONF not found"
  vivify_100:
  vivify_99:
    set $P618, $P617[$P616]
    unless_null $P618, vivify_101
    new $P618, "Undef"
  vivify_101:
    unless $P618, unless_615
    set $P614, $P618
    goto unless_615_end
  unless_615:
    find_lex $P619, "$key"
    find_dynamic_lex $P620, "%*VM"
    unless_null $P620, vivify_102
    get_hll_global $P620, "%VM"
    unless_null $P620, vivify_103
    die "Contextual %*VM not found"
  vivify_103:
  vivify_102:
    set $P621, $P620["config"]
    unless_null $P621, vivify_104
    new $P621, "Hash"
  vivify_104:
    set $P622, $P621[$P619]
    unless_null $P622, vivify_105
    new $P622, "Undef"
  vivify_105:
    set $P614, $P622
  unless_615_end:
    unless $P614, unless_613
    set $P612, $P614
    goto unless_613_end
  unless_613:
    find_lex $P623, "$key"
    find_dynamic_lex $P624, "%*BIN"
    unless_null $P624, vivify_106
    get_hll_global $P624, "%BIN"
    unless_null $P624, vivify_107
    die "Contextual %*BIN not found"
  vivify_107:
  vivify_106:
    set $P625, $P624[$P623]
    unless_null $P625, vivify_108
    new $P625, "Undef"
  vivify_108:
    set $P612, $P625
  unless_613_end:
.annotate "line", 848
    unless $P612, unless_611
    set $P610, $P612
    goto unless_611_end
  unless_611:
    find_lex $P626, "$key"
    find_dynamic_lex $P627, "%*ENV"
    unless_null $P627, vivify_109
    get_hll_global $P627, "%ENV"
    unless_null $P627, vivify_110
    die "Contextual %*ENV not found"
  vivify_110:
  vivify_109:
    set $P628, $P627[$P626]
    unless_null $P628, vivify_111
    new $P628, "Undef"
  vivify_111:
    set $P610, $P628
  unless_611_end:
.annotate "line", 849
    unless $P610, unless_609
    set $P608, $P610
    goto unless_609_end
  unless_609:
    new $P629, "String"
    assign $P629, ""
    set $P608, $P629
  unless_609_end:
.annotate "line", 850
    store_lex "$config", $P608
.annotate "line", 852
    new $P630, "Exception"
    set $P630['type'], 58
    find_lex $P631, "$config"
    setattribute $P630, 'payload', $P631
    throw $P630
.annotate "line", 844
    .return ()
  control_601:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P632, exception, "payload"
    .return ($P632)
.end


.namespace ["Hash"]
.sub "_block633"  :subid("50_1261126406.73119") :outer("10_1261126406.73119")
.annotate "line", 77
    .const 'Sub' $P684 = "56_1261126406.73119" 
    capture_lex $P684
    .const 'Sub' $P663 = "54_1261126406.73119" 
    capture_lex $P663
    .const 'Sub' $P642 = "52_1261126406.73119" 
    capture_lex $P642
    .const 'Sub' $P635 = "51_1261126406.73119" 
    capture_lex $P635
.annotate "line", 140
    .const 'Sub' $P684 = "56_1261126406.73119" 
    capture_lex $P684
.annotate "line", 77
    .return ($P684)
.end


.namespace ["Hash"]
.sub "exists"  :subid("51_1261126406.73119") :method :outer("50_1261126406.73119")
    .param pmc param_638
.annotate "line", 90
    new $P637, 'ExceptionHandler'
    set_addr $P637, control_636
    $P637."handle_types"(58)
    push_eh $P637
    .lex "self", self
    .lex "$key", param_638
.annotate "line", 91
    new $P639, "Exception"
    set $P639['type'], 58

            $P1 = find_lex '$key'
            $I0 = exists self[$P1]
            $P640  = box $I0
        
    setattribute $P639, 'payload', $P640
    throw $P639
.annotate "line", 90
    .return ()
  control_636:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P641, exception, "payload"
    .return ($P641)
.end


.namespace ["Hash"]
.sub "keys"  :subid("52_1261126406.73119") :method :outer("50_1261126406.73119")
.annotate "line", 107
    .const 'Sub' $P652 = "53_1261126406.73119" 
    capture_lex $P652
    new $P644, 'ExceptionHandler'
    set_addr $P644, control_643
    $P644."handle_types"(58)
    push_eh $P644
    .lex "self", self
.annotate "line", 108
    new $P645, "ResizablePMCArray"
    .lex "@keys", $P645
.annotate "line", 107
    find_lex $P646, "@keys"
.annotate "line", 109
    find_lex $P648, "self"
    defined $I649, $P648
    unless $I649, for_undef_112
    iter $P647, $P648
    new $P659, 'ExceptionHandler'
    set_addr $P659, loop658_handler
    $P659."handle_types"(65, 67, 66)
    push_eh $P659
  loop658_test:
    unless $P647, loop658_done
    shift $P650, $P647
  loop658_redo:
    .const 'Sub' $P652 = "53_1261126406.73119" 
    capture_lex $P652
    $P652($P650)
  loop658_next:
    goto loop658_test
  loop658_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P660, exception, 'type'
    eq $P660, 65, loop658_next
    eq $P660, 67, loop658_redo
  loop658_done:
    pop_eh 
  for_undef_112:
    find_lex $P661, "@keys"
.annotate "line", 107
    .return ($P661)
  control_643:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P662, exception, "payload"
    .return ($P662)
.end


.namespace ["Hash"]
.sub "_block651"  :anon :subid("53_1261126406.73119") :outer("52_1261126406.73119")
    .param pmc param_653
.annotate "line", 109
    .lex "$_", param_653
    find_lex $P654, "@keys"
    find_lex $P655, "$_"
    $P656 = $P655."key"()
    $P657 = $P654."push"($P656)
    .return ($P657)
.end


.namespace ["Hash"]
.sub "values"  :subid("54_1261126406.73119") :method :outer("50_1261126406.73119")
.annotate "line", 122
    .const 'Sub' $P673 = "55_1261126406.73119" 
    capture_lex $P673
    new $P665, 'ExceptionHandler'
    set_addr $P665, control_664
    $P665."handle_types"(58)
    push_eh $P665
    .lex "self", self
.annotate "line", 123
    new $P666, "ResizablePMCArray"
    .lex "@values", $P666
.annotate "line", 122
    find_lex $P667, "@values"
.annotate "line", 124
    find_lex $P669, "self"
    defined $I670, $P669
    unless $I670, for_undef_113
    iter $P668, $P669
    new $P680, 'ExceptionHandler'
    set_addr $P680, loop679_handler
    $P680."handle_types"(65, 67, 66)
    push_eh $P680
  loop679_test:
    unless $P668, loop679_done
    shift $P671, $P668
  loop679_redo:
    .const 'Sub' $P673 = "55_1261126406.73119" 
    capture_lex $P673
    $P673($P671)
  loop679_next:
    goto loop679_test
  loop679_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P681, exception, 'type'
    eq $P681, 65, loop679_next
    eq $P681, 67, loop679_redo
  loop679_done:
    pop_eh 
  for_undef_113:
    find_lex $P682, "@values"
.annotate "line", 122
    .return ($P682)
  control_664:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P683, exception, "payload"
    .return ($P683)
.end


.namespace ["Hash"]
.sub "_block672"  :anon :subid("55_1261126406.73119") :outer("54_1261126406.73119")
    .param pmc param_674
.annotate "line", 124
    .lex "$_", param_674
    find_lex $P675, "@values"
    find_lex $P676, "$_"
    $P677 = $P676."value"()
    $P678 = $P675."push"($P677)
    .return ($P678)
.end


.namespace ["Hash"]
.sub "kv"  :subid("56_1261126406.73119") :method :outer("50_1261126406.73119")
.annotate "line", 140
    .const 'Sub' $P694 = "57_1261126406.73119" 
    capture_lex $P694
    new $P686, 'ExceptionHandler'
    set_addr $P686, control_685
    $P686."handle_types"(58)
    push_eh $P686
    .lex "self", self
.annotate "line", 141
    new $P687, "ResizablePMCArray"
    .lex "@kv", $P687
.annotate "line", 140
    find_lex $P688, "@kv"
.annotate "line", 142
    find_lex $P690, "self"
    defined $I691, $P690
    unless $I691, for_undef_114
    iter $P689, $P690
    new $P704, 'ExceptionHandler'
    set_addr $P704, loop703_handler
    $P704."handle_types"(65, 67, 66)
    push_eh $P704
  loop703_test:
    unless $P689, loop703_done
    shift $P692, $P689
  loop703_redo:
    .const 'Sub' $P694 = "57_1261126406.73119" 
    capture_lex $P694
    $P694($P692)
  loop703_next:
    goto loop703_test
  loop703_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P705, exception, 'type'
    eq $P705, 65, loop703_next
    eq $P705, 67, loop703_redo
  loop703_done:
    pop_eh 
  for_undef_114:
    find_lex $P706, "@kv"
.annotate "line", 140
    .return ($P706)
  control_685:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P707, exception, "payload"
    .return ($P707)
.end


.namespace ["Hash"]
.sub "_block693"  :anon :subid("57_1261126406.73119") :outer("56_1261126406.73119")
    .param pmc param_695
.annotate "line", 142
    .lex "$_", param_695
    find_lex $P696, "@kv"
    find_lex $P697, "$_"
    $P698 = $P697."key"()
    $P696."push"($P698)
    find_lex $P699, "@kv"
    find_lex $P700, "$_"
    $P701 = $P700."value"()
    $P702 = $P699."push"($P701)
    .return ($P702)
.end


.namespace ["Array"]
.sub "_block708"  :subid("58_1261126406.73119") :outer("10_1261126406.73119")
.annotate "line", 165
    .const 'Sub' $P710 = "59_1261126406.73119" 
    capture_lex $P710
.annotate "line", 178
    .const 'Sub' $P710 = "59_1261126406.73119" 
    capture_lex $P710
.annotate "line", 165
    .return ($P710)
.end


.namespace ["Array"]
.sub "reverse"  :subid("59_1261126406.73119") :method :outer("58_1261126406.73119")
.annotate "line", 178
    .const 'Sub' $P720 = "60_1261126406.73119" 
    capture_lex $P720
    new $P712, 'ExceptionHandler'
    set_addr $P712, control_711
    $P712."handle_types"(58)
    push_eh $P712
    .lex "self", self
.annotate "line", 179
    new $P713, "ResizablePMCArray"
    .lex "@reversed", $P713
.annotate "line", 178
    find_lex $P714, "@reversed"
.annotate "line", 180
    find_lex $P716, "self"
    defined $I717, $P716
    unless $I717, for_undef_115
    iter $P715, $P716
    new $P726, 'ExceptionHandler'
    set_addr $P726, loop725_handler
    $P726."handle_types"(65, 67, 66)
    push_eh $P726
  loop725_test:
    unless $P715, loop725_done
    shift $P718, $P715
  loop725_redo:
    .const 'Sub' $P720 = "60_1261126406.73119" 
    capture_lex $P720
    $P720($P718)
  loop725_next:
    goto loop725_test
  loop725_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P727, exception, 'type'
    eq $P727, 65, loop725_next
    eq $P727, 67, loop725_redo
  loop725_done:
    pop_eh 
  for_undef_115:
    find_lex $P728, "@reversed"
.annotate "line", 178
    .return ($P728)
  control_711:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P729, exception, "payload"
    .return ($P729)
.end


.namespace ["Array"]
.sub "_block719"  :anon :subid("60_1261126406.73119") :outer("59_1261126406.73119")
    .param pmc param_721
.annotate "line", 180
    .lex "$_", param_721
    find_lex $P722, "@reversed"
    find_lex $P723, "$_"
    $P724 = $P722."unshift"($P723)
    .return ($P724)
.end

