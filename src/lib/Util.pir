
.namespace []
.sub "_block11"  :anon :subid("10_1261116270.65639")
.annotate "line", 0
    .const 'Sub' $P686 = "55_1261116270.65639" 
    capture_lex $P686
    get_hll_global $P645, ["Array"], "_block644" 
    capture_lex $P645
    get_hll_global $P570, ["Hash"], "_block569" 
    capture_lex $P570
    .const 'Sub' $P536 = "43_1261116270.65639" 
    capture_lex $P536
    .const 'Sub' $P514 = "42_1261116270.65639" 
    capture_lex $P514
    .const 'Sub' $P499 = "41_1261116270.65639" 
    capture_lex $P499
    .const 'Sub' $P471 = "40_1261116270.65639" 
    capture_lex $P471
    .const 'Sub' $P444 = "38_1261116270.65639" 
    capture_lex $P444
    .const 'Sub' $P434 = "37_1261116270.65639" 
    capture_lex $P434
    .const 'Sub' $P400 = "35_1261116270.65639" 
    capture_lex $P400
    .const 'Sub' $P333 = "32_1261116270.65639" 
    capture_lex $P333
    .const 'Sub' $P295 = "30_1261116270.65639" 
    capture_lex $P295
    .const 'Sub' $P267 = "28_1261116270.65639" 
    capture_lex $P267
    .const 'Sub' $P242 = "26_1261116270.65639" 
    capture_lex $P242
    .const 'Sub' $P225 = "25_1261116270.65639" 
    capture_lex $P225
    .const 'Sub' $P195 = "24_1261116270.65639" 
    capture_lex $P195
    .const 'Sub' $P173 = "22_1261116270.65639" 
    capture_lex $P173
    .const 'Sub' $P166 = "21_1261116270.65639" 
    capture_lex $P166
    .const 'Sub' $P141 = "19_1261116270.65639" 
    capture_lex $P141
    .const 'Sub' $P66 = "15_1261116270.65639" 
    capture_lex $P66
    .const 'Sub' $P38 = "13_1261116270.65639" 
    capture_lex $P38
    .const 'Sub' $P13 = "11_1261116270.65639" 
    capture_lex $P13
.annotate "line", 206
    .const 'Sub' $P13 = "11_1261116270.65639" 
    capture_lex $P13
    .lex "map", $P13
.annotate "line", 226
    .const 'Sub' $P38 = "13_1261116270.65639" 
    capture_lex $P38
    .lex "grep", $P38
.annotate "line", 258
    .const 'Sub' $P66 = "15_1261116270.65639" 
    capture_lex $P66
    .lex "reduce", $P66
.annotate "line", 286
    .const 'Sub' $P141 = "19_1261116270.65639" 
    capture_lex $P141
    .lex "_reduce", $P141
.annotate "line", 314
    .const 'Sub' $P166 = "21_1261116270.65639" 
    capture_lex $P166
    .lex "hash", $P166
.annotate "line", 327
    .const 'Sub' $P173 = "22_1261116270.65639" 
    capture_lex $P173
    .lex "set_from_array", $P173
.annotate "line", 359
    .const 'Sub' $P195 = "24_1261116270.65639" 
    capture_lex $P195
    .lex "fscat", $P195
.annotate "line", 379
    .const 'Sub' $P225 = "25_1261116270.65639" 
    capture_lex $P225
    .lex "user_home_dir", $P225
.annotate "line", 394
    .const 'Sub' $P242 = "26_1261116270.65639" 
    capture_lex $P242
    .lex "path_exists", $P242
.annotate "line", 413
    .const 'Sub' $P267 = "28_1261116270.65639" 
    capture_lex $P267
    .lex "is_dir", $P267
.annotate "line", 440
    .const 'Sub' $P295 = "30_1261116270.65639" 
    capture_lex $P295
    .lex "test_dir_writable", $P295
.annotate "line", 479
    .const 'Sub' $P333 = "32_1261116270.65639" 
    capture_lex $P333
    .lex "find_program", $P333
.annotate "line", 509
    .const 'Sub' $P400 = "35_1261116270.65639" 
    capture_lex $P400
    .lex "mkpath", $P400
.annotate "line", 544
    .const 'Sub' $P434 = "37_1261116270.65639" 
    capture_lex $P434
    .lex "run", $P434
.annotate "line", 562
    .const 'Sub' $P444 = "38_1261116270.65639" 
    capture_lex $P444
    .lex "do_run", $P444
.annotate "line", 586
    .const 'Sub' $P471 = "40_1261116270.65639" 
    capture_lex $P471
    .lex "qx", $P471
.annotate "line", 621
    .const 'Sub' $P499 = "41_1261116270.65639" 
    capture_lex $P499
    .lex "store_dynlex_safely", $P499
.annotate "line", 741
    .const 'Sub' $P514 = "42_1261116270.65639" 
    capture_lex $P514
    .lex "replace_config_strings", $P514
.annotate "line", 753
    .const 'Sub' $P536 = "43_1261116270.65639" 
    capture_lex $P536
    .lex "config_value", $P536
.annotate "line", 70
    get_hll_global $P570, ["Hash"], "_block569" 
    capture_lex $P570
    $P570()
.annotate "line", 158
    get_hll_global $P645, ["Array"], "_block644" 
    capture_lex $P645
    $P645()
    find_lex $P666, "map"
    find_lex $P667, "grep"
    find_lex $P668, "reduce"
    find_lex $P669, "_reduce"
    find_lex $P670, "hash"
    find_lex $P671, "set_from_array"
    find_lex $P672, "fscat"
    find_lex $P673, "user_home_dir"
    find_lex $P674, "path_exists"
    find_lex $P675, "is_dir"
    find_lex $P676, "test_dir_writable"
    find_lex $P677, "find_program"
    find_lex $P678, "mkpath"
    find_lex $P679, "run"
    find_lex $P680, "do_run"
    find_lex $P681, "qx"
    find_lex $P682, "store_dynlex_safely"
.annotate "line", 675
    find_lex $P683, "replace_config_strings"
    find_lex $P684, "config_value"
.annotate "line", 1
    .return ($P684)
.end


.namespace []
.sub "" :load :init :subid("post56") :outer("10_1261116270.65639")
.annotate "line", 0
    .const 'Sub' $P12 = "10_1261116270.65639" 
    .local pmc block
    set block, $P12
.annotate "line", 675
    .const 'Sub' $P686 = "55_1261116270.65639" 
    capture_lex $P686
    $P686()
.end


.namespace []
.sub "_block685"  :anon :subid("55_1261116270.65639") :outer("10_1261116270.65639")
.annotate "line", 678
    new $P687, "Undef"
    .lex "$interp", $P687
.annotate "line", 679
    new $P688, "ResizablePMCArray"
    .lex "@argv", $P688
.annotate "line", 680
    new $P689, "Undef"
    .lex "$config", $P689
.annotate "line", 683
    new $P690, "Hash"
    .lex "%vm", $P690
.annotate "line", 676
    load_bytecode "config.pbc"
.annotate "line", 678
    getinterp $P691
    store_lex "$interp", $P691
.annotate "line", 679
    find_lex $P692, "$interp"
    unless_null $P692, vivify_57
    new $P692, "ResizablePMCArray"
  vivify_57:
    set $P693, $P692[2]
    unless_null $P693, vivify_58
    new $P693, "Undef"
  vivify_58:
    store_lex "@argv", $P693
.annotate "line", 680
    find_lex $P694, "$interp"
    unless_null $P694, vivify_59
    new $P694, "ResizablePMCArray"
  vivify_59:
    set $P695, $P694[6]
    unless_null $P695, vivify_60
    new $P695, "Undef"
  vivify_60:
    store_lex "$config", $P695
    find_lex $P696, "%vm"
.annotate "line", 684
    find_lex $P697, "$config"
    find_lex $P698, "%vm"
    unless_null $P698, vivify_61
    new $P698, "Hash"
    store_lex "%vm", $P698
  vivify_61:
    set $P698["config"], $P697
.annotate "line", 685
    find_lex $P699, "%vm"
    "store_dynlex_safely"("%*VM", $P699)
.annotate "line", 688
    find_lex $P701, "@argv"
    if $P701, unless_700_end
    find_lex $P702, "@argv"
    $P702."unshift"("<anonymous>")
  unless_700_end:
.annotate "line", 689
    find_lex $P703, "@argv"
    $P704 = $P703."shift"()
    "store_dynlex_safely"("$*PROGRAM_NAME", $P704)
.annotate "line", 690
    find_lex $P705, "@argv"
    "store_dynlex_safely"("@*ARGS", $P705)
.annotate "line", 693
    interpinfo $S706, 19
    "store_dynlex_safely"("$*EXECUTABLE_NAME", $S706)
.annotate "line", 696
    sysinfo $S707, 4
    "store_dynlex_safely"("$*OSNAME", $S707)
.annotate "line", 697
    sysinfo $S708, 5
    "store_dynlex_safely"("%*OSVER", $S708)
.annotate "line", 700
    new $P709, "ResizablePMCArray"
    push $P709, "parrot"
    push $P709, "Env"
    root_new $P710, $P709
    "store_dynlex_safely"("%*ENV", $P710)
.annotate "line", 701
    new $P711, "ResizablePMCArray"
    push $P711, "parrot"
    push $P711, "OS"
    root_new $P712, $P711
    $P713 = "store_dynlex_safely"("$*OS", $P712)
.annotate "line", 675
    .return ($P713)
.end


.namespace []
.sub "map"  :subid("11_1261116270.65639") :outer("10_1261116270.65639")
    .param pmc param_16
    .param pmc param_17
.annotate "line", 206
    .const 'Sub' $P25 = "12_1261116270.65639" 
    capture_lex $P25
    new $P15, 'ExceptionHandler'
    set_addr $P15, control_14
    $P15."handle_types"(58)
    push_eh $P15
    .lex "&code", param_16
    .lex "@originals", param_17
.annotate "line", 207
    new $P18, "ResizablePMCArray"
    .lex "@mapped", $P18
.annotate "line", 206
    find_lex $P19, "@mapped"
.annotate "line", 209
    find_lex $P21, "@originals"
    defined $I22, $P21
    unless $I22, for_undef_62
    iter $P20, $P21
    new $P33, 'ExceptionHandler'
    set_addr $P33, loop32_handler
    $P33."handle_types"(65, 67, 66)
    push_eh $P33
  loop32_test:
    unless $P20, loop32_done
    shift $P23, $P20
  loop32_redo:
    .const 'Sub' $P25 = "12_1261116270.65639" 
    capture_lex $P25
    $P25($P23)
  loop32_next:
    goto loop32_test
  loop32_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P34, exception, 'type'
    eq $P34, 65, loop32_next
    eq $P34, 67, loop32_redo
  loop32_done:
    pop_eh 
  for_undef_62:
.annotate "line", 213
    new $P35, "Exception"
    set $P35['type'], 58
    find_lex $P36, "@mapped"
    setattribute $P35, 'payload', $P36
    throw $P35
.annotate "line", 206
    .return ()
  control_14:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P37, exception, "payload"
    .return ($P37)
.end


.namespace []
.sub "_block24"  :anon :subid("12_1261116270.65639") :outer("11_1261116270.65639")
    .param pmc param_26
.annotate "line", 209
    .lex "$_", param_26
.annotate "line", 210
    find_lex $P27, "@mapped"
    find_lex $P28, "&code"
    find_lex $P29, "$_"
    $P30 = $P28($P29)
    $P31 = $P27."push"($P30)
.annotate "line", 209
    .return ($P31)
.end


.namespace []
.sub "grep"  :subid("13_1261116270.65639") :outer("10_1261116270.65639")
    .param pmc param_41
    .param pmc param_42
.annotate "line", 226
    .const 'Sub' $P50 = "14_1261116270.65639" 
    capture_lex $P50
    new $P40, 'ExceptionHandler'
    set_addr $P40, control_39
    $P40."handle_types"(58)
    push_eh $P40
    .lex "&code", param_41
    .lex "@all", param_42
.annotate "line", 227
    new $P43, "ResizablePMCArray"
    .lex "@matches", $P43
.annotate "line", 226
    find_lex $P44, "@matches"
.annotate "line", 229
    find_lex $P46, "@all"
    defined $I47, $P46
    unless $I47, for_undef_63
    iter $P45, $P46
    new $P61, 'ExceptionHandler'
    set_addr $P61, loop60_handler
    $P61."handle_types"(65, 67, 66)
    push_eh $P61
  loop60_test:
    unless $P45, loop60_done
    shift $P48, $P45
  loop60_redo:
    .const 'Sub' $P50 = "14_1261116270.65639" 
    capture_lex $P50
    $P50($P48)
  loop60_next:
    goto loop60_test
  loop60_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P62, exception, 'type'
    eq $P62, 65, loop60_next
    eq $P62, 67, loop60_redo
  loop60_done:
    pop_eh 
  for_undef_63:
.annotate "line", 233
    new $P63, "Exception"
    set $P63['type'], 58
    find_lex $P64, "@matches"
    setattribute $P63, 'payload', $P64
    throw $P63
.annotate "line", 226
    .return ()
  control_39:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P65, exception, "payload"
    .return ($P65)
.end


.namespace []
.sub "_block49"  :anon :subid("14_1261116270.65639") :outer("13_1261116270.65639")
    .param pmc param_51
.annotate "line", 229
    .lex "$_", param_51
.annotate "line", 230
    find_lex $P54, "&code"
    find_lex $P55, "$_"
    $P56 = $P54($P55)
    if $P56, if_53
    set $P52, $P56
    goto if_53_end
  if_53:
    find_lex $P57, "@matches"
    find_lex $P58, "$_"
    $P59 = $P57."push"($P58)
    set $P52, $P59
  if_53_end:
.annotate "line", 229
    .return ($P52)
.end


.namespace []
.sub "reduce"  :subid("15_1261116270.65639") :outer("10_1261116270.65639")
    .param pmc param_69
    .param pmc param_70
    .param pmc param_71 :slurpy
.annotate "line", 258
    .const 'Sub' $P93 = "16_1261116270.65639" 
    capture_lex $P93
    new $P68, 'ExceptionHandler'
    set_addr $P68, control_67
    $P68."handle_types"(58)
    push_eh $P68
    .lex "&code", param_69
    .lex "@array", param_70
    .lex "@initial", param_71
.annotate "line", 259
    new $P72, "Undef"
    .lex "$init_elems", $P72
    find_lex $P73, "@initial"
    elements $I74, $P73
    new $P75, 'Integer'
    set $P75, $I74
    store_lex "$init_elems", $P75
.annotate "line", 260
    find_lex $P78, "$init_elems"
    set $N79, $P78
    isgt $I80, $N79, 1.0
    if $I80, if_77
.annotate "line", 263
    find_lex $P83, "$init_elems"
    set $N84, $P83
    iseq $I85, $N84, 1.0
    if $I85, if_82
.annotate "line", 266
    .const 'Sub' $P93 = "16_1261116270.65639" 
    capture_lex $P93
    $P139 = $P93()
    set $P81, $P139
.annotate "line", 263
    goto if_82_end
  if_82:
.annotate "line", 264
    new $P86, "Exception"
    set $P86['type'], 58
    find_lex $P87, "&code"
    find_lex $P88, "@array"
    find_lex $P89, "@initial"
    unless_null $P89, vivify_70
    new $P89, "ResizablePMCArray"
  vivify_70:
    set $P90, $P89[0]
    unless_null $P90, vivify_71
    new $P90, "Undef"
  vivify_71:
    $P91 = "_reduce"($P87, $P88, $P90)
    setattribute $P86, 'payload', $P91
    throw $P86
  if_82_end:
.annotate "line", 263
    set $P76, $P81
.annotate "line", 260
    goto if_77_end
  if_77:
.annotate "line", 261
    die "Only one initial value allowed in reduce()"
  if_77_end:
.annotate "line", 258
    .return ($P76)
  control_67:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P140, exception, "payload"
    .return ($P140)
.end


.namespace []
.sub "_block92"  :anon :subid("16_1261116270.65639") :outer("15_1261116270.65639")
.annotate "line", 266
    .const 'Sub' $P118 = "18_1261116270.65639" 
    capture_lex $P118
    .const 'Sub' $P104 = "17_1261116270.65639" 
    capture_lex $P104
.annotate "line", 267
    new $P94, "Undef"
    .lex "$array_elems", $P94
    find_lex $P95, "@array"
    elements $I96, $P95
    new $P97, 'Integer'
    set $P97, $I96
    store_lex "$array_elems", $P97
.annotate "line", 268
    find_lex $P100, "$array_elems"
    set $N101, $P100
    iseq $I102, $N101, 0.0
    if $I102, if_99
.annotate "line", 271
    find_lex $P111, "$array_elems"
    set $N112, $P111
    iseq $I113, $N112, 1.0
    if $I113, if_110
.annotate "line", 274
    .const 'Sub' $P118 = "18_1261116270.65639" 
    capture_lex $P118
    $P138 = $P118()
    set $P109, $P138
.annotate "line", 271
    goto if_110_end
  if_110:
.annotate "line", 272
    new $P114, "Exception"
    set $P114['type'], 58
    find_lex $P115, "@array"
    unless_null $P115, vivify_68
    new $P115, "ResizablePMCArray"
  vivify_68:
    set $P116, $P115[0]
    unless_null $P116, vivify_69
    new $P116, "Undef"
  vivify_69:
    setattribute $P114, 'payload', $P116
    throw $P114
  if_110_end:
.annotate "line", 271
    set $P98, $P109
.annotate "line", 268
    goto if_99_end
  if_99:
    .const 'Sub' $P104 = "17_1261116270.65639" 
    capture_lex $P104
    $P108 = $P104()
    set $P98, $P108
  if_99_end:
.annotate "line", 266
    .return ($P98)
.end


.namespace []
.sub "_block117"  :anon :subid("18_1261116270.65639") :outer("16_1261116270.65639")
.annotate "line", 275
    new $P119, "Undef"
    .lex "$initial", $P119
.annotate "line", 276
    new $P120, "Undef"
    .lex "$iter", $P120
.annotate "line", 275
    find_lex $P121, "&code"
    find_lex $P122, "@array"
    unless_null $P122, vivify_64
    new $P122, "ResizablePMCArray"
  vivify_64:
    set $P123, $P122[0]
    unless_null $P123, vivify_65
    new $P123, "Undef"
  vivify_65:
    find_lex $P124, "@array"
    unless_null $P124, vivify_66
    new $P124, "ResizablePMCArray"
  vivify_66:
    set $P125, $P124[1]
    unless_null $P125, vivify_67
    new $P125, "Undef"
  vivify_67:
    $P126 = $P121($P123, $P125)
    store_lex "$initial", $P126
.annotate "line", 276
    find_lex $P127, "@array"
    iter $P128, $P127
    store_lex "$iter", $P128
.annotate "line", 278
    find_lex $P129, "$iter"
    shift $P130, $P129
.annotate "line", 279
    find_lex $P131, "$iter"
    shift $P132, $P131
.annotate "line", 281
    new $P133, "Exception"
    set $P133['type'], 58
    find_lex $P134, "&code"
    find_lex $P135, "$iter"
    find_lex $P136, "$initial"
    $P137 = "_reduce"($P134, $P135, $P136)
    setattribute $P133, 'payload', $P137
    throw $P133
.annotate "line", 274
    .return ()
.end


.namespace []
.sub "_block103"  :anon :subid("17_1261116270.65639") :outer("16_1261116270.65639")
.annotate "line", 269
    new $P105, "Undef"
    .lex "$undef", $P105
    new $P106, "Exception"
    set $P106['type'], 58
    find_lex $P107, "$undef"
    setattribute $P106, 'payload', $P107
    throw $P106
.annotate "line", 268
    .return ()
.end


.namespace []
.sub "_reduce"  :subid("19_1261116270.65639") :outer("10_1261116270.65639")
    .param pmc param_144
    .param pmc param_145
    .param pmc param_146
.annotate "line", 286
    .const 'Sub' $P154 = "20_1261116270.65639" 
    capture_lex $P154
    new $P143, 'ExceptionHandler'
    set_addr $P143, control_142
    $P143."handle_types"(58)
    push_eh $P143
    .lex "&code", param_144
    .lex "$iter", param_145
    .lex "$initial", param_146
.annotate "line", 287
    new $P147, "Undef"
    .lex "$result", $P147
    find_lex $P148, "$initial"
    store_lex "$result", $P148
.annotate "line", 289
    find_lex $P150, "$iter"
    defined $I151, $P150
    unless $I151, for_undef_72
    iter $P149, $P150
    new $P161, 'ExceptionHandler'
    set_addr $P161, loop160_handler
    $P161."handle_types"(65, 67, 66)
    push_eh $P161
  loop160_test:
    unless $P149, loop160_done
    shift $P152, $P149
  loop160_redo:
    .const 'Sub' $P154 = "20_1261116270.65639" 
    capture_lex $P154
    $P154($P152)
  loop160_next:
    goto loop160_test
  loop160_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P162, exception, 'type'
    eq $P162, 65, loop160_next
    eq $P162, 67, loop160_redo
  loop160_done:
    pop_eh 
  for_undef_72:
.annotate "line", 293
    new $P163, "Exception"
    set $P163['type'], 58
    find_lex $P164, "$result"
    setattribute $P163, 'payload', $P164
    throw $P163
.annotate "line", 286
    .return ()
  control_142:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P165, exception, "payload"
    .return ($P165)
.end


.namespace []
.sub "_block153"  :anon :subid("20_1261116270.65639") :outer("19_1261116270.65639")
    .param pmc param_155
.annotate "line", 289
    .lex "$_", param_155
.annotate "line", 290
    find_lex $P156, "&code"
    find_lex $P157, "$result"
    find_lex $P158, "$_"
    $P159 = $P156($P157, $P158)
    store_lex "$result", $P159
.annotate "line", 289
    .return ($P159)
.end


.namespace []
.sub "hash"  :subid("21_1261116270.65639") :outer("10_1261116270.65639")
    .param pmc param_169 :slurpy :named
.annotate "line", 314
    new $P168, 'ExceptionHandler'
    set_addr $P168, control_167
    $P168."handle_types"(58)
    push_eh $P168
    .lex "%h", param_169
    new $P170, "Exception"
    set $P170['type'], 58
    find_lex $P171, "%h"
    setattribute $P170, 'payload', $P171
    throw $P170
    .return ()
  control_167:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P172, exception, "payload"
    .return ($P172)
.end


.namespace []
.sub "set_from_array"  :subid("22_1261116270.65639") :outer("10_1261116270.65639")
    .param pmc param_176
.annotate "line", 327
    .const 'Sub' $P184 = "23_1261116270.65639" 
    capture_lex $P184
    new $P175, 'ExceptionHandler'
    set_addr $P175, control_174
    $P175."handle_types"(58)
    push_eh $P175
    .lex "@array", param_176
.annotate "line", 328
    new $P177, "Hash"
    .lex "%set", $P177
.annotate "line", 327
    find_lex $P178, "%set"
.annotate "line", 330
    find_lex $P180, "@array"
    defined $I181, $P180
    unless $I181, for_undef_73
    iter $P179, $P180
    new $P190, 'ExceptionHandler'
    set_addr $P190, loop189_handler
    $P190."handle_types"(65, 67, 66)
    push_eh $P190
  loop189_test:
    unless $P179, loop189_done
    shift $P182, $P179
  loop189_redo:
    .const 'Sub' $P184 = "23_1261116270.65639" 
    capture_lex $P184
    $P184($P182)
  loop189_next:
    goto loop189_test
  loop189_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P191, exception, 'type'
    eq $P191, 65, loop189_next
    eq $P191, 67, loop189_redo
  loop189_done:
    pop_eh 
  for_undef_73:
.annotate "line", 334
    new $P192, "Exception"
    set $P192['type'], 58
    find_lex $P193, "%set"
    setattribute $P192, 'payload', $P193
    throw $P192
.annotate "line", 327
    .return ()
  control_174:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P194, exception, "payload"
    .return ($P194)
.end


.namespace []
.sub "_block183"  :anon :subid("23_1261116270.65639") :outer("22_1261116270.65639")
    .param pmc param_185
.annotate "line", 330
    .lex "$_", param_185
.annotate "line", 331
    new $P186, "Integer"
    assign $P186, 1
    find_lex $P187, "$_"
    find_lex $P188, "%set"
    unless_null $P188, vivify_74
    new $P188, "Hash"
    store_lex "%set", $P188
  vivify_74:
    set $P188[$P187], $P186
.annotate "line", 330
    .return ($P186)
.end


.namespace []
.sub "fscat"  :subid("24_1261116270.65639") :outer("10_1261116270.65639")
    .param pmc param_198
    .param pmc param_199 :slurpy
.annotate "line", 359
    new $P197, 'ExceptionHandler'
    set_addr $P197, control_196
    $P197."handle_types"(58)
    push_eh $P197
    .lex "@path_parts", param_198
    .lex "@filename", param_199
.annotate "line", 363
    new $P200, "Undef"
    .lex "$sep", $P200
.annotate "line", 364
    new $P201, "Undef"
    .lex "$joined", $P201
.annotate "line", 361
    find_lex $P203, "@filename"
    set $N204, $P203
    isgt $I205, $N204, 1.0
    unless $I205, if_202_end
.annotate "line", 360
    die "Only one filename allowed in fscat()"
  if_202_end:
.annotate "line", 363
    getinterp $P206
    set $P207, $P206[6]
    unless_null $P207, vivify_75
    new $P207, "Hash"
  vivify_75:
    set $P208, $P207["slash"]
    unless_null $P208, vivify_76
    new $P208, "Undef"
  vivify_76:
    store_lex "$sep", $P208
.annotate "line", 364
    find_lex $P209, "$sep"
    set $S210, $P209
    find_lex $P211, "@path_parts"
    join $S212, $S210, $P211
    new $P213, 'String'
    set $P213, $S212
    store_lex "$joined", $P213
.annotate "line", 365
    find_lex $P215, "@filename"
    unless $P215, if_214_end
    find_lex $P216, "$joined"
    find_lex $P217, "$sep"
    concat $P218, $P216, $P217
    find_lex $P219, "@filename"
    unless_null $P219, vivify_77
    new $P219, "ResizablePMCArray"
  vivify_77:
    set $P220, $P219[0]
    unless_null $P220, vivify_78
    new $P220, "Undef"
  vivify_78:
    concat $P221, $P218, $P220
    store_lex "$joined", $P221
  if_214_end:
.annotate "line", 367
    new $P222, "Exception"
    set $P222['type'], 58
    find_lex $P223, "$joined"
    setattribute $P222, 'payload', $P223
    throw $P222
.annotate "line", 359
    .return ()
  control_196:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P224, exception, "payload"
    .return ($P224)
.end


.namespace []
.sub "user_home_dir"  :subid("25_1261116270.65639") :outer("10_1261116270.65639")
.annotate "line", 379
    new $P227, 'ExceptionHandler'
    set_addr $P227, control_226
    $P227."handle_types"(58)
    push_eh $P227
.annotate "line", 380
    new $P228, "Hash"
    .lex "%env", $P228
    new $P229, "ResizablePMCArray"
    push $P229, "parrot"
    push $P229, "Env"
    root_new $P230, $P229
    store_lex "%env", $P230
.annotate "line", 381
    new $P231, "Exception"
    set $P231['type'], 58
    find_lex $P233, "%env"
    unless_null $P233, vivify_79
    new $P233, "Hash"
  vivify_79:
    set $P234, $P233["HOMEDRIVE"]
    unless_null $P234, vivify_80
    new $P234, "Undef"
  vivify_80:
    set $P232, $P234
    defined $I236, $P232
    if $I236, default_235
    new $P237, "String"
    assign $P237, ""
    set $P232, $P237
  default_235:
    find_lex $P238, "%env"
    unless_null $P238, vivify_81
    new $P238, "Hash"
  vivify_81:
    set $P239, $P238["HOME"]
    unless_null $P239, vivify_82
    new $P239, "Undef"
  vivify_82:
    concat $P240, $P232, $P239
    setattribute $P231, 'payload', $P240
    throw $P231
.annotate "line", 379
    .return ()
  control_226:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P241, exception, "payload"
    .return ($P241)
.end


.namespace []
.sub "path_exists"  :subid("26_1261116270.65639") :outer("10_1261116270.65639")
    .param pmc param_245
.annotate "line", 394
    .const 'Sub' $P259 = "27_1261116270.65639" 
    capture_lex $P259
    new $P244, 'ExceptionHandler'
    set_addr $P244, control_243
    $P244."handle_types"(58)
    push_eh $P244
    new $P255, 'ExceptionHandler'
    set_addr $P255, control_254
    $P255."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P255
    .lex "$path", param_245
.annotate "line", 395
    new $P246, "ResizablePMCArray"
    .lex "@stat", $P246
    new $P247, "ResizablePMCArray"
    push $P247, "parrot"
    push $P247, "OS"
    root_new $P248, $P247
    find_lex $P249, "$path"
    $P250 = $P248."stat"($P249)
    store_lex "@stat", $P250
.annotate "line", 396
    new $P251, "Exception"
    set $P251['type'], 58
    new $P252, "Integer"
    assign $P252, 1
    setattribute $P251, 'payload', $P252
    throw $P251
.annotate "line", 394
    pop_eh 
    goto skip_handler_253
  control_254:
.annotate "line", 398
    .local pmc exception 
    .get_results (exception) 
    .const 'Sub' $P259 = "27_1261116270.65639" 
    capture_lex $P259
    $P259(exception)
    new $P264, 'Integer'
    set $P264, 1
    set exception["handled"], $P264
    set $I265, exception["handled"]
    ne $I265, 1, nothandled_257
  handled_256:
    .return (exception)
  nothandled_257:
    rethrow exception
  skip_handler_253:
.annotate "line", 394
    .return ()
  control_243:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P266, exception, "payload"
    .return ($P266)
.end


.namespace []
.sub "_block258"  :anon :subid("27_1261116270.65639") :outer("26_1261116270.65639")
    .param pmc param_260
.annotate "line", 398
    .lex "$_", param_260
    find_lex $P261, "$_"
    .lex "$!", $P261
.annotate "line", 399
    new $P262, "Exception"
    set $P262['type'], 58
    new $P263, "Integer"
    assign $P263, 0
    setattribute $P262, 'payload', $P263
    throw $P262
.annotate "line", 398
    .return ()
.end


.namespace []
.sub "is_dir"  :subid("28_1261116270.65639") :outer("10_1261116270.65639")
    .param pmc param_270
.annotate "line", 413
    .const 'Sub' $P287 = "29_1261116270.65639" 
    capture_lex $P287
    new $P269, 'ExceptionHandler'
    set_addr $P269, control_268
    $P269."handle_types"(58)
    push_eh $P269
    new $P283, 'ExceptionHandler'
    set_addr $P283, control_282
    $P283."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P283
    .lex "$path", param_270
.annotate "line", 414
    new $P271, "ResizablePMCArray"
    .lex "@stat", $P271
    new $P272, "ResizablePMCArray"
    push $P272, "parrot"
    push $P272, "OS"
    root_new $P273, $P272
    find_lex $P274, "$path"
    $P275 = $P273."stat"($P274)
    store_lex "@stat", $P275
.annotate "line", 415
    new $P276, "Exception"
    set $P276['type'], 58
    find_lex $P277, "$path"
    set $S278, $P277
    stat $I279, $S278, 2
    new $P280, 'Integer'
    set $P280, $I279
    setattribute $P276, 'payload', $P280
    throw $P276
.annotate "line", 413
    pop_eh 
    goto skip_handler_281
  control_282:
.annotate "line", 417
    .local pmc exception 
    .get_results (exception) 
    .const 'Sub' $P287 = "29_1261116270.65639" 
    capture_lex $P287
    $P287(exception)
    new $P292, 'Integer'
    set $P292, 1
    set exception["handled"], $P292
    set $I293, exception["handled"]
    ne $I293, 1, nothandled_285
  handled_284:
    .return (exception)
  nothandled_285:
    rethrow exception
  skip_handler_281:
.annotate "line", 413
    .return ()
  control_268:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P294, exception, "payload"
    .return ($P294)
.end


.namespace []
.sub "_block286"  :anon :subid("29_1261116270.65639") :outer("28_1261116270.65639")
    .param pmc param_288
.annotate "line", 417
    .lex "$_", param_288
    find_lex $P289, "$_"
    .lex "$!", $P289
.annotate "line", 418
    new $P290, "Exception"
    set $P290['type'], 58
    new $P291, "Integer"
    assign $P291, 0
    setattribute $P290, 'payload', $P291
    throw $P290
.annotate "line", 417
    .return ()
.end


.namespace []
.sub "test_dir_writable"  :subid("30_1261116270.65639") :outer("10_1261116270.65639")
    .param pmc param_298
.annotate "line", 440
    .const 'Sub' $P311 = "31_1261116270.65639" 
    capture_lex $P311
    new $P297, 'ExceptionHandler'
    set_addr $P297, control_296
    $P297."handle_types"(58)
    push_eh $P297
    .lex "$dir", param_298
.annotate "line", 441
    new $P299, "Undef"
    .lex "$test_file", $P299
    find_lex $P300, "$dir"
    new $P301, "ResizablePMCArray"
    push $P301, $P300
    $P302 = "fscat"($P301, "WrItAbLe.UtL")
    store_lex "$test_file", $P302
.annotate "line", 444
    find_lex $P304, "$test_file"
    $P305 = "path_exists"($P304)
    unless $P305, if_303_end
.annotate "line", 443
    new $P306, 'String'
    set $P306, "Test file '"
    find_lex $P307, "$test_file"
    concat $P308, $P306, $P307
    concat $P309, $P308, "'\nthat should never exist already does."
    die $P309
  if_303_end:
.annotate "line", 446
    .const 'Sub' $P311 = "31_1261116270.65639" 
    capture_lex $P311
    $P311()
.annotate "line", 450
    find_lex $P323, "$test_file"
    $P324 = "path_exists"($P323)
    if $P324, if_322
.annotate "line", 455
    new $P330, "Exception"
    set $P330['type'], 58
    new $P331, "Integer"
    assign $P331, 0
    setattribute $P330, 'payload', $P331
    throw $P330
.annotate "line", 454
    goto if_322_end
  if_322:
.annotate "line", 451
    new $P325, "ResizablePMCArray"
    push $P325, "parrot"
    push $P325, "OS"
    root_new $P326, $P325
    find_lex $P327, "$test_file"
    $P326."rm"($P327)
.annotate "line", 452
    new $P328, "Exception"
    set $P328['type'], 58
    new $P329, "Integer"
    assign $P329, 1
    setattribute $P328, 'payload', $P329
    throw $P328
  if_322_end:
.annotate "line", 440
    .return ($P321)
  control_296:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P332, exception, "payload"
    .return ($P332)
.end


.namespace []
.sub "_block310"  :anon :subid("31_1261116270.65639") :outer("30_1261116270.65639")
.annotate "line", 446
    new $P316, 'ExceptionHandler'
    set_addr $P316, control_315
    $P316."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P316
.annotate "line", 447
    find_lex $P312, "$test_file"
    $P313 = "spew"($P312, "test_dir_writable() test file.\n")
.annotate "line", 446
    pop_eh 
    goto skip_handler_314
  control_315:
    .local pmc exception 
    .get_results (exception) 
    new $P319, 'Integer'
    set $P319, 1
    set exception["handled"], $P319
    set $I320, exception["handled"]
    ne $I320, 1, nothandled_318
  handled_317:
    .return (exception)
  nothandled_318:
    rethrow exception
  skip_handler_314:
    .return ($P313)
.end


.namespace []
.sub "find_program"  :subid("32_1261116270.65639") :outer("10_1261116270.65639")
    .param pmc param_336
.annotate "line", 479
    .const 'Sub' $P367 = "33_1261116270.65639" 
    capture_lex $P367
    new $P335, 'ExceptionHandler'
    set_addr $P335, control_334
    $P335."handle_types"(58)
    push_eh $P335
    .lex "$program", param_336
.annotate "line", 480
    new $P337, "Undef"
    .lex "$path_sep", $P337
.annotate "line", 481
    new $P338, "Hash"
    .lex "%env", $P338
.annotate "line", 482
    new $P339, "ResizablePMCArray"
    .lex "@paths", $P339
.annotate "line", 483
    new $P340, "ResizablePMCArray"
    .lex "@exts", $P340
.annotate "line", 480
    sysinfo $S343, 4
    iseq $I344, $S343, "MSWin32"
    if $I344, if_342
    new $P346, "String"
    assign $P346, ":"
    set $P341, $P346
    goto if_342_end
  if_342:
    new $P345, "String"
    assign $P345, ";"
    set $P341, $P345
  if_342_end:
    store_lex "$path_sep", $P341
.annotate "line", 481
    new $P347, "ResizablePMCArray"
    push $P347, "parrot"
    push $P347, "Env"
    root_new $P348, $P347
    store_lex "%env", $P348
.annotate "line", 482
    find_lex $P349, "$path_sep"
    set $S350, $P349
    find_lex $P351, "%env"
    unless_null $P351, vivify_83
    new $P351, "Hash"
  vivify_83:
    set $P352, $P351["PATH"]
    unless_null $P352, vivify_84
    new $P352, "Undef"
  vivify_84:
    set $S353, $P352
    split $P354, $S350, $S353
    store_lex "@paths", $P354
.annotate "line", 483
    find_lex $P355, "$path_sep"
    set $S356, $P355
    find_lex $P357, "%env"
    unless_null $P357, vivify_85
    new $P357, "Hash"
  vivify_85:
    set $P358, $P357["PATHEXT"]
    unless_null $P358, vivify_86
    new $P358, "Undef"
  vivify_86:
    set $S359, $P358
    split $P360, $S356, $S359
    store_lex "@exts", $P360
.annotate "line", 485
    find_lex $P361, "@exts"
    $P361."unshift"("")
.annotate "line", 487
    find_lex $P363, "@paths"
    defined $I364, $P363
    unless $I364, for_undef_87
    iter $P362, $P363
    new $P395, 'ExceptionHandler'
    set_addr $P395, loop394_handler
    $P395."handle_types"(65, 67, 66)
    push_eh $P395
  loop394_test:
    unless $P362, loop394_done
    shift $P365, $P362
  loop394_redo:
    .const 'Sub' $P367 = "33_1261116270.65639" 
    capture_lex $P367
    $P367($P365)
  loop394_next:
    goto loop394_test
  loop394_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P396, exception, 'type'
    eq $P396, 65, loop394_next
    eq $P396, 67, loop394_redo
  loop394_done:
    pop_eh 
  for_undef_87:
.annotate "line", 496
    new $P397, "Exception"
    set $P397['type'], 58
    new $P398, "String"
    assign $P398, ""
    setattribute $P397, 'payload', $P398
    throw $P397
.annotate "line", 479
    .return ()
  control_334:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P399, exception, "payload"
    .return ($P399)
.end


.namespace []
.sub "_block366"  :anon :subid("33_1261116270.65639") :outer("32_1261116270.65639")
    .param pmc param_368
.annotate "line", 487
    .const 'Sub' $P379 = "34_1261116270.65639" 
    capture_lex $P379
    .lex "$dir", param_368
.annotate "line", 488
    new $P369, "Undef"
    .lex "$path", $P369
    find_lex $P370, "$dir"
    new $P371, "ResizablePMCArray"
    push $P371, $P370
    find_lex $P372, "$program"
    $P373 = "fscat"($P371, $P372)
    store_lex "$path", $P373
.annotate "line", 490
    find_lex $P375, "@exts"
    defined $I376, $P375
    unless $I376, for_undef_88
    iter $P374, $P375
    new $P392, 'ExceptionHandler'
    set_addr $P392, loop391_handler
    $P392."handle_types"(65, 67, 66)
    push_eh $P392
  loop391_test:
    unless $P374, loop391_done
    shift $P377, $P374
  loop391_redo:
    .const 'Sub' $P379 = "34_1261116270.65639" 
    capture_lex $P379
    $P379($P377)
  loop391_next:
    goto loop391_test
  loop391_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P393, exception, 'type'
    eq $P393, 65, loop391_next
    eq $P393, 67, loop391_redo
  loop391_done:
    pop_eh 
  for_undef_88:
.annotate "line", 487
    .return ($P374)
.end


.namespace []
.sub "_block378"  :anon :subid("34_1261116270.65639") :outer("33_1261116270.65639")
    .param pmc param_380
.annotate "line", 490
    .lex "$ext", param_380
.annotate "line", 491
    new $P381, "Undef"
    .lex "$pathext", $P381
    find_lex $P382, "$path"
    find_lex $P383, "$ext"
    concat $P384, $P382, $P383
    store_lex "$pathext", $P384
.annotate "line", 492
    find_lex $P387, "$pathext"
    $P388 = "path_exists"($P387)
    if $P388, if_386
    set $P385, $P388
    goto if_386_end
  if_386:
    new $P389, "Exception"
    set $P389['type'], 58
    find_lex $P390, "$pathext"
    setattribute $P389, 'payload', $P390
    throw $P389
  if_386_end:
.annotate "line", 490
    .return ($P385)
.end


.namespace []
.sub "mkpath"  :subid("35_1261116270.65639") :outer("10_1261116270.65639")
    .param pmc param_403
.annotate "line", 509
    .const 'Sub' $P416 = "36_1261116270.65639" 
    capture_lex $P416
    new $P402, 'ExceptionHandler'
    set_addr $P402, control_401
    $P402."handle_types"(58)
    push_eh $P402
    .lex "$path", param_403
.annotate "line", 510
    new $P404, "ResizablePMCArray"
    .lex "@path", $P404
.annotate "line", 511
    new $P405, "Undef"
    .lex "$cur", $P405
.annotate "line", 510
    find_lex $P406, "$path"
    set $S407, $P406
    split $P408, "/", $S407
    store_lex "@path", $P408
.annotate "line", 511
    find_lex $P409, "@path"
    $P410 = $P409."shift"()
    store_lex "$cur", $P410
.annotate "line", 513
    find_lex $P412, "@path"
    defined $I413, $P412
    unless $I413, for_undef_89
    iter $P411, $P412
    new $P431, 'ExceptionHandler'
    set_addr $P431, loop430_handler
    $P431."handle_types"(65, 67, 66)
    push_eh $P431
  loop430_test:
    unless $P411, loop430_done
    shift $P414, $P411
  loop430_redo:
    .const 'Sub' $P416 = "36_1261116270.65639" 
    capture_lex $P416
    $P416($P414)
  loop430_next:
    goto loop430_test
  loop430_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P432, exception, 'type'
    eq $P432, 65, loop430_next
    eq $P432, 67, loop430_redo
  loop430_done:
    pop_eh 
  for_undef_89:
.annotate "line", 509
    .return ($P411)
  control_401:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P433, exception, "payload"
    .return ($P433)
.end


.namespace []
.sub "_block415"  :anon :subid("36_1261116270.65639") :outer("35_1261116270.65639")
    .param pmc param_417
.annotate "line", 513
    .lex "$dir", param_417
.annotate "line", 514
    find_lex $P418, "$cur"
    find_lex $P419, "$dir"
    new $P420, "ResizablePMCArray"
    push $P420, $P418
    push $P420, $P419
    $P421 = "fscat"($P420)
    store_lex "$cur", $P421
.annotate "line", 516
    find_lex $P424, "$cur"
    $P425 = "path_exists"($P424)
    unless $P425, unless_423
    set $P422, $P425
    goto unless_423_end
  unless_423:
.annotate "line", 517
    new $P426, "ResizablePMCArray"
    push $P426, "parrot"
    push $P426, "OS"
    root_new $P427, $P426
    find_lex $P428, "$cur"
    $P429 = $P427."mkdir"($P428, 511)
.annotate "line", 516
    set $P422, $P429
  unless_423_end:
.annotate "line", 513
    .return ($P422)
.end


.namespace []
.sub "run"  :subid("37_1261116270.65639") :outer("10_1261116270.65639")
    .param pmc param_437 :slurpy
.annotate "line", 544
    new $P436, 'ExceptionHandler'
    set_addr $P436, control_435
    $P436."handle_types"(58)
    push_eh $P436
    .lex "@command_and_args", param_437
.annotate "line", 545
    new $P438, "Exception"
    set $P438['type'], 58
    find_lex $P439, "@command_and_args"
    spawnw $I440, $P439
    new $P441, 'Integer'
    set $P441, $I440
    shr $P442, $P441, 8
    setattribute $P438, 'payload', $P442
    throw $P438
.annotate "line", 544
    .return ()
  control_435:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P443, exception, "payload"
    .return ($P443)
.end


.namespace []
.sub "do_run"  :subid("38_1261116270.65639") :outer("10_1261116270.65639")
    .param pmc param_447 :slurpy
.annotate "line", 562
    .const 'Sub' $P463 = "39_1261116270.65639" 
    capture_lex $P463
    new $P446, 'ExceptionHandler'
    set_addr $P446, control_445
    $P446."handle_types"(58)
    push_eh $P446
    new $P459, 'ExceptionHandler'
    set_addr $P459, control_458
    $P459."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P459
    .lex "@command_and_args", param_447
.annotate "line", 563
    find_lex $P448, "@command_and_args"
    join $S449, " ", $P448
    "say"($S449)
.annotate "line", 565
    new $P450, "Exception"
    set $P450['type'], 58
    find_lex $P453, "@command_and_args"
    spawnw $I454, $P453
    if $I454, if_452
    new $P456, "Integer"
    assign $P456, 1
    set $P451, $P456
    goto if_452_end
  if_452:
    new $P455, "Integer"
    assign $P455, 0
    set $P451, $P455
  if_452_end:
    setattribute $P450, 'payload', $P451
    throw $P450
.annotate "line", 562
    pop_eh 
    goto skip_handler_457
  control_458:
.annotate "line", 567
    .local pmc exception 
    .get_results (exception) 
    .const 'Sub' $P463 = "39_1261116270.65639" 
    capture_lex $P463
    $P463(exception)
    new $P468, 'Integer'
    set $P468, 1
    set exception["handled"], $P468
    set $I469, exception["handled"]
    ne $I469, 1, nothandled_461
  handled_460:
    .return (exception)
  nothandled_461:
    rethrow exception
  skip_handler_457:
.annotate "line", 562
    .return ()
  control_445:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P470, exception, "payload"
    .return ($P470)
.end


.namespace []
.sub "_block462"  :anon :subid("39_1261116270.65639") :outer("38_1261116270.65639")
    .param pmc param_464
.annotate "line", 567
    .lex "$_", param_464
    find_lex $P465, "$_"
    .lex "$!", $P465
.annotate "line", 568
    new $P466, "Exception"
    set $P466['type'], 58
    new $P467, "Integer"
    assign $P467, -1
    setattribute $P466, 'payload', $P467
    throw $P466
.annotate "line", 567
    .return ()
.end


.namespace []
.sub "qx"  :subid("40_1261116270.65639") :outer("10_1261116270.65639")
    .param pmc param_474 :slurpy
.annotate "line", 586
    new $P473, 'ExceptionHandler'
    set_addr $P473, control_472
    $P473."handle_types"(58)
    push_eh $P473
    .lex "@command_and_args", param_474
.annotate "line", 587
    new $P475, "Undef"
    .lex "$cmd", $P475
.annotate "line", 588
    new $P476, "Undef"
    .lex "$pipe", $P476
.annotate "line", 592
    new $P477, "Undef"
    .lex "$output", $P477
.annotate "line", 587
    find_lex $P478, "@command_and_args"
    join $S479, " ", $P478
    new $P480, 'String'
    set $P480, $S479
    store_lex "$cmd", $P480
.annotate "line", 588
    find_lex $P481, "$cmd"
    set $S482, $P481
    open $P483, $S482, "rp"
    store_lex "$pipe", $P483
.annotate "line", 589
    find_lex $P485, "$pipe"
    if $P485, unless_484_end
    new $P486, 'String'
    set $P486, "Unable to execute '"
    find_lex $P487, "$cmd"
    concat $P488, $P486, $P487
    concat $P489, $P488, "'"
    die $P489
  unless_484_end:
.annotate "line", 591
    find_lex $P490, "$pipe"
    $P490."encoding"("utf8")
.annotate "line", 592
    find_lex $P491, "$pipe"
    $P492 = $P491."readall"()
    store_lex "$output", $P492
.annotate "line", 593
    find_lex $P493, "$pipe"
    $P493."close"()
.annotate "line", 595
    find_lex $P494, "$pipe"
    $P495 = $P494."exit_status"()
    "store_dynlex_safely"("$!", $P495)
.annotate "line", 597
    new $P496, "Exception"
    set $P496['type'], 58
    find_lex $P497, "$output"
    setattribute $P496, 'payload', $P497
    throw $P496
.annotate "line", 586
    .return ()
  control_472:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P498, exception, "payload"
    .return ($P498)
.end


.namespace []
.sub "store_dynlex_safely"  :subid("41_1261116270.65639") :outer("10_1261116270.65639")
    .param pmc param_502
    .param pmc param_503
.annotate "line", 621
    new $P501, 'ExceptionHandler'
    set_addr $P501, control_500
    $P501."handle_types"(58)
    push_eh $P501
    .lex "$var_name", param_502
    .lex "$value", param_503
.annotate "line", 623
    find_lex $P506, "$var_name"
    set $S507, $P506
    find_dynamic_lex $P508, $S507
    isnull $I509, $P508
    unless $I509, unless_505
    new $P504, 'Integer'
    set $P504, $I509
    goto unless_505_end
  unless_505:
.annotate "line", 622
    find_lex $P510, "$var_name"
    set $S511, $P510
    find_lex $P512, "$value"
    store_dynamic_lex $S511, $P512
  unless_505_end:
.annotate "line", 621
    .return ($P504)
  control_500:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P513, exception, "payload"
    .return ($P513)
.end


.namespace []
.sub "replace_config_strings"  :subid("42_1261116270.65639") :outer("10_1261116270.65639")
    .param pmc param_517
.annotate "line", 741
    new $P516, 'ExceptionHandler'
    set_addr $P516, control_515
    $P516."handle_types"(58)
    push_eh $P516
    .lex "$original", param_517
.annotate "line", 742
    new $P518, "Undef"
    .lex "$new", $P518
    find_lex $P519, "$original"
    store_lex "$new", $P519
.annotate "line", 744
    new $P531, 'ExceptionHandler'
    set_addr $P531, loop530_handler
    $P531."handle_types"(65, 67, 66)
    push_eh $P531
    goto loop530_redo
  loop530_test:
.annotate "line", 748
    find_lex $P520, "$new"
    set $S521, $P520
    find_lex $P522, "$original"
    set $S523, $P522
    isne $I524, $S521, $S523
    unless $I524, loop530_done
  loop530_redo:
.annotate "line", 745
    find_lex $P525, "$new"
    store_lex "$original", $P525
.annotate "line", 746
    find_lex $P526, "$original"
    $P527 = "rx"("\\#<ident>\\#")
    get_hll_global $P528, "config_value"
    $P529 = "subst"($P526, $P527, $P528)
    store_lex "$new", $P529
  loop530_next:
.annotate "line", 744
    goto loop530_test
  loop530_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P532, exception, 'type'
    eq $P532, 65, loop530_next
    eq $P532, 67, loop530_redo
  loop530_done:
    pop_eh 
.annotate "line", 750
    new $P533, "Exception"
    set $P533['type'], 58
    find_lex $P534, "$new"
    setattribute $P533, 'payload', $P534
    throw $P533
.annotate "line", 741
    .return ()
  control_515:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P535, exception, "payload"
    .return ($P535)
.end


.namespace []
.sub "config_value"  :subid("43_1261116270.65639") :outer("10_1261116270.65639")
    .param pmc param_539
.annotate "line", 753
    new $P538, 'ExceptionHandler'
    set_addr $P538, control_537
    $P538."handle_types"(58)
    push_eh $P538
    .lex "$match", param_539
.annotate "line", 754
    new $P540, "Undef"
    .lex "$key", $P540
.annotate "line", 755
    new $P541, "Undef"
    .lex "$config", $P541
.annotate "line", 754
    find_lex $P542, "$match"
    unless_null $P542, vivify_90
    new $P542, "Hash"
  vivify_90:
    set $P543, $P542["ident"]
    unless_null $P543, vivify_91
    new $P543, "Undef"
  vivify_91:
    store_lex "$key", $P543
.annotate "line", 756
    find_lex $P552, "$key"
    find_dynamic_lex $P553, "%*CONF"
    unless_null $P553, vivify_92
    get_hll_global $P553, "%CONF"
    unless_null $P553, vivify_93
    die "Contextual %*CONF not found"
  vivify_93:
  vivify_92:
    set $P554, $P553[$P552]
    unless_null $P554, vivify_94
    new $P554, "Undef"
  vivify_94:
    unless $P554, unless_551
    set $P550, $P554
    goto unless_551_end
  unless_551:
    find_lex $P555, "$key"
    find_dynamic_lex $P556, "%*VM"
    unless_null $P556, vivify_95
    get_hll_global $P556, "%VM"
    unless_null $P556, vivify_96
    die "Contextual %*VM not found"
  vivify_96:
  vivify_95:
    set $P557, $P556["config"]
    unless_null $P557, vivify_97
    new $P557, "Hash"
  vivify_97:
    set $P558, $P557[$P555]
    unless_null $P558, vivify_98
    new $P558, "Undef"
  vivify_98:
    set $P550, $P558
  unless_551_end:
    unless $P550, unless_549
    set $P548, $P550
    goto unless_549_end
  unless_549:
    find_lex $P559, "$key"
    find_dynamic_lex $P560, "%*BIN"
    unless_null $P560, vivify_99
    get_hll_global $P560, "%BIN"
    unless_null $P560, vivify_100
    die "Contextual %*BIN not found"
  vivify_100:
  vivify_99:
    set $P561, $P560[$P559]
    unless_null $P561, vivify_101
    new $P561, "Undef"
  vivify_101:
    set $P548, $P561
  unless_549_end:
.annotate "line", 757
    unless $P548, unless_547
    set $P546, $P548
    goto unless_547_end
  unless_547:
    find_lex $P562, "$key"
    find_dynamic_lex $P563, "%*ENV"
    unless_null $P563, vivify_102
    get_hll_global $P563, "%ENV"
    unless_null $P563, vivify_103
    die "Contextual %*ENV not found"
  vivify_103:
  vivify_102:
    set $P564, $P563[$P562]
    unless_null $P564, vivify_104
    new $P564, "Undef"
  vivify_104:
    set $P546, $P564
  unless_547_end:
.annotate "line", 758
    unless $P546, unless_545
    set $P544, $P546
    goto unless_545_end
  unless_545:
    new $P565, "String"
    assign $P565, ""
    set $P544, $P565
  unless_545_end:
.annotate "line", 759
    store_lex "$config", $P544
.annotate "line", 761
    new $P566, "Exception"
    set $P566['type'], 58
    find_lex $P567, "$config"
    setattribute $P566, 'payload', $P567
    throw $P566
.annotate "line", 753
    .return ()
  control_537:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P568, exception, "payload"
    .return ($P568)
.end


.namespace ["Hash"]
.sub "_block569"  :subid("44_1261116270.65639") :outer("10_1261116270.65639")
.annotate "line", 70
    .const 'Sub' $P620 = "50_1261116270.65639" 
    capture_lex $P620
    .const 'Sub' $P599 = "48_1261116270.65639" 
    capture_lex $P599
    .const 'Sub' $P578 = "46_1261116270.65639" 
    capture_lex $P578
    .const 'Sub' $P571 = "45_1261116270.65639" 
    capture_lex $P571
.annotate "line", 133
    .const 'Sub' $P620 = "50_1261116270.65639" 
    capture_lex $P620
.annotate "line", 70
    .return ($P620)
.end


.namespace ["Hash"]
.sub "exists"  :subid("45_1261116270.65639") :method :outer("44_1261116270.65639")
    .param pmc param_574
.annotate "line", 83
    new $P573, 'ExceptionHandler'
    set_addr $P573, control_572
    $P573."handle_types"(58)
    push_eh $P573
    .lex "self", self
    .lex "$key", param_574
.annotate "line", 84
    new $P575, "Exception"
    set $P575['type'], 58

            $P1 = find_lex '$key'
            $I0 = exists self[$P1]
            $P576  = box $I0
        
    setattribute $P575, 'payload', $P576
    throw $P575
.annotate "line", 83
    .return ()
  control_572:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P577, exception, "payload"
    .return ($P577)
.end


.namespace ["Hash"]
.sub "keys"  :subid("46_1261116270.65639") :method :outer("44_1261116270.65639")
.annotate "line", 100
    .const 'Sub' $P588 = "47_1261116270.65639" 
    capture_lex $P588
    new $P580, 'ExceptionHandler'
    set_addr $P580, control_579
    $P580."handle_types"(58)
    push_eh $P580
    .lex "self", self
.annotate "line", 101
    new $P581, "ResizablePMCArray"
    .lex "@keys", $P581
.annotate "line", 100
    find_lex $P582, "@keys"
.annotate "line", 102
    find_lex $P584, "self"
    defined $I585, $P584
    unless $I585, for_undef_105
    iter $P583, $P584
    new $P595, 'ExceptionHandler'
    set_addr $P595, loop594_handler
    $P595."handle_types"(65, 67, 66)
    push_eh $P595
  loop594_test:
    unless $P583, loop594_done
    shift $P586, $P583
  loop594_redo:
    .const 'Sub' $P588 = "47_1261116270.65639" 
    capture_lex $P588
    $P588($P586)
  loop594_next:
    goto loop594_test
  loop594_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P596, exception, 'type'
    eq $P596, 65, loop594_next
    eq $P596, 67, loop594_redo
  loop594_done:
    pop_eh 
  for_undef_105:
    find_lex $P597, "@keys"
.annotate "line", 100
    .return ($P597)
  control_579:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P598, exception, "payload"
    .return ($P598)
.end


.namespace ["Hash"]
.sub "_block587"  :anon :subid("47_1261116270.65639") :outer("46_1261116270.65639")
    .param pmc param_589
.annotate "line", 102
    .lex "$_", param_589
    find_lex $P590, "@keys"
    find_lex $P591, "$_"
    $P592 = $P591."key"()
    $P593 = $P590."push"($P592)
    .return ($P593)
.end


.namespace ["Hash"]
.sub "values"  :subid("48_1261116270.65639") :method :outer("44_1261116270.65639")
.annotate "line", 115
    .const 'Sub' $P609 = "49_1261116270.65639" 
    capture_lex $P609
    new $P601, 'ExceptionHandler'
    set_addr $P601, control_600
    $P601."handle_types"(58)
    push_eh $P601
    .lex "self", self
.annotate "line", 116
    new $P602, "ResizablePMCArray"
    .lex "@values", $P602
.annotate "line", 115
    find_lex $P603, "@values"
.annotate "line", 117
    find_lex $P605, "self"
    defined $I606, $P605
    unless $I606, for_undef_106
    iter $P604, $P605
    new $P616, 'ExceptionHandler'
    set_addr $P616, loop615_handler
    $P616."handle_types"(65, 67, 66)
    push_eh $P616
  loop615_test:
    unless $P604, loop615_done
    shift $P607, $P604
  loop615_redo:
    .const 'Sub' $P609 = "49_1261116270.65639" 
    capture_lex $P609
    $P609($P607)
  loop615_next:
    goto loop615_test
  loop615_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P617, exception, 'type'
    eq $P617, 65, loop615_next
    eq $P617, 67, loop615_redo
  loop615_done:
    pop_eh 
  for_undef_106:
    find_lex $P618, "@values"
.annotate "line", 115
    .return ($P618)
  control_600:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P619, exception, "payload"
    .return ($P619)
.end


.namespace ["Hash"]
.sub "_block608"  :anon :subid("49_1261116270.65639") :outer("48_1261116270.65639")
    .param pmc param_610
.annotate "line", 117
    .lex "$_", param_610
    find_lex $P611, "@values"
    find_lex $P612, "$_"
    $P613 = $P612."value"()
    $P614 = $P611."push"($P613)
    .return ($P614)
.end


.namespace ["Hash"]
.sub "kv"  :subid("50_1261116270.65639") :method :outer("44_1261116270.65639")
.annotate "line", 133
    .const 'Sub' $P630 = "51_1261116270.65639" 
    capture_lex $P630
    new $P622, 'ExceptionHandler'
    set_addr $P622, control_621
    $P622."handle_types"(58)
    push_eh $P622
    .lex "self", self
.annotate "line", 134
    new $P623, "ResizablePMCArray"
    .lex "@kv", $P623
.annotate "line", 133
    find_lex $P624, "@kv"
.annotate "line", 135
    find_lex $P626, "self"
    defined $I627, $P626
    unless $I627, for_undef_107
    iter $P625, $P626
    new $P640, 'ExceptionHandler'
    set_addr $P640, loop639_handler
    $P640."handle_types"(65, 67, 66)
    push_eh $P640
  loop639_test:
    unless $P625, loop639_done
    shift $P628, $P625
  loop639_redo:
    .const 'Sub' $P630 = "51_1261116270.65639" 
    capture_lex $P630
    $P630($P628)
  loop639_next:
    goto loop639_test
  loop639_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P641, exception, 'type'
    eq $P641, 65, loop639_next
    eq $P641, 67, loop639_redo
  loop639_done:
    pop_eh 
  for_undef_107:
    find_lex $P642, "@kv"
.annotate "line", 133
    .return ($P642)
  control_621:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P643, exception, "payload"
    .return ($P643)
.end


.namespace ["Hash"]
.sub "_block629"  :anon :subid("51_1261116270.65639") :outer("50_1261116270.65639")
    .param pmc param_631
.annotate "line", 135
    .lex "$_", param_631
    find_lex $P632, "@kv"
    find_lex $P633, "$_"
    $P634 = $P633."key"()
    $P632."push"($P634)
    find_lex $P635, "@kv"
    find_lex $P636, "$_"
    $P637 = $P636."value"()
    $P638 = $P635."push"($P637)
    .return ($P638)
.end


.namespace ["Array"]
.sub "_block644"  :subid("52_1261116270.65639") :outer("10_1261116270.65639")
.annotate "line", 158
    .const 'Sub' $P646 = "53_1261116270.65639" 
    capture_lex $P646
.annotate "line", 171
    .const 'Sub' $P646 = "53_1261116270.65639" 
    capture_lex $P646
.annotate "line", 158
    .return ($P646)
.end


.namespace ["Array"]
.sub "reverse"  :subid("53_1261116270.65639") :method :outer("52_1261116270.65639")
.annotate "line", 171
    .const 'Sub' $P656 = "54_1261116270.65639" 
    capture_lex $P656
    new $P648, 'ExceptionHandler'
    set_addr $P648, control_647
    $P648."handle_types"(58)
    push_eh $P648
    .lex "self", self
.annotate "line", 172
    new $P649, "ResizablePMCArray"
    .lex "@reversed", $P649
.annotate "line", 171
    find_lex $P650, "@reversed"
.annotate "line", 173
    find_lex $P652, "self"
    defined $I653, $P652
    unless $I653, for_undef_108
    iter $P651, $P652
    new $P662, 'ExceptionHandler'
    set_addr $P662, loop661_handler
    $P662."handle_types"(65, 67, 66)
    push_eh $P662
  loop661_test:
    unless $P651, loop661_done
    shift $P654, $P651
  loop661_redo:
    .const 'Sub' $P656 = "54_1261116270.65639" 
    capture_lex $P656
    $P656($P654)
  loop661_next:
    goto loop661_test
  loop661_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P663, exception, 'type'
    eq $P663, 65, loop661_next
    eq $P663, 67, loop661_redo
  loop661_done:
    pop_eh 
  for_undef_108:
    find_lex $P664, "@reversed"
.annotate "line", 171
    .return ($P664)
  control_647:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P665, exception, "payload"
    .return ($P665)
.end


.namespace ["Array"]
.sub "_block655"  :anon :subid("54_1261116270.65639") :outer("53_1261116270.65639")
    .param pmc param_657
.annotate "line", 173
    .lex "$_", param_657
    find_lex $P658, "@reversed"
    find_lex $P659, "$_"
    $P660 = $P658."unshift"($P659)
    .return ($P660)
.end

