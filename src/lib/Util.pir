
.namespace []
.sub "_block11"  :anon :subid("10_1261457050.23577")
.annotate "line", 0
    .const 'Sub' $P872 = "66_1261457050.23577" 
    capture_lex $P872
    get_hll_global $P823, ["Array"], "_block822" 
    capture_lex $P823
    get_hll_global $P748, ["Hash"], "_block747" 
    capture_lex $P748
    .const 'Sub' $P714 = "54_1261457050.23577" 
    capture_lex $P714
    .const 'Sub' $P687 = "52_1261457050.23577" 
    capture_lex $P687
    .const 'Sub' $P672 = "51_1261457050.23577" 
    capture_lex $P672
    .const 'Sub' $P651 = "50_1261457050.23577" 
    capture_lex $P651
    .const 'Sub' $P623 = "49_1261457050.23577" 
    capture_lex $P623
    .const 'Sub' $P596 = "47_1261457050.23577" 
    capture_lex $P596
    .const 'Sub' $P586 = "46_1261457050.23577" 
    capture_lex $P586
    .const 'Sub' $P552 = "44_1261457050.23577" 
    capture_lex $P552
    .const 'Sub' $P485 = "41_1261457050.23577" 
    capture_lex $P485
    .const 'Sub' $P447 = "39_1261457050.23577" 
    capture_lex $P447
    .const 'Sub' $P419 = "37_1261457050.23577" 
    capture_lex $P419
    .const 'Sub' $P394 = "35_1261457050.23577" 
    capture_lex $P394
    .const 'Sub' $P377 = "34_1261457050.23577" 
    capture_lex $P377
    .const 'Sub' $P347 = "33_1261457050.23577" 
    capture_lex $P347
    .const 'Sub' $P334 = "32_1261457050.23577" 
    capture_lex $P334
    .const 'Sub' $P321 = "31_1261457050.23577" 
    capture_lex $P321
    .const 'Sub' $P306 = "30_1261457050.23577" 
    capture_lex $P306
    .const 'Sub' $P299 = "29_1261457050.23577" 
    capture_lex $P299
    .const 'Sub' $P283 = "27_1261457050.23577" 
    capture_lex $P283
    .const 'Sub' $P222 = "25_1261457050.23577" 
    capture_lex $P222
    .const 'Sub' $P195 = "24_1261457050.23577" 
    capture_lex $P195
    .const 'Sub' $P173 = "22_1261457050.23577" 
    capture_lex $P173
    .const 'Sub' $P166 = "21_1261457050.23577" 
    capture_lex $P166
    .const 'Sub' $P141 = "19_1261457050.23577" 
    capture_lex $P141
    .const 'Sub' $P66 = "15_1261457050.23577" 
    capture_lex $P66
    .const 'Sub' $P38 = "13_1261457050.23577" 
    capture_lex $P38
    .const 'Sub' $P13 = "11_1261457050.23577" 
    capture_lex $P13
.annotate "line", 219
    .const 'Sub' $P13 = "11_1261457050.23577" 
    capture_lex $P13
    .lex "map", $P13
.annotate "line", 239
    .const 'Sub' $P38 = "13_1261457050.23577" 
    capture_lex $P38
    .lex "grep", $P38
.annotate "line", 271
    .const 'Sub' $P66 = "15_1261457050.23577" 
    capture_lex $P66
    .lex "reduce", $P66
.annotate "line", 299
    .const 'Sub' $P141 = "19_1261457050.23577" 
    capture_lex $P141
    .lex "_reduce", $P141
.annotate "line", 327
    .const 'Sub' $P166 = "21_1261457050.23577" 
    capture_lex $P166
    .lex "hash", $P166
.annotate "line", 340
    .const 'Sub' $P173 = "22_1261457050.23577" 
    capture_lex $P173
    .lex "set_from_array", $P173
.annotate "line", 367
    .const 'Sub' $P195 = "24_1261457050.23577" 
    capture_lex $P195
    .lex "all_matches", $P195
.annotate "line", 394
    .const 'Sub' $P222 = "25_1261457050.23577" 
    capture_lex $P222
    .lex "subst", $P222
.annotate "line", 443
    .const 'Sub' $P283 = "27_1261457050.23577" 
    capture_lex $P283
    .lex "print", $P283
.annotate "line", 458
    .const 'Sub' $P299 = "29_1261457050.23577" 
    capture_lex $P299
    .lex "say", $P299
.annotate "line", 471
    .const 'Sub' $P306 = "30_1261457050.23577" 
    capture_lex $P306
    .lex "slurp", $P306
.annotate "line", 488
    .const 'Sub' $P321 = "31_1261457050.23577" 
    capture_lex $P321
    .lex "spew", $P321
.annotate "line", 503
    .const 'Sub' $P334 = "32_1261457050.23577" 
    capture_lex $P334
    .lex "append", $P334
.annotate "line", 531
    .const 'Sub' $P347 = "33_1261457050.23577" 
    capture_lex $P347
    .lex "fscat", $P347
.annotate "line", 551
    .const 'Sub' $P377 = "34_1261457050.23577" 
    capture_lex $P377
    .lex "user_home_dir", $P377
.annotate "line", 566
    .const 'Sub' $P394 = "35_1261457050.23577" 
    capture_lex $P394
    .lex "path_exists", $P394
.annotate "line", 585
    .const 'Sub' $P419 = "37_1261457050.23577" 
    capture_lex $P419
    .lex "is_dir", $P419
.annotate "line", 612
    .const 'Sub' $P447 = "39_1261457050.23577" 
    capture_lex $P447
    .lex "test_dir_writable", $P447
.annotate "line", 651
    .const 'Sub' $P485 = "41_1261457050.23577" 
    capture_lex $P485
    .lex "find_program", $P485
.annotate "line", 681
    .const 'Sub' $P552 = "44_1261457050.23577" 
    capture_lex $P552
    .lex "mkpath", $P552
.annotate "line", 716
    .const 'Sub' $P586 = "46_1261457050.23577" 
    capture_lex $P586
    .lex "run", $P586
.annotate "line", 734
    .const 'Sub' $P596 = "47_1261457050.23577" 
    capture_lex $P596
    .lex "do_run", $P596
.annotate "line", 758
    .const 'Sub' $P623 = "49_1261457050.23577" 
    capture_lex $P623
    .lex "qx", $P623
.annotate "line", 792
    .const 'Sub' $P651 = "50_1261457050.23577" 
    capture_lex $P651
    .lex "eval", $P651
.annotate "line", 822
    .const 'Sub' $P672 = "51_1261457050.23577" 
    capture_lex $P672
    .lex "store_dynlex_safely", $P672
.annotate "line", 944
    .const 'Sub' $P687 = "52_1261457050.23577" 
    capture_lex $P687
    .lex "replace_config_strings", $P687
.annotate "line", 956
    .const 'Sub' $P714 = "54_1261457050.23577" 
    capture_lex $P714
    .lex "config_value", $P714
.annotate "line", 84
    get_hll_global $P748, ["Hash"], "_block747" 
    capture_lex $P748
    $P748()
.annotate "line", 172
    get_hll_global $P823, ["Array"], "_block822" 
    capture_lex $P823
    $P823()
    find_lex $P844, "map"
    find_lex $P845, "grep"
    find_lex $P846, "reduce"
    find_lex $P847, "_reduce"
    find_lex $P848, "hash"
    find_lex $P849, "set_from_array"
    find_lex $P850, "all_matches"
    find_lex $P851, "subst"
    find_lex $P852, "print"
    find_lex $P853, "say"
    find_lex $P854, "slurp"
    find_lex $P855, "spew"
    find_lex $P856, "append"
    find_lex $P857, "fscat"
    find_lex $P858, "user_home_dir"
    find_lex $P859, "path_exists"
    find_lex $P860, "is_dir"
    find_lex $P861, "test_dir_writable"
    find_lex $P862, "find_program"
    find_lex $P863, "mkpath"
    find_lex $P864, "run"
    find_lex $P865, "do_run"
    find_lex $P866, "qx"
    find_lex $P867, "eval"
    find_lex $P868, "store_dynlex_safely"
.annotate "line", 876
    find_lex $P869, "replace_config_strings"
    find_lex $P870, "config_value"
.annotate "line", 1
    .return ($P870)
.end


.namespace []
.sub "" :load :init :subid("post67") :outer("10_1261457050.23577")
.annotate "line", 0
    .const 'Sub' $P12 = "10_1261457050.23577" 
    .local pmc block
    set block, $P12
.annotate "line", 876
    .const 'Sub' $P872 = "66_1261457050.23577" 
    capture_lex $P872
    $P872()
.end


.namespace []
.sub "_block871"  :anon :subid("66_1261457050.23577") :outer("10_1261457050.23577")
.annotate "line", 881
    new $P873, "Undef"
    .lex "$interp", $P873
.annotate "line", 882
    new $P874, "ResizablePMCArray"
    .lex "@argv", $P874
.annotate "line", 883
    new $P875, "Undef"
    .lex "$config", $P875
.annotate "line", 886
    new $P876, "Hash"
    .lex "%vm", $P876
.annotate "line", 878
    load_bytecode "config.pbc"
.annotate "line", 879
    load_bytecode "P6Regex.pbc"
.annotate "line", 881
    getinterp $P877
    store_lex "$interp", $P877
.annotate "line", 882
    find_lex $P878, "$interp"
    unless_null $P878, vivify_68
    new $P878, "ResizablePMCArray"
  vivify_68:
    set $P879, $P878[2]
    unless_null $P879, vivify_69
    new $P879, "Undef"
  vivify_69:
    store_lex "@argv", $P879
.annotate "line", 883
    find_lex $P880, "$interp"
    unless_null $P880, vivify_70
    new $P880, "ResizablePMCArray"
  vivify_70:
    set $P881, $P880[6]
    unless_null $P881, vivify_71
    new $P881, "Undef"
  vivify_71:
    store_lex "$config", $P881
    find_lex $P882, "%vm"
.annotate "line", 887
    find_lex $P883, "$config"
    find_lex $P884, "%vm"
    unless_null $P884, vivify_72
    new $P884, "Hash"
    store_lex "%vm", $P884
  vivify_72:
    set $P884["config"], $P883
.annotate "line", 888
    find_lex $P885, "%vm"
    "store_dynlex_safely"("%*VM", $P885)
.annotate "line", 891
    find_lex $P887, "@argv"
    if $P887, unless_886_end
    find_lex $P888, "@argv"
    $P888."unshift"("<anonymous>")
  unless_886_end:
.annotate "line", 892
    find_lex $P889, "@argv"
    $P890 = $P889."shift"()
    "store_dynlex_safely"("$*PROGRAM_NAME", $P890)
.annotate "line", 893
    find_lex $P891, "@argv"
    "store_dynlex_safely"("@*ARGS", $P891)
.annotate "line", 896
    interpinfo $S892, 19
    "store_dynlex_safely"("$*EXECUTABLE_NAME", $S892)
.annotate "line", 899
    sysinfo $S893, 4
    "store_dynlex_safely"("$*OSNAME", $S893)
.annotate "line", 900
    sysinfo $S894, 5
    "store_dynlex_safely"("%*OSVER", $S894)
.annotate "line", 903
    new $P895, "ResizablePMCArray"
    push $P895, "parrot"
    push $P895, "Env"
    root_new $P896, $P895
    "store_dynlex_safely"("%*ENV", $P896)
.annotate "line", 904
    new $P897, "ResizablePMCArray"
    push $P897, "parrot"
    push $P897, "OS"
    root_new $P898, $P897
    $P899 = "store_dynlex_safely"("$*OS", $P898)
.annotate "line", 876
    .return ($P899)
.end


.namespace []
.sub "map"  :subid("11_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_16
    .param pmc param_17
.annotate "line", 219
    .const 'Sub' $P25 = "12_1261457050.23577" 
    capture_lex $P25
    new $P15, 'ExceptionHandler'
    set_addr $P15, control_14
    $P15."handle_types"(58)
    push_eh $P15
    .lex "&code", param_16
    .lex "@originals", param_17
.annotate "line", 220
    new $P18, "ResizablePMCArray"
    .lex "@mapped", $P18
.annotate "line", 219
    find_lex $P19, "@mapped"
.annotate "line", 222
    find_lex $P21, "@originals"
    defined $I22, $P21
    unless $I22, for_undef_73
    iter $P20, $P21
    new $P33, 'ExceptionHandler'
    set_addr $P33, loop32_handler
    $P33."handle_types"(65, 67, 66)
    push_eh $P33
  loop32_test:
    unless $P20, loop32_done
    shift $P23, $P20
  loop32_redo:
    .const 'Sub' $P25 = "12_1261457050.23577" 
    capture_lex $P25
    $P25($P23)
  loop32_next:
    goto loop32_test
  loop32_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P34, exception, 'type'
    eq $P34, 65, loop32_next
    eq $P34, 67, loop32_redo
  loop32_done:
    pop_eh 
  for_undef_73:
.annotate "line", 226
    new $P35, "Exception"
    set $P35['type'], 58
    find_lex $P36, "@mapped"
    setattribute $P35, 'payload', $P36
    throw $P35
.annotate "line", 219
    .return ()
  control_14:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P37, exception, "payload"
    .return ($P37)
.end


.namespace []
.sub "_block24"  :anon :subid("12_1261457050.23577") :outer("11_1261457050.23577")
    .param pmc param_26
.annotate "line", 222
    .lex "$_", param_26
.annotate "line", 223
    find_lex $P27, "@mapped"
    find_lex $P28, "&code"
    find_lex $P29, "$_"
    $P30 = $P28($P29)
    $P31 = $P27."push"($P30)
.annotate "line", 222
    .return ($P31)
.end


.namespace []
.sub "grep"  :subid("13_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_41
    .param pmc param_42
.annotate "line", 239
    .const 'Sub' $P50 = "14_1261457050.23577" 
    capture_lex $P50
    new $P40, 'ExceptionHandler'
    set_addr $P40, control_39
    $P40."handle_types"(58)
    push_eh $P40
    .lex "&code", param_41
    .lex "@all", param_42
.annotate "line", 240
    new $P43, "ResizablePMCArray"
    .lex "@matches", $P43
.annotate "line", 239
    find_lex $P44, "@matches"
.annotate "line", 242
    find_lex $P46, "@all"
    defined $I47, $P46
    unless $I47, for_undef_74
    iter $P45, $P46
    new $P61, 'ExceptionHandler'
    set_addr $P61, loop60_handler
    $P61."handle_types"(65, 67, 66)
    push_eh $P61
  loop60_test:
    unless $P45, loop60_done
    shift $P48, $P45
  loop60_redo:
    .const 'Sub' $P50 = "14_1261457050.23577" 
    capture_lex $P50
    $P50($P48)
  loop60_next:
    goto loop60_test
  loop60_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P62, exception, 'type'
    eq $P62, 65, loop60_next
    eq $P62, 67, loop60_redo
  loop60_done:
    pop_eh 
  for_undef_74:
.annotate "line", 246
    new $P63, "Exception"
    set $P63['type'], 58
    find_lex $P64, "@matches"
    setattribute $P63, 'payload', $P64
    throw $P63
.annotate "line", 239
    .return ()
  control_39:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P65, exception, "payload"
    .return ($P65)
.end


.namespace []
.sub "_block49"  :anon :subid("14_1261457050.23577") :outer("13_1261457050.23577")
    .param pmc param_51
.annotate "line", 242
    .lex "$_", param_51
.annotate "line", 243
    find_lex $P54, "&code"
    find_lex $P55, "$_"
    $P56 = $P54($P55)
    if $P56, if_53
    set $P52, $P56
    goto if_53_end
  if_53:
    find_lex $P57, "@matches"
    find_lex $P58, "$_"
    $P59 = $P57."push"($P58)
    set $P52, $P59
  if_53_end:
.annotate "line", 242
    .return ($P52)
.end


.namespace []
.sub "reduce"  :subid("15_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_69
    .param pmc param_70
    .param pmc param_71 :slurpy
.annotate "line", 271
    .const 'Sub' $P93 = "16_1261457050.23577" 
    capture_lex $P93
    new $P68, 'ExceptionHandler'
    set_addr $P68, control_67
    $P68."handle_types"(58)
    push_eh $P68
    .lex "&code", param_69
    .lex "@array", param_70
    .lex "@initial", param_71
.annotate "line", 272
    new $P72, "Undef"
    .lex "$init_elems", $P72
    find_lex $P73, "@initial"
    elements $I74, $P73
    new $P75, 'Integer'
    set $P75, $I74
    store_lex "$init_elems", $P75
.annotate "line", 273
    find_lex $P78, "$init_elems"
    set $N79, $P78
    isgt $I80, $N79, 1.0
    if $I80, if_77
.annotate "line", 276
    find_lex $P83, "$init_elems"
    set $N84, $P83
    iseq $I85, $N84, 1.0
    if $I85, if_82
.annotate "line", 279
    .const 'Sub' $P93 = "16_1261457050.23577" 
    capture_lex $P93
    $P139 = $P93()
    set $P81, $P139
.annotate "line", 276
    goto if_82_end
  if_82:
.annotate "line", 277
    new $P86, "Exception"
    set $P86['type'], 58
    find_lex $P87, "&code"
    find_lex $P88, "@array"
    find_lex $P89, "@initial"
    unless_null $P89, vivify_81
    new $P89, "ResizablePMCArray"
  vivify_81:
    set $P90, $P89[0]
    unless_null $P90, vivify_82
    new $P90, "Undef"
  vivify_82:
    $P91 = "_reduce"($P87, $P88, $P90)
    setattribute $P86, 'payload', $P91
    throw $P86
  if_82_end:
.annotate "line", 276
    set $P76, $P81
.annotate "line", 273
    goto if_77_end
  if_77:
.annotate "line", 274
    die "Only one initial value allowed in reduce()"
  if_77_end:
.annotate "line", 271
    .return ($P76)
  control_67:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P140, exception, "payload"
    .return ($P140)
.end


.namespace []
.sub "_block92"  :anon :subid("16_1261457050.23577") :outer("15_1261457050.23577")
.annotate "line", 279
    .const 'Sub' $P118 = "18_1261457050.23577" 
    capture_lex $P118
    .const 'Sub' $P104 = "17_1261457050.23577" 
    capture_lex $P104
.annotate "line", 280
    new $P94, "Undef"
    .lex "$array_elems", $P94
    find_lex $P95, "@array"
    elements $I96, $P95
    new $P97, 'Integer'
    set $P97, $I96
    store_lex "$array_elems", $P97
.annotate "line", 281
    find_lex $P100, "$array_elems"
    set $N101, $P100
    iseq $I102, $N101, 0.0
    if $I102, if_99
.annotate "line", 284
    find_lex $P111, "$array_elems"
    set $N112, $P111
    iseq $I113, $N112, 1.0
    if $I113, if_110
.annotate "line", 287
    .const 'Sub' $P118 = "18_1261457050.23577" 
    capture_lex $P118
    $P138 = $P118()
    set $P109, $P138
.annotate "line", 284
    goto if_110_end
  if_110:
.annotate "line", 285
    new $P114, "Exception"
    set $P114['type'], 58
    find_lex $P115, "@array"
    unless_null $P115, vivify_79
    new $P115, "ResizablePMCArray"
  vivify_79:
    set $P116, $P115[0]
    unless_null $P116, vivify_80
    new $P116, "Undef"
  vivify_80:
    setattribute $P114, 'payload', $P116
    throw $P114
  if_110_end:
.annotate "line", 284
    set $P98, $P109
.annotate "line", 281
    goto if_99_end
  if_99:
    .const 'Sub' $P104 = "17_1261457050.23577" 
    capture_lex $P104
    $P108 = $P104()
    set $P98, $P108
  if_99_end:
.annotate "line", 279
    .return ($P98)
.end


.namespace []
.sub "_block117"  :anon :subid("18_1261457050.23577") :outer("16_1261457050.23577")
.annotate "line", 288
    new $P119, "Undef"
    .lex "$initial", $P119
.annotate "line", 289
    new $P120, "Undef"
    .lex "$iter", $P120
.annotate "line", 288
    find_lex $P121, "&code"
    find_lex $P122, "@array"
    unless_null $P122, vivify_75
    new $P122, "ResizablePMCArray"
  vivify_75:
    set $P123, $P122[0]
    unless_null $P123, vivify_76
    new $P123, "Undef"
  vivify_76:
    find_lex $P124, "@array"
    unless_null $P124, vivify_77
    new $P124, "ResizablePMCArray"
  vivify_77:
    set $P125, $P124[1]
    unless_null $P125, vivify_78
    new $P125, "Undef"
  vivify_78:
    $P126 = $P121($P123, $P125)
    store_lex "$initial", $P126
.annotate "line", 289
    find_lex $P127, "@array"
    iter $P128, $P127
    store_lex "$iter", $P128
.annotate "line", 291
    find_lex $P129, "$iter"
    shift $P130, $P129
.annotate "line", 292
    find_lex $P131, "$iter"
    shift $P132, $P131
.annotate "line", 294
    new $P133, "Exception"
    set $P133['type'], 58
    find_lex $P134, "&code"
    find_lex $P135, "$iter"
    find_lex $P136, "$initial"
    $P137 = "_reduce"($P134, $P135, $P136)
    setattribute $P133, 'payload', $P137
    throw $P133
.annotate "line", 287
    .return ()
.end


.namespace []
.sub "_block103"  :anon :subid("17_1261457050.23577") :outer("16_1261457050.23577")
.annotate "line", 282
    new $P105, "Undef"
    .lex "$undef", $P105
    new $P106, "Exception"
    set $P106['type'], 58
    find_lex $P107, "$undef"
    setattribute $P106, 'payload', $P107
    throw $P106
.annotate "line", 281
    .return ()
.end


.namespace []
.sub "_reduce"  :subid("19_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_144
    .param pmc param_145
    .param pmc param_146
.annotate "line", 299
    .const 'Sub' $P154 = "20_1261457050.23577" 
    capture_lex $P154
    new $P143, 'ExceptionHandler'
    set_addr $P143, control_142
    $P143."handle_types"(58)
    push_eh $P143
    .lex "&code", param_144
    .lex "$iter", param_145
    .lex "$initial", param_146
.annotate "line", 300
    new $P147, "Undef"
    .lex "$result", $P147
    find_lex $P148, "$initial"
    store_lex "$result", $P148
.annotate "line", 302
    find_lex $P150, "$iter"
    defined $I151, $P150
    unless $I151, for_undef_83
    iter $P149, $P150
    new $P161, 'ExceptionHandler'
    set_addr $P161, loop160_handler
    $P161."handle_types"(65, 67, 66)
    push_eh $P161
  loop160_test:
    unless $P149, loop160_done
    shift $P152, $P149
  loop160_redo:
    .const 'Sub' $P154 = "20_1261457050.23577" 
    capture_lex $P154
    $P154($P152)
  loop160_next:
    goto loop160_test
  loop160_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P162, exception, 'type'
    eq $P162, 65, loop160_next
    eq $P162, 67, loop160_redo
  loop160_done:
    pop_eh 
  for_undef_83:
.annotate "line", 306
    new $P163, "Exception"
    set $P163['type'], 58
    find_lex $P164, "$result"
    setattribute $P163, 'payload', $P164
    throw $P163
.annotate "line", 299
    .return ()
  control_142:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P165, exception, "payload"
    .return ($P165)
.end


.namespace []
.sub "_block153"  :anon :subid("20_1261457050.23577") :outer("19_1261457050.23577")
    .param pmc param_155
.annotate "line", 302
    .lex "$_", param_155
.annotate "line", 303
    find_lex $P156, "&code"
    find_lex $P157, "$result"
    find_lex $P158, "$_"
    $P159 = $P156($P157, $P158)
    store_lex "$result", $P159
.annotate "line", 302
    .return ($P159)
.end


.namespace []
.sub "hash"  :subid("21_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_169 :slurpy :named
.annotate "line", 327
    new $P168, 'ExceptionHandler'
    set_addr $P168, control_167
    $P168."handle_types"(58)
    push_eh $P168
    .lex "%h", param_169
    new $P170, "Exception"
    set $P170['type'], 58
    find_lex $P171, "%h"
    setattribute $P170, 'payload', $P171
    throw $P170
    .return ()
  control_167:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P172, exception, "payload"
    .return ($P172)
.end


.namespace []
.sub "set_from_array"  :subid("22_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_176
.annotate "line", 340
    .const 'Sub' $P184 = "23_1261457050.23577" 
    capture_lex $P184
    new $P175, 'ExceptionHandler'
    set_addr $P175, control_174
    $P175."handle_types"(58)
    push_eh $P175
    .lex "@array", param_176
.annotate "line", 341
    new $P177, "Hash"
    .lex "%set", $P177
.annotate "line", 340
    find_lex $P178, "%set"
.annotate "line", 343
    find_lex $P180, "@array"
    defined $I181, $P180
    unless $I181, for_undef_84
    iter $P179, $P180
    new $P190, 'ExceptionHandler'
    set_addr $P190, loop189_handler
    $P190."handle_types"(65, 67, 66)
    push_eh $P190
  loop189_test:
    unless $P179, loop189_done
    shift $P182, $P179
  loop189_redo:
    .const 'Sub' $P184 = "23_1261457050.23577" 
    capture_lex $P184
    $P184($P182)
  loop189_next:
    goto loop189_test
  loop189_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P191, exception, 'type'
    eq $P191, 65, loop189_next
    eq $P191, 67, loop189_redo
  loop189_done:
    pop_eh 
  for_undef_84:
.annotate "line", 347
    new $P192, "Exception"
    set $P192['type'], 58
    find_lex $P193, "%set"
    setattribute $P192, 'payload', $P193
    throw $P192
.annotate "line", 340
    .return ()
  control_174:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P194, exception, "payload"
    .return ($P194)
.end


.namespace []
.sub "_block183"  :anon :subid("23_1261457050.23577") :outer("22_1261457050.23577")
    .param pmc param_185
.annotate "line", 343
    .lex "$_", param_185
.annotate "line", 344
    new $P186, "Integer"
    assign $P186, 1
    find_lex $P187, "$_"
    find_lex $P188, "%set"
    unless_null $P188, vivify_85
    new $P188, "Hash"
    store_lex "%set", $P188
  vivify_85:
    set $P188[$P187], $P186
.annotate "line", 343
    .return ($P186)
.end


.namespace []
.sub "all_matches"  :subid("24_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_198
    .param pmc param_199
.annotate "line", 367
    new $P197, 'ExceptionHandler'
    set_addr $P197, control_196
    $P197."handle_types"(58)
    push_eh $P197
    .lex "$regex", param_198
    .lex "$text", param_199
.annotate "line", 368
    new $P200, "ResizablePMCArray"
    .lex "@matches", $P200
.annotate "line", 370
    new $P201, "Undef"
    .lex "$match", $P201
.annotate "line", 367
    find_lex $P202, "@matches"
.annotate "line", 370
    find_lex $P203, "$regex"
    find_lex $P204, "$text"
    $P205 = $P203."ACCEPTS"($P204)
    store_lex "$match", $P205
.annotate "line", 371
    new $P217, 'ExceptionHandler'
    set_addr $P217, loop216_handler
    $P217."handle_types"(65, 67, 66)
    push_eh $P217
  loop216_test:
    find_lex $P206, "$match"
    unless $P206, loop216_done
  loop216_redo:
.annotate "line", 372
    find_lex $P207, "@matches"
    find_lex $P208, "$match"
    $P207."push"($P208)
.annotate "line", 373
    find_lex $P209, "$match"
    $P210 = $P209."CURSOR"()
    find_lex $P211, "$text"
    find_lex $P212, "$regex"
    find_lex $P213, "$match"
    $P214 = $P213."to"()
    $P215 = $P210."parse"($P211, $P212 :named("rule"), $P214 :named("c"))
    store_lex "$match", $P215
  loop216_next:
.annotate "line", 371
    goto loop216_test
  loop216_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P218, exception, 'type'
    eq $P218, 65, loop216_next
    eq $P218, 67, loop216_redo
  loop216_done:
    pop_eh 
.annotate "line", 376
    new $P219, "Exception"
    set $P219['type'], 58
    find_lex $P220, "@matches"
    setattribute $P219, 'payload', $P220
    throw $P219
.annotate "line", 367
    .return ()
  control_196:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P221, exception, "payload"
    .return ($P221)
.end


.namespace []
.sub "subst"  :subid("25_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_225
    .param pmc param_226
    .param pmc param_227
.annotate "line", 394
    .const 'Sub' $P246 = "26_1261457050.23577" 
    capture_lex $P246
    new $P224, 'ExceptionHandler'
    set_addr $P224, control_223
    $P224."handle_types"(58)
    push_eh $P224
    .lex "$original", param_225
    .lex "$regex", param_226
    .lex "$replacement", param_227
.annotate "line", 395
    new $P228, "ResizablePMCArray"
    .lex "@matches", $P228
.annotate "line", 396
    new $P229, "Undef"
    .lex "$edited", $P229
.annotate "line", 397
    new $P230, "Undef"
    .lex "$is_sub", $P230
.annotate "line", 398
    new $P231, "Undef"
    .lex "$offset", $P231
.annotate "line", 395
    find_lex $P232, "$regex"
    find_lex $P233, "$original"
    $P234 = "all_matches"($P232, $P233)
    store_lex "@matches", $P234
.annotate "line", 396
    find_lex $P235, "$original"
    clone $P236, $P235
    store_lex "$edited", $P236
.annotate "line", 397
    find_lex $P237, "$replacement"
    isa $I238, $P237, "Sub"
    new $P239, 'Integer'
    set $P239, $I238
    store_lex "$is_sub", $P239
.annotate "line", 398
    new $P240, "Integer"
    assign $P240, 0
    store_lex "$offset", $P240
.annotate "line", 400
    find_lex $P242, "@matches"
    defined $I243, $P242
    unless $I243, for_undef_86
    iter $P241, $P242
    new $P278, 'ExceptionHandler'
    set_addr $P278, loop277_handler
    $P278."handle_types"(65, 67, 66)
    push_eh $P278
  loop277_test:
    unless $P241, loop277_done
    shift $P244, $P241
  loop277_redo:
    .const 'Sub' $P246 = "26_1261457050.23577" 
    capture_lex $P246
    $P246($P244)
  loop277_next:
    goto loop277_test
  loop277_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P279, exception, 'type'
    eq $P279, 65, loop277_next
    eq $P279, 67, loop277_redo
  loop277_done:
    pop_eh 
  for_undef_86:
.annotate "line", 422
    new $P280, "Exception"
    set $P280['type'], 58
    find_lex $P281, "$edited"
    setattribute $P280, 'payload', $P281
    throw $P280
.annotate "line", 394
    .return ()
  control_223:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P282, exception, "payload"
    .return ($P282)
.end


.namespace []
.sub "_block245"  :anon :subid("26_1261457050.23577") :outer("25_1261457050.23577")
    .param pmc param_247
.annotate "line", 400
    .lex "$match", param_247
.annotate "line", 401
    new $P248, "Undef"
    .lex "$replace_string", $P248
.annotate "line", 402
    new $P249, "Undef"
    .lex "$replace_len", $P249
.annotate "line", 403
    new $P250, "Undef"
    .lex "$match_len", $P250
.annotate "line", 404
    new $P251, "Undef"
    .lex "$real_from", $P251
.annotate "line", 401
    find_lex $P254, "$is_sub"
    if $P254, if_253
    find_lex $P258, "$replacement"
    set $P252, $P258
    goto if_253_end
  if_253:
    find_lex $P255, "$replacement"
    find_lex $P256, "$match"
    $P257 = $P255($P256)
    set $P252, $P257
  if_253_end:
    store_lex "$replace_string", $P252
.annotate "line", 402
    find_lex $P259, "$replace_string"
    set $S260, $P259
    length $I261, $S260
    new $P262, 'Integer'
    set $P262, $I261
    store_lex "$replace_len", $P262
.annotate "line", 403
    find_lex $P263, "$match"
    $P264 = $P263."to"()
    find_lex $P265, "$match"
    $N266 = $P265."from"()
    sub $P267, $P264, $N266
    store_lex "$match_len", $P267
.annotate "line", 404
    find_lex $P268, "$match"
    $P269 = $P268."from"()
    find_lex $P270, "$offset"
    add $P271, $P269, $P270
    store_lex "$real_from", $P271
.annotate "line", 406

             $P0 = find_lex '$edited'
	     $S0 = $P0
	     $P1 = find_lex '$real_from'
	     $I0 = $P1
	     $P2 = find_lex '$match_len'
	     $I1 = $P2
	     $P3 = find_lex '$replace_string'
	     $S1 = $P3
	     substr $S0, $I0, $I1, $S1
	     $P0 = $S0
	
.annotate "line", 419
    find_lex $P272, "$offset"
    find_lex $P273, "$match_len"
    sub $P274, $P272, $P273
    find_lex $P275, "$replace_len"
    add $P276, $P274, $P275
    store_lex "$offset", $P276
.annotate "line", 400
    .return ($P276)
.end


.namespace []
.sub "print"  :subid("27_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_286 :slurpy
.annotate "line", 443
    .const 'Sub' $P292 = "28_1261457050.23577" 
    capture_lex $P292
    new $P285, 'ExceptionHandler'
    set_addr $P285, control_284
    $P285."handle_types"(58)
    push_eh $P285
    .lex "@strings", param_286
.annotate "line", 444
    find_lex $P288, "@strings"
    defined $I289, $P288
    unless $I289, for_undef_87
    iter $P287, $P288
    new $P296, 'ExceptionHandler'
    set_addr $P296, loop295_handler
    $P296."handle_types"(65, 67, 66)
    push_eh $P296
  loop295_test:
    unless $P287, loop295_done
    shift $P290, $P287
  loop295_redo:
    .const 'Sub' $P292 = "28_1261457050.23577" 
    capture_lex $P292
    $P292($P290)
  loop295_next:
    goto loop295_test
  loop295_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P297, exception, 'type'
    eq $P297, 65, loop295_next
    eq $P297, 67, loop295_redo
  loop295_done:
    pop_eh 
  for_undef_87:
.annotate "line", 443
    .return ($P287)
  control_284:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P298, exception, "payload"
    .return ($P298)
.end


.namespace []
.sub "_block291"  :anon :subid("28_1261457050.23577") :outer("27_1261457050.23577")
    .param pmc param_293
.annotate "line", 444
    .lex "$_", param_293
.annotate "line", 445
    find_lex $P294, "$_"
    print $P294
.annotate "line", 444
    .return ()
.end


.namespace []
.sub "say"  :subid("29_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_302 :slurpy
.annotate "line", 458
    new $P301, 'ExceptionHandler'
    set_addr $P301, control_300
    $P301."handle_types"(58)
    push_eh $P301
    .lex "@strings", param_302
.annotate "line", 459
    find_lex $P303, "@strings"
    $P304 = "print"($P303 :flat, "\n")
.annotate "line", 458
    .return ($P304)
  control_300:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P305, exception, "payload"
    .return ($P305)
.end


.namespace []
.sub "slurp"  :subid("30_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_309
.annotate "line", 471
    new $P308, 'ExceptionHandler'
    set_addr $P308, control_307
    $P308."handle_types"(58)
    push_eh $P308
    .lex "$filename", param_309
.annotate "line", 472
    new $P310, "Undef"
    .lex "$fh", $P310
.annotate "line", 473
    new $P311, "Undef"
    .lex "$contents", $P311
.annotate "line", 472
    find_lex $P312, "$filename"
    set $S313, $P312
    open $P314, $S313, "r"
    store_lex "$fh", $P314
.annotate "line", 473
    find_lex $P315, "$fh"
    $P316 = $P315."readall"()
    store_lex "$contents", $P316
.annotate "line", 474
    find_lex $P317, "$fh"
    close $P317
.annotate "line", 476
    new $P318, "Exception"
    set $P318['type'], 58
    find_lex $P319, "$contents"
    setattribute $P318, 'payload', $P319
    throw $P318
.annotate "line", 471
    .return ()
  control_307:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P320, exception, "payload"
    .return ($P320)
.end


.namespace []
.sub "spew"  :subid("31_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_324
    .param pmc param_325
.annotate "line", 488
    new $P323, 'ExceptionHandler'
    set_addr $P323, control_322
    $P323."handle_types"(58)
    push_eh $P323
    .lex "$filename", param_324
    .lex "$contents", param_325
.annotate "line", 489
    new $P326, "Undef"
    .lex "$fh", $P326
    find_lex $P327, "$filename"
    set $S328, $P327
    open $P329, $S328, "w"
    store_lex "$fh", $P329
.annotate "line", 490
    find_lex $P330, "$fh"
    find_lex $P331, "$contents"
    $P330."print"($P331)
.annotate "line", 491
    find_lex $P332, "$fh"
    close $P332
.annotate "line", 488
    .return ()
  control_322:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P333, exception, "payload"
    .return ($P333)
.end


.namespace []
.sub "append"  :subid("32_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_337
    .param pmc param_338
.annotate "line", 503
    new $P336, 'ExceptionHandler'
    set_addr $P336, control_335
    $P336."handle_types"(58)
    push_eh $P336
    .lex "$filename", param_337
    .lex "$contents", param_338
.annotate "line", 504
    new $P339, "Undef"
    .lex "$fh", $P339
    find_lex $P340, "$filename"
    set $S341, $P340
    open $P342, $S341, "a"
    store_lex "$fh", $P342
.annotate "line", 505
    find_lex $P343, "$fh"
    find_lex $P344, "$contents"
    $P343."print"($P344)
.annotate "line", 506
    find_lex $P345, "$fh"
    close $P345
.annotate "line", 503
    .return ()
  control_335:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P346, exception, "payload"
    .return ($P346)
.end


.namespace []
.sub "fscat"  :subid("33_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_350
    .param pmc param_351 :slurpy
.annotate "line", 531
    new $P349, 'ExceptionHandler'
    set_addr $P349, control_348
    $P349."handle_types"(58)
    push_eh $P349
    .lex "@path_parts", param_350
    .lex "@filename", param_351
.annotate "line", 535
    new $P352, "Undef"
    .lex "$sep", $P352
.annotate "line", 536
    new $P353, "Undef"
    .lex "$joined", $P353
.annotate "line", 533
    find_lex $P355, "@filename"
    set $N356, $P355
    isgt $I357, $N356, 1.0
    unless $I357, if_354_end
.annotate "line", 532
    die "Only one filename allowed in fscat()"
  if_354_end:
.annotate "line", 535
    getinterp $P358
    set $P359, $P358[6]
    unless_null $P359, vivify_88
    new $P359, "Hash"
  vivify_88:
    set $P360, $P359["slash"]
    unless_null $P360, vivify_89
    new $P360, "Undef"
  vivify_89:
    store_lex "$sep", $P360
.annotate "line", 536
    find_lex $P361, "$sep"
    set $S362, $P361
    find_lex $P363, "@path_parts"
    join $S364, $S362, $P363
    new $P365, 'String'
    set $P365, $S364
    store_lex "$joined", $P365
.annotate "line", 537
    find_lex $P367, "@filename"
    unless $P367, if_366_end
    find_lex $P368, "$joined"
    find_lex $P369, "$sep"
    concat $P370, $P368, $P369
    find_lex $P371, "@filename"
    unless_null $P371, vivify_90
    new $P371, "ResizablePMCArray"
  vivify_90:
    set $P372, $P371[0]
    unless_null $P372, vivify_91
    new $P372, "Undef"
  vivify_91:
    concat $P373, $P370, $P372
    store_lex "$joined", $P373
  if_366_end:
.annotate "line", 539
    new $P374, "Exception"
    set $P374['type'], 58
    find_lex $P375, "$joined"
    setattribute $P374, 'payload', $P375
    throw $P374
.annotate "line", 531
    .return ()
  control_348:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P376, exception, "payload"
    .return ($P376)
.end


.namespace []
.sub "user_home_dir"  :subid("34_1261457050.23577") :outer("10_1261457050.23577")
.annotate "line", 551
    new $P379, 'ExceptionHandler'
    set_addr $P379, control_378
    $P379."handle_types"(58)
    push_eh $P379
.annotate "line", 552
    new $P380, "Hash"
    .lex "%env", $P380
    new $P381, "ResizablePMCArray"
    push $P381, "parrot"
    push $P381, "Env"
    root_new $P382, $P381
    store_lex "%env", $P382
.annotate "line", 553
    new $P383, "Exception"
    set $P383['type'], 58
    find_lex $P385, "%env"
    unless_null $P385, vivify_92
    new $P385, "Hash"
  vivify_92:
    set $P386, $P385["HOMEDRIVE"]
    unless_null $P386, vivify_93
    new $P386, "Undef"
  vivify_93:
    set $P384, $P386
    defined $I388, $P384
    if $I388, default_387
    new $P389, "String"
    assign $P389, ""
    set $P384, $P389
  default_387:
    find_lex $P390, "%env"
    unless_null $P390, vivify_94
    new $P390, "Hash"
  vivify_94:
    set $P391, $P390["HOME"]
    unless_null $P391, vivify_95
    new $P391, "Undef"
  vivify_95:
    concat $P392, $P384, $P391
    setattribute $P383, 'payload', $P392
    throw $P383
.annotate "line", 551
    .return ()
  control_378:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P393, exception, "payload"
    .return ($P393)
.end


.namespace []
.sub "path_exists"  :subid("35_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_397
.annotate "line", 566
    .const 'Sub' $P411 = "36_1261457050.23577" 
    capture_lex $P411
    new $P396, 'ExceptionHandler'
    set_addr $P396, control_395
    $P396."handle_types"(58)
    push_eh $P396
    new $P407, 'ExceptionHandler'
    set_addr $P407, control_406
    $P407."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P407
    .lex "$path", param_397
.annotate "line", 567
    new $P398, "ResizablePMCArray"
    .lex "@stat", $P398
    new $P399, "ResizablePMCArray"
    push $P399, "parrot"
    push $P399, "OS"
    root_new $P400, $P399
    find_lex $P401, "$path"
    $P402 = $P400."stat"($P401)
    store_lex "@stat", $P402
.annotate "line", 568
    new $P403, "Exception"
    set $P403['type'], 58
    new $P404, "Integer"
    assign $P404, 1
    setattribute $P403, 'payload', $P404
    throw $P403
.annotate "line", 566
    pop_eh 
    goto skip_handler_405
  control_406:
.annotate "line", 570
    .local pmc exception 
    .get_results (exception) 
    .const 'Sub' $P411 = "36_1261457050.23577" 
    capture_lex $P411
    $P411(exception)
    new $P416, 'Integer'
    set $P416, 1
    set exception["handled"], $P416
    set $I417, exception["handled"]
    ne $I417, 1, nothandled_409
  handled_408:
    .return (exception)
  nothandled_409:
    rethrow exception
  skip_handler_405:
.annotate "line", 566
    .return ()
  control_395:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P418, exception, "payload"
    .return ($P418)
.end


.namespace []
.sub "_block410"  :anon :subid("36_1261457050.23577") :outer("35_1261457050.23577")
    .param pmc param_412
.annotate "line", 570
    .lex "$_", param_412
    find_lex $P413, "$_"
    .lex "$!", $P413
.annotate "line", 571
    new $P414, "Exception"
    set $P414['type'], 58
    new $P415, "Integer"
    assign $P415, 0
    setattribute $P414, 'payload', $P415
    throw $P414
.annotate "line", 570
    .return ()
.end


.namespace []
.sub "is_dir"  :subid("37_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_422
.annotate "line", 585
    .const 'Sub' $P439 = "38_1261457050.23577" 
    capture_lex $P439
    new $P421, 'ExceptionHandler'
    set_addr $P421, control_420
    $P421."handle_types"(58)
    push_eh $P421
    new $P435, 'ExceptionHandler'
    set_addr $P435, control_434
    $P435."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P435
    .lex "$path", param_422
.annotate "line", 586
    new $P423, "ResizablePMCArray"
    .lex "@stat", $P423
    new $P424, "ResizablePMCArray"
    push $P424, "parrot"
    push $P424, "OS"
    root_new $P425, $P424
    find_lex $P426, "$path"
    $P427 = $P425."stat"($P426)
    store_lex "@stat", $P427
.annotate "line", 587
    new $P428, "Exception"
    set $P428['type'], 58
    find_lex $P429, "$path"
    set $S430, $P429
    stat $I431, $S430, 2
    new $P432, 'Integer'
    set $P432, $I431
    setattribute $P428, 'payload', $P432
    throw $P428
.annotate "line", 585
    pop_eh 
    goto skip_handler_433
  control_434:
.annotate "line", 589
    .local pmc exception 
    .get_results (exception) 
    .const 'Sub' $P439 = "38_1261457050.23577" 
    capture_lex $P439
    $P439(exception)
    new $P444, 'Integer'
    set $P444, 1
    set exception["handled"], $P444
    set $I445, exception["handled"]
    ne $I445, 1, nothandled_437
  handled_436:
    .return (exception)
  nothandled_437:
    rethrow exception
  skip_handler_433:
.annotate "line", 585
    .return ()
  control_420:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P446, exception, "payload"
    .return ($P446)
.end


.namespace []
.sub "_block438"  :anon :subid("38_1261457050.23577") :outer("37_1261457050.23577")
    .param pmc param_440
.annotate "line", 589
    .lex "$_", param_440
    find_lex $P441, "$_"
    .lex "$!", $P441
.annotate "line", 590
    new $P442, "Exception"
    set $P442['type'], 58
    new $P443, "Integer"
    assign $P443, 0
    setattribute $P442, 'payload', $P443
    throw $P442
.annotate "line", 589
    .return ()
.end


.namespace []
.sub "test_dir_writable"  :subid("39_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_450
.annotate "line", 612
    .const 'Sub' $P463 = "40_1261457050.23577" 
    capture_lex $P463
    new $P449, 'ExceptionHandler'
    set_addr $P449, control_448
    $P449."handle_types"(58)
    push_eh $P449
    .lex "$dir", param_450
.annotate "line", 613
    new $P451, "Undef"
    .lex "$test_file", $P451
    find_lex $P452, "$dir"
    new $P453, "ResizablePMCArray"
    push $P453, $P452
    $P454 = "fscat"($P453, "WrItAbLe.UtL")
    store_lex "$test_file", $P454
.annotate "line", 616
    find_lex $P456, "$test_file"
    $P457 = "path_exists"($P456)
    unless $P457, if_455_end
.annotate "line", 615
    new $P458, 'String'
    set $P458, "Test file '"
    find_lex $P459, "$test_file"
    concat $P460, $P458, $P459
    concat $P461, $P460, "'\nthat should never exist already does."
    die $P461
  if_455_end:
.annotate "line", 618
    .const 'Sub' $P463 = "40_1261457050.23577" 
    capture_lex $P463
    $P463()
.annotate "line", 622
    find_lex $P475, "$test_file"
    $P476 = "path_exists"($P475)
    if $P476, if_474
.annotate "line", 627
    new $P482, "Exception"
    set $P482['type'], 58
    new $P483, "Integer"
    assign $P483, 0
    setattribute $P482, 'payload', $P483
    throw $P482
.annotate "line", 626
    goto if_474_end
  if_474:
.annotate "line", 623
    new $P477, "ResizablePMCArray"
    push $P477, "parrot"
    push $P477, "OS"
    root_new $P478, $P477
    find_lex $P479, "$test_file"
    $P478."rm"($P479)
.annotate "line", 624
    new $P480, "Exception"
    set $P480['type'], 58
    new $P481, "Integer"
    assign $P481, 1
    setattribute $P480, 'payload', $P481
    throw $P480
  if_474_end:
.annotate "line", 612
    .return ($P473)
  control_448:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P484, exception, "payload"
    .return ($P484)
.end


.namespace []
.sub "_block462"  :anon :subid("40_1261457050.23577") :outer("39_1261457050.23577")
.annotate "line", 618
    new $P468, 'ExceptionHandler'
    set_addr $P468, control_467
    $P468."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P468
.annotate "line", 619
    find_lex $P464, "$test_file"
    $P465 = "spew"($P464, "test_dir_writable() test file.\n")
.annotate "line", 618
    pop_eh 
    goto skip_handler_466
  control_467:
    .local pmc exception 
    .get_results (exception) 
    new $P471, 'Integer'
    set $P471, 1
    set exception["handled"], $P471
    set $I472, exception["handled"]
    ne $I472, 1, nothandled_470
  handled_469:
    .return (exception)
  nothandled_470:
    rethrow exception
  skip_handler_466:
    .return ($P465)
.end


.namespace []
.sub "find_program"  :subid("41_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_488
.annotate "line", 651
    .const 'Sub' $P519 = "42_1261457050.23577" 
    capture_lex $P519
    new $P487, 'ExceptionHandler'
    set_addr $P487, control_486
    $P487."handle_types"(58)
    push_eh $P487
    .lex "$program", param_488
.annotate "line", 652
    new $P489, "Undef"
    .lex "$path_sep", $P489
.annotate "line", 653
    new $P490, "Hash"
    .lex "%env", $P490
.annotate "line", 654
    new $P491, "ResizablePMCArray"
    .lex "@paths", $P491
.annotate "line", 655
    new $P492, "ResizablePMCArray"
    .lex "@exts", $P492
.annotate "line", 652
    sysinfo $S495, 4
    iseq $I496, $S495, "MSWin32"
    if $I496, if_494
    new $P498, "String"
    assign $P498, ":"
    set $P493, $P498
    goto if_494_end
  if_494:
    new $P497, "String"
    assign $P497, ";"
    set $P493, $P497
  if_494_end:
    store_lex "$path_sep", $P493
.annotate "line", 653
    new $P499, "ResizablePMCArray"
    push $P499, "parrot"
    push $P499, "Env"
    root_new $P500, $P499
    store_lex "%env", $P500
.annotate "line", 654
    find_lex $P501, "$path_sep"
    set $S502, $P501
    find_lex $P503, "%env"
    unless_null $P503, vivify_96
    new $P503, "Hash"
  vivify_96:
    set $P504, $P503["PATH"]
    unless_null $P504, vivify_97
    new $P504, "Undef"
  vivify_97:
    set $S505, $P504
    split $P506, $S502, $S505
    store_lex "@paths", $P506
.annotate "line", 655
    find_lex $P507, "$path_sep"
    set $S508, $P507
    find_lex $P509, "%env"
    unless_null $P509, vivify_98
    new $P509, "Hash"
  vivify_98:
    set $P510, $P509["PATHEXT"]
    unless_null $P510, vivify_99
    new $P510, "Undef"
  vivify_99:
    set $S511, $P510
    split $P512, $S508, $S511
    store_lex "@exts", $P512
.annotate "line", 657
    find_lex $P513, "@exts"
    $P513."unshift"("")
.annotate "line", 659
    find_lex $P515, "@paths"
    defined $I516, $P515
    unless $I516, for_undef_100
    iter $P514, $P515
    new $P547, 'ExceptionHandler'
    set_addr $P547, loop546_handler
    $P547."handle_types"(65, 67, 66)
    push_eh $P547
  loop546_test:
    unless $P514, loop546_done
    shift $P517, $P514
  loop546_redo:
    .const 'Sub' $P519 = "42_1261457050.23577" 
    capture_lex $P519
    $P519($P517)
  loop546_next:
    goto loop546_test
  loop546_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P548, exception, 'type'
    eq $P548, 65, loop546_next
    eq $P548, 67, loop546_redo
  loop546_done:
    pop_eh 
  for_undef_100:
.annotate "line", 668
    new $P549, "Exception"
    set $P549['type'], 58
    new $P550, "String"
    assign $P550, ""
    setattribute $P549, 'payload', $P550
    throw $P549
.annotate "line", 651
    .return ()
  control_486:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P551, exception, "payload"
    .return ($P551)
.end


.namespace []
.sub "_block518"  :anon :subid("42_1261457050.23577") :outer("41_1261457050.23577")
    .param pmc param_520
.annotate "line", 659
    .const 'Sub' $P531 = "43_1261457050.23577" 
    capture_lex $P531
    .lex "$dir", param_520
.annotate "line", 660
    new $P521, "Undef"
    .lex "$path", $P521
    find_lex $P522, "$dir"
    new $P523, "ResizablePMCArray"
    push $P523, $P522
    find_lex $P524, "$program"
    $P525 = "fscat"($P523, $P524)
    store_lex "$path", $P525
.annotate "line", 662
    find_lex $P527, "@exts"
    defined $I528, $P527
    unless $I528, for_undef_101
    iter $P526, $P527
    new $P544, 'ExceptionHandler'
    set_addr $P544, loop543_handler
    $P544."handle_types"(65, 67, 66)
    push_eh $P544
  loop543_test:
    unless $P526, loop543_done
    shift $P529, $P526
  loop543_redo:
    .const 'Sub' $P531 = "43_1261457050.23577" 
    capture_lex $P531
    $P531($P529)
  loop543_next:
    goto loop543_test
  loop543_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P545, exception, 'type'
    eq $P545, 65, loop543_next
    eq $P545, 67, loop543_redo
  loop543_done:
    pop_eh 
  for_undef_101:
.annotate "line", 659
    .return ($P526)
.end


.namespace []
.sub "_block530"  :anon :subid("43_1261457050.23577") :outer("42_1261457050.23577")
    .param pmc param_532
.annotate "line", 662
    .lex "$ext", param_532
.annotate "line", 663
    new $P533, "Undef"
    .lex "$pathext", $P533
    find_lex $P534, "$path"
    find_lex $P535, "$ext"
    concat $P536, $P534, $P535
    store_lex "$pathext", $P536
.annotate "line", 664
    find_lex $P539, "$pathext"
    $P540 = "path_exists"($P539)
    if $P540, if_538
    set $P537, $P540
    goto if_538_end
  if_538:
    new $P541, "Exception"
    set $P541['type'], 58
    find_lex $P542, "$pathext"
    setattribute $P541, 'payload', $P542
    throw $P541
  if_538_end:
.annotate "line", 662
    .return ($P537)
.end


.namespace []
.sub "mkpath"  :subid("44_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_555
.annotate "line", 681
    .const 'Sub' $P568 = "45_1261457050.23577" 
    capture_lex $P568
    new $P554, 'ExceptionHandler'
    set_addr $P554, control_553
    $P554."handle_types"(58)
    push_eh $P554
    .lex "$path", param_555
.annotate "line", 682
    new $P556, "ResizablePMCArray"
    .lex "@path", $P556
.annotate "line", 683
    new $P557, "Undef"
    .lex "$cur", $P557
.annotate "line", 682
    find_lex $P558, "$path"
    set $S559, $P558
    split $P560, "/", $S559
    store_lex "@path", $P560
.annotate "line", 683
    find_lex $P561, "@path"
    $P562 = $P561."shift"()
    store_lex "$cur", $P562
.annotate "line", 685
    find_lex $P564, "@path"
    defined $I565, $P564
    unless $I565, for_undef_102
    iter $P563, $P564
    new $P583, 'ExceptionHandler'
    set_addr $P583, loop582_handler
    $P583."handle_types"(65, 67, 66)
    push_eh $P583
  loop582_test:
    unless $P563, loop582_done
    shift $P566, $P563
  loop582_redo:
    .const 'Sub' $P568 = "45_1261457050.23577" 
    capture_lex $P568
    $P568($P566)
  loop582_next:
    goto loop582_test
  loop582_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P584, exception, 'type'
    eq $P584, 65, loop582_next
    eq $P584, 67, loop582_redo
  loop582_done:
    pop_eh 
  for_undef_102:
.annotate "line", 681
    .return ($P563)
  control_553:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P585, exception, "payload"
    .return ($P585)
.end


.namespace []
.sub "_block567"  :anon :subid("45_1261457050.23577") :outer("44_1261457050.23577")
    .param pmc param_569
.annotate "line", 685
    .lex "$dir", param_569
.annotate "line", 686
    find_lex $P570, "$cur"
    find_lex $P571, "$dir"
    new $P572, "ResizablePMCArray"
    push $P572, $P570
    push $P572, $P571
    $P573 = "fscat"($P572)
    store_lex "$cur", $P573
.annotate "line", 688
    find_lex $P576, "$cur"
    $P577 = "path_exists"($P576)
    unless $P577, unless_575
    set $P574, $P577
    goto unless_575_end
  unless_575:
.annotate "line", 689
    new $P578, "ResizablePMCArray"
    push $P578, "parrot"
    push $P578, "OS"
    root_new $P579, $P578
    find_lex $P580, "$cur"
    $P581 = $P579."mkdir"($P580, 511)
.annotate "line", 688
    set $P574, $P581
  unless_575_end:
.annotate "line", 685
    .return ($P574)
.end


.namespace []
.sub "run"  :subid("46_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_589 :slurpy
.annotate "line", 716
    new $P588, 'ExceptionHandler'
    set_addr $P588, control_587
    $P588."handle_types"(58)
    push_eh $P588
    .lex "@command_and_args", param_589
.annotate "line", 717
    new $P590, "Exception"
    set $P590['type'], 58
    find_lex $P591, "@command_and_args"
    spawnw $I592, $P591
    new $P593, 'Integer'
    set $P593, $I592
    shr $P594, $P593, 8
    setattribute $P590, 'payload', $P594
    throw $P590
.annotate "line", 716
    .return ()
  control_587:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P595, exception, "payload"
    .return ($P595)
.end


.namespace []
.sub "do_run"  :subid("47_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_599 :slurpy
.annotate "line", 734
    .const 'Sub' $P615 = "48_1261457050.23577" 
    capture_lex $P615
    new $P598, 'ExceptionHandler'
    set_addr $P598, control_597
    $P598."handle_types"(58)
    push_eh $P598
    new $P611, 'ExceptionHandler'
    set_addr $P611, control_610
    $P611."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P611
    .lex "@command_and_args", param_599
.annotate "line", 735
    find_lex $P600, "@command_and_args"
    join $S601, " ", $P600
    "say"($S601)
.annotate "line", 737
    new $P602, "Exception"
    set $P602['type'], 58
    find_lex $P605, "@command_and_args"
    spawnw $I606, $P605
    if $I606, if_604
    new $P608, "Integer"
    assign $P608, 1
    set $P603, $P608
    goto if_604_end
  if_604:
    new $P607, "Integer"
    assign $P607, 0
    set $P603, $P607
  if_604_end:
    setattribute $P602, 'payload', $P603
    throw $P602
.annotate "line", 734
    pop_eh 
    goto skip_handler_609
  control_610:
.annotate "line", 739
    .local pmc exception 
    .get_results (exception) 
    .const 'Sub' $P615 = "48_1261457050.23577" 
    capture_lex $P615
    $P615(exception)
    new $P620, 'Integer'
    set $P620, 1
    set exception["handled"], $P620
    set $I621, exception["handled"]
    ne $I621, 1, nothandled_613
  handled_612:
    .return (exception)
  nothandled_613:
    rethrow exception
  skip_handler_609:
.annotate "line", 734
    .return ()
  control_597:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P622, exception, "payload"
    .return ($P622)
.end


.namespace []
.sub "_block614"  :anon :subid("48_1261457050.23577") :outer("47_1261457050.23577")
    .param pmc param_616
.annotate "line", 739
    .lex "$_", param_616
    find_lex $P617, "$_"
    .lex "$!", $P617
.annotate "line", 740
    new $P618, "Exception"
    set $P618['type'], 58
    new $P619, "Integer"
    assign $P619, -1
    setattribute $P618, 'payload', $P619
    throw $P618
.annotate "line", 739
    .return ()
.end


.namespace []
.sub "qx"  :subid("49_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_626 :slurpy
.annotate "line", 758
    new $P625, 'ExceptionHandler'
    set_addr $P625, control_624
    $P625."handle_types"(58)
    push_eh $P625
    .lex "@command_and_args", param_626
.annotate "line", 759
    new $P627, "Undef"
    .lex "$cmd", $P627
.annotate "line", 760
    new $P628, "Undef"
    .lex "$pipe", $P628
.annotate "line", 764
    new $P629, "Undef"
    .lex "$output", $P629
.annotate "line", 759
    find_lex $P630, "@command_and_args"
    join $S631, " ", $P630
    new $P632, 'String'
    set $P632, $S631
    store_lex "$cmd", $P632
.annotate "line", 760
    find_lex $P633, "$cmd"
    set $S634, $P633
    open $P635, $S634, "rp"
    store_lex "$pipe", $P635
.annotate "line", 761
    find_lex $P637, "$pipe"
    if $P637, unless_636_end
    new $P638, 'String'
    set $P638, "Unable to execute '"
    find_lex $P639, "$cmd"
    concat $P640, $P638, $P639
    concat $P641, $P640, "'"
    die $P641
  unless_636_end:
.annotate "line", 763
    find_lex $P642, "$pipe"
    $P642."encoding"("utf8")
.annotate "line", 764
    find_lex $P643, "$pipe"
    $P644 = $P643."readall"()
    store_lex "$output", $P644
.annotate "line", 765
    find_lex $P645, "$pipe"
    $P645."close"()
.annotate "line", 767
    find_lex $P646, "$pipe"
    $P647 = $P646."exit_status"()
    "store_dynlex_safely"("$!", $P647)
.annotate "line", 769
    new $P648, "Exception"
    set $P648['type'], 58
    find_lex $P649, "$output"
    setattribute $P648, 'payload', $P649
    throw $P648
.annotate "line", 758
    .return ()
  control_624:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P650, exception, "payload"
    .return ($P650)
.end


.namespace []
.sub "eval"  :subid("50_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_654
    .param pmc param_655
.annotate "line", 792
    new $P653, 'ExceptionHandler'
    set_addr $P653, control_652
    $P653."handle_types"(58)
    push_eh $P653
    .lex "$source_code", param_654
    .lex "$language", param_655
.annotate "line", 796
    new $P656, "Undef"
    .lex "$compiler", $P656
.annotate "line", 793
    find_lex $P657, "$language"
    set $S658, $P657
    downcase $S659, $S658
    new $P660, 'String'
    set $P660, $S659
    store_lex "$language", $P660
.annotate "line", 795
    find_lex $P661, "$language"
    set $S662, $P661
    load_language $S662
.annotate "line", 796
    find_lex $P663, "$language"
    set $S664, $P663
    compreg $P665, $S664
    store_lex "$compiler", $P665
.annotate "line", 798
    new $P666, "Exception"
    set $P666['type'], 58
    find_lex $P667, "$compiler"
    find_lex $P668, "$source_code"
    $P669 = $P667."compile"($P668)
    $P670 = $P669()
    setattribute $P666, 'payload', $P670
    throw $P666
.annotate "line", 792
    .return ()
  control_652:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P671, exception, "payload"
    .return ($P671)
.end


.namespace []
.sub "store_dynlex_safely"  :subid("51_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_675
    .param pmc param_676
.annotate "line", 822
    new $P674, 'ExceptionHandler'
    set_addr $P674, control_673
    $P674."handle_types"(58)
    push_eh $P674
    .lex "$var_name", param_675
    .lex "$value", param_676
.annotate "line", 824
    find_lex $P679, "$var_name"
    set $S680, $P679
    find_dynamic_lex $P681, $S680
    isnull $I682, $P681
    unless $I682, unless_678
    new $P677, 'Integer'
    set $P677, $I682
    goto unless_678_end
  unless_678:
.annotate "line", 823
    find_lex $P683, "$var_name"
    set $S684, $P683
    find_lex $P685, "$value"
    store_dynamic_lex $S684, $P685
  unless_678_end:
.annotate "line", 822
    .return ($P677)
  control_673:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P686, exception, "payload"
    .return ($P686)
.end


.namespace []
.sub "replace_config_strings"  :subid("52_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_690
.annotate "line", 944
    .const 'Sub' $P702 = "53_1261457050.23577" 
    capture_lex $P702
    new $P689, 'ExceptionHandler'
    set_addr $P689, control_688
    $P689."handle_types"(58)
    push_eh $P689
    .lex "$original", param_690
.annotate "line", 945
    new $P691, "Undef"
    .lex "$new", $P691
    find_lex $P692, "$original"
    store_lex "$new", $P692
.annotate "line", 947
    new $P709, 'ExceptionHandler'
    set_addr $P709, loop708_handler
    $P709."handle_types"(65, 67, 66)
    push_eh $P709
    goto loop708_redo
  loop708_test:
.annotate "line", 951
    find_lex $P693, "$new"
    set $S694, $P693
    find_lex $P695, "$original"
    set $S696, $P695
    isne $I697, $S694, $S696
    unless $I697, loop708_done
  loop708_redo:
.annotate "line", 948
    find_lex $P698, "$new"
    store_lex "$original", $P698
.annotate "line", 949
    find_lex $P699, "$original"
    get_hll_global $P700, ["Regex"], "Regex"
    .const 'Sub' $P702 = "53_1261457050.23577" 
    capture_lex $P702
    $P705 = $P700."new"($P702)
    get_hll_global $P706, "config_value"
    $P707 = "subst"($P699, $P705, $P706)
    store_lex "$new", $P707
  loop708_next:
.annotate "line", 947
    goto loop708_test
  loop708_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P710, exception, 'type'
    eq $P710, 65, loop708_next
    eq $P710, 67, loop708_redo
  loop708_done:
    pop_eh 
.annotate "line", 953
    new $P711, "Exception"
    set $P711['type'], 58
    find_lex $P712, "$new"
    setattribute $P711, 'payload', $P712
    throw $P711
.annotate "line", 944
    .return ()
  control_688:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P713, exception, "payload"
    .return ($P713)
.end


.namespace []
.sub "_block701"  :anon :subid("53_1261457050.23577") :method :outer("52_1261457050.23577")
.annotate "line", 949
    .local string rx703_tgt
    .local int rx703_pos
    .local int rx703_off
    .local int rx703_eos
    .local int rx703_rep
    .local pmc rx703_cur
    (rx703_cur, rx703_pos, rx703_tgt) = self."!cursor_start"()
    rx703_cur."!cursor_debug"("START ", "")
    .lex unicode:"$\x{a2}", rx703_cur
    .local pmc match
    .lex "$/", match
    length rx703_eos, rx703_tgt
    set rx703_off, 0
    lt rx703_pos, 2, rx703_start
    sub rx703_off, rx703_pos, 1
    substr rx703_tgt, rx703_tgt, rx703_off
  rx703_start:
    $I10 = self.'from'()
    ne $I10, -1, rxscan704_done
    goto rxscan704_scan
  rxscan704_loop:
    ($P10) = rx703_cur."from"()
    inc $P10
    set rx703_pos, $P10
    ge rx703_pos, rx703_eos, rxscan704_done
  rxscan704_scan:
    set_addr $I10, rxscan704_loop
    rx703_cur."!mark_push"(0, rx703_pos, $I10)
  rxscan704_done:
  # rx literal  "#"
    add $I11, rx703_pos, 1
    gt $I11, rx703_eos, rx703_fail
    sub $I11, rx703_pos, rx703_off
    substr $S10, rx703_tgt, $I11, 1
    ne $S10, "#", rx703_fail
    add rx703_pos, 1
  # rx subrule "ident" subtype=capture negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."ident"()
    unless $P10, rx703_fail
    rx703_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("ident")
    rx703_pos = $P10."pos"()
  # rx literal  "#"
    add $I11, rx703_pos, 1
    gt $I11, rx703_eos, rx703_fail
    sub $I11, rx703_pos, rx703_off
    substr $S10, rx703_tgt, $I11, 1
    ne $S10, "#", rx703_fail
    add rx703_pos, 1
  # rx pass
    rx703_cur."!cursor_pass"(rx703_pos, "")
    rx703_cur."!cursor_debug"("PASS  ", "", " at pos=", rx703_pos)
    .return (rx703_cur)
  rx703_fail:
    (rx703_rep, rx703_pos, $I10, $P10) = rx703_cur."!mark_fail"(0)
    lt rx703_pos, -1, rx703_done
    eq rx703_pos, -1, rx703_fail
    jump $I10
  rx703_done:
    rx703_cur."!cursor_fail"()
    rx703_cur."!cursor_debug"("FAIL  ", "")
    .return (rx703_cur)
    .return ()
.end


.namespace []
.sub "config_value"  :subid("54_1261457050.23577") :outer("10_1261457050.23577")
    .param pmc param_717
.annotate "line", 956
    new $P716, 'ExceptionHandler'
    set_addr $P716, control_715
    $P716."handle_types"(58)
    push_eh $P716
    .lex "$match", param_717
.annotate "line", 957
    new $P718, "Undef"
    .lex "$key", $P718
.annotate "line", 958
    new $P719, "Undef"
    .lex "$config", $P719
.annotate "line", 957
    find_lex $P720, "$match"
    unless_null $P720, vivify_103
    new $P720, "Hash"
  vivify_103:
    set $P721, $P720["ident"]
    unless_null $P721, vivify_104
    new $P721, "Undef"
  vivify_104:
    store_lex "$key", $P721
.annotate "line", 959
    find_lex $P730, "$key"
    find_dynamic_lex $P731, "%*CONF"
    unless_null $P731, vivify_105
    get_hll_global $P731, "%CONF"
    unless_null $P731, vivify_106
    die "Contextual %*CONF not found"
  vivify_106:
  vivify_105:
    set $P732, $P731[$P730]
    unless_null $P732, vivify_107
    new $P732, "Undef"
  vivify_107:
    unless $P732, unless_729
    set $P728, $P732
    goto unless_729_end
  unless_729:
    find_lex $P733, "$key"
    find_dynamic_lex $P734, "%*VM"
    unless_null $P734, vivify_108
    get_hll_global $P734, "%VM"
    unless_null $P734, vivify_109
    die "Contextual %*VM not found"
  vivify_109:
  vivify_108:
    set $P735, $P734["config"]
    unless_null $P735, vivify_110
    new $P735, "Hash"
  vivify_110:
    set $P736, $P735[$P733]
    unless_null $P736, vivify_111
    new $P736, "Undef"
  vivify_111:
    set $P728, $P736
  unless_729_end:
    unless $P728, unless_727
    set $P726, $P728
    goto unless_727_end
  unless_727:
    find_lex $P737, "$key"
    find_dynamic_lex $P738, "%*BIN"
    unless_null $P738, vivify_112
    get_hll_global $P738, "%BIN"
    unless_null $P738, vivify_113
    die "Contextual %*BIN not found"
  vivify_113:
  vivify_112:
    set $P739, $P738[$P737]
    unless_null $P739, vivify_114
    new $P739, "Undef"
  vivify_114:
    set $P726, $P739
  unless_727_end:
.annotate "line", 960
    unless $P726, unless_725
    set $P724, $P726
    goto unless_725_end
  unless_725:
    find_lex $P740, "$key"
    find_dynamic_lex $P741, "%*ENV"
    unless_null $P741, vivify_115
    get_hll_global $P741, "%ENV"
    unless_null $P741, vivify_116
    die "Contextual %*ENV not found"
  vivify_116:
  vivify_115:
    set $P742, $P741[$P740]
    unless_null $P742, vivify_117
    new $P742, "Undef"
  vivify_117:
    set $P724, $P742
  unless_725_end:
.annotate "line", 961
    unless $P724, unless_723
    set $P722, $P724
    goto unless_723_end
  unless_723:
    new $P743, "String"
    assign $P743, ""
    set $P722, $P743
  unless_723_end:
.annotate "line", 962
    store_lex "$config", $P722
.annotate "line", 964
    new $P744, "Exception"
    set $P744['type'], 58
    find_lex $P745, "$config"
    setattribute $P744, 'payload', $P745
    throw $P744
.annotate "line", 956
    .return ()
  control_715:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P746, exception, "payload"
    .return ($P746)
.end


.namespace ["Hash"]
.sub "_block747"  :subid("55_1261457050.23577") :outer("10_1261457050.23577")
.annotate "line", 84
    .const 'Sub' $P798 = "61_1261457050.23577" 
    capture_lex $P798
    .const 'Sub' $P777 = "59_1261457050.23577" 
    capture_lex $P777
    .const 'Sub' $P756 = "57_1261457050.23577" 
    capture_lex $P756
    .const 'Sub' $P749 = "56_1261457050.23577" 
    capture_lex $P749
.annotate "line", 147
    .const 'Sub' $P798 = "61_1261457050.23577" 
    capture_lex $P798
.annotate "line", 84
    .return ($P798)
.end


.namespace ["Hash"]
.sub "exists"  :subid("56_1261457050.23577") :method :outer("55_1261457050.23577")
    .param pmc param_752
.annotate "line", 97
    new $P751, 'ExceptionHandler'
    set_addr $P751, control_750
    $P751."handle_types"(58)
    push_eh $P751
    .lex "self", self
    .lex "$key", param_752
.annotate "line", 98
    new $P753, "Exception"
    set $P753['type'], 58

            $P1 = find_lex '$key'
            $I0 = exists self[$P1]
            $P754  = box $I0
        
    setattribute $P753, 'payload', $P754
    throw $P753
.annotate "line", 97
    .return ()
  control_750:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P755, exception, "payload"
    .return ($P755)
.end


.namespace ["Hash"]
.sub "keys"  :subid("57_1261457050.23577") :method :outer("55_1261457050.23577")
.annotate "line", 114
    .const 'Sub' $P766 = "58_1261457050.23577" 
    capture_lex $P766
    new $P758, 'ExceptionHandler'
    set_addr $P758, control_757
    $P758."handle_types"(58)
    push_eh $P758
    .lex "self", self
.annotate "line", 115
    new $P759, "ResizablePMCArray"
    .lex "@keys", $P759
.annotate "line", 114
    find_lex $P760, "@keys"
.annotate "line", 116
    find_lex $P762, "self"
    defined $I763, $P762
    unless $I763, for_undef_118
    iter $P761, $P762
    new $P773, 'ExceptionHandler'
    set_addr $P773, loop772_handler
    $P773."handle_types"(65, 67, 66)
    push_eh $P773
  loop772_test:
    unless $P761, loop772_done
    shift $P764, $P761
  loop772_redo:
    .const 'Sub' $P766 = "58_1261457050.23577" 
    capture_lex $P766
    $P766($P764)
  loop772_next:
    goto loop772_test
  loop772_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P774, exception, 'type'
    eq $P774, 65, loop772_next
    eq $P774, 67, loop772_redo
  loop772_done:
    pop_eh 
  for_undef_118:
    find_lex $P775, "@keys"
.annotate "line", 114
    .return ($P775)
  control_757:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P776, exception, "payload"
    .return ($P776)
.end


.namespace ["Hash"]
.sub "_block765"  :anon :subid("58_1261457050.23577") :outer("57_1261457050.23577")
    .param pmc param_767
.annotate "line", 116
    .lex "$_", param_767
    find_lex $P768, "@keys"
    find_lex $P769, "$_"
    $P770 = $P769."key"()
    $P771 = $P768."push"($P770)
    .return ($P771)
.end


.namespace ["Hash"]
.sub "values"  :subid("59_1261457050.23577") :method :outer("55_1261457050.23577")
.annotate "line", 129
    .const 'Sub' $P787 = "60_1261457050.23577" 
    capture_lex $P787
    new $P779, 'ExceptionHandler'
    set_addr $P779, control_778
    $P779."handle_types"(58)
    push_eh $P779
    .lex "self", self
.annotate "line", 130
    new $P780, "ResizablePMCArray"
    .lex "@values", $P780
.annotate "line", 129
    find_lex $P781, "@values"
.annotate "line", 131
    find_lex $P783, "self"
    defined $I784, $P783
    unless $I784, for_undef_119
    iter $P782, $P783
    new $P794, 'ExceptionHandler'
    set_addr $P794, loop793_handler
    $P794."handle_types"(65, 67, 66)
    push_eh $P794
  loop793_test:
    unless $P782, loop793_done
    shift $P785, $P782
  loop793_redo:
    .const 'Sub' $P787 = "60_1261457050.23577" 
    capture_lex $P787
    $P787($P785)
  loop793_next:
    goto loop793_test
  loop793_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P795, exception, 'type'
    eq $P795, 65, loop793_next
    eq $P795, 67, loop793_redo
  loop793_done:
    pop_eh 
  for_undef_119:
    find_lex $P796, "@values"
.annotate "line", 129
    .return ($P796)
  control_778:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P797, exception, "payload"
    .return ($P797)
.end


.namespace ["Hash"]
.sub "_block786"  :anon :subid("60_1261457050.23577") :outer("59_1261457050.23577")
    .param pmc param_788
.annotate "line", 131
    .lex "$_", param_788
    find_lex $P789, "@values"
    find_lex $P790, "$_"
    $P791 = $P790."value"()
    $P792 = $P789."push"($P791)
    .return ($P792)
.end


.namespace ["Hash"]
.sub "kv"  :subid("61_1261457050.23577") :method :outer("55_1261457050.23577")
.annotate "line", 147
    .const 'Sub' $P808 = "62_1261457050.23577" 
    capture_lex $P808
    new $P800, 'ExceptionHandler'
    set_addr $P800, control_799
    $P800."handle_types"(58)
    push_eh $P800
    .lex "self", self
.annotate "line", 148
    new $P801, "ResizablePMCArray"
    .lex "@kv", $P801
.annotate "line", 147
    find_lex $P802, "@kv"
.annotate "line", 149
    find_lex $P804, "self"
    defined $I805, $P804
    unless $I805, for_undef_120
    iter $P803, $P804
    new $P818, 'ExceptionHandler'
    set_addr $P818, loop817_handler
    $P818."handle_types"(65, 67, 66)
    push_eh $P818
  loop817_test:
    unless $P803, loop817_done
    shift $P806, $P803
  loop817_redo:
    .const 'Sub' $P808 = "62_1261457050.23577" 
    capture_lex $P808
    $P808($P806)
  loop817_next:
    goto loop817_test
  loop817_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P819, exception, 'type'
    eq $P819, 65, loop817_next
    eq $P819, 67, loop817_redo
  loop817_done:
    pop_eh 
  for_undef_120:
    find_lex $P820, "@kv"
.annotate "line", 147
    .return ($P820)
  control_799:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P821, exception, "payload"
    .return ($P821)
.end


.namespace ["Hash"]
.sub "_block807"  :anon :subid("62_1261457050.23577") :outer("61_1261457050.23577")
    .param pmc param_809
.annotate "line", 149
    .lex "$_", param_809
    find_lex $P810, "@kv"
    find_lex $P811, "$_"
    $P812 = $P811."key"()
    $P810."push"($P812)
    find_lex $P813, "@kv"
    find_lex $P814, "$_"
    $P815 = $P814."value"()
    $P816 = $P813."push"($P815)
    .return ($P816)
.end


.namespace ["Array"]
.sub "_block822"  :subid("63_1261457050.23577") :outer("10_1261457050.23577")
.annotate "line", 172
    .const 'Sub' $P824 = "64_1261457050.23577" 
    capture_lex $P824
.annotate "line", 185
    .const 'Sub' $P824 = "64_1261457050.23577" 
    capture_lex $P824
.annotate "line", 172
    .return ($P824)
.end


.namespace ["Array"]
.sub "reverse"  :subid("64_1261457050.23577") :method :outer("63_1261457050.23577")
.annotate "line", 185
    .const 'Sub' $P834 = "65_1261457050.23577" 
    capture_lex $P834
    new $P826, 'ExceptionHandler'
    set_addr $P826, control_825
    $P826."handle_types"(58)
    push_eh $P826
    .lex "self", self
.annotate "line", 186
    new $P827, "ResizablePMCArray"
    .lex "@reversed", $P827
.annotate "line", 185
    find_lex $P828, "@reversed"
.annotate "line", 187
    find_lex $P830, "self"
    defined $I831, $P830
    unless $I831, for_undef_121
    iter $P829, $P830
    new $P840, 'ExceptionHandler'
    set_addr $P840, loop839_handler
    $P840."handle_types"(65, 67, 66)
    push_eh $P840
  loop839_test:
    unless $P829, loop839_done
    shift $P832, $P829
  loop839_redo:
    .const 'Sub' $P834 = "65_1261457050.23577" 
    capture_lex $P834
    $P834($P832)
  loop839_next:
    goto loop839_test
  loop839_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P841, exception, 'type'
    eq $P841, 65, loop839_next
    eq $P841, 67, loop839_redo
  loop839_done:
    pop_eh 
  for_undef_121:
    find_lex $P842, "@reversed"
.annotate "line", 185
    .return ($P842)
  control_825:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P843, exception, "payload"
    .return ($P843)
.end


.namespace ["Array"]
.sub "_block833"  :anon :subid("65_1261457050.23577") :outer("64_1261457050.23577")
    .param pmc param_835
.annotate "line", 187
    .lex "$_", param_835
    find_lex $P836, "@reversed"
    find_lex $P837, "$_"
    $P838 = $P836."unshift"($P837)
    .return ($P838)
.end

