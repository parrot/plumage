
.namespace []
.sub "_block11"  :anon :subid("10_1261112412.85332")
.annotate "line", 0
    .const 'Sub' $P593 = "50_1261112412.85332" 
    capture_lex $P593
    get_hll_global $P555, ["Array"], "_block554" 
    capture_lex $P555
    get_hll_global $P480, ["Hash"], "_block479" 
    capture_lex $P480
    .const 'Sub' $P446 = "38_1261112412.85332" 
    capture_lex $P446
    .const 'Sub' $P424 = "37_1261112412.85332" 
    capture_lex $P424
    .const 'Sub' $P409 = "36_1261112412.85332" 
    capture_lex $P409
    .const 'Sub' $P381 = "35_1261112412.85332" 
    capture_lex $P381
    .const 'Sub' $P354 = "33_1261112412.85332" 
    capture_lex $P354
    .const 'Sub' $P344 = "32_1261112412.85332" 
    capture_lex $P344
    .const 'Sub' $P330 = "31_1261112412.85332" 
    capture_lex $P330
    .const 'Sub' $P293 = "29_1261112412.85332" 
    capture_lex $P293
    .const 'Sub' $P260 = "27_1261112412.85332" 
    capture_lex $P260
    .const 'Sub' $P195 = "24_1261112412.85332" 
    capture_lex $P195
    .const 'Sub' $P173 = "22_1261112412.85332" 
    capture_lex $P173
    .const 'Sub' $P166 = "21_1261112412.85332" 
    capture_lex $P166
    .const 'Sub' $P141 = "19_1261112412.85332" 
    capture_lex $P141
    .const 'Sub' $P66 = "15_1261112412.85332" 
    capture_lex $P66
    .const 'Sub' $P38 = "13_1261112412.85332" 
    capture_lex $P38
    .const 'Sub' $P13 = "11_1261112412.85332" 
    capture_lex $P13
.annotate "line", 203
    .const 'Sub' $P13 = "11_1261112412.85332" 
    capture_lex $P13
    .lex "map", $P13
.annotate "line", 223
    .const 'Sub' $P38 = "13_1261112412.85332" 
    capture_lex $P38
    .lex "grep", $P38
.annotate "line", 255
    .const 'Sub' $P66 = "15_1261112412.85332" 
    capture_lex $P66
    .lex "reduce", $P66
.annotate "line", 283
    .const 'Sub' $P141 = "19_1261112412.85332" 
    capture_lex $P141
    .lex "_reduce", $P141
.annotate "line", 311
    .const 'Sub' $P166 = "21_1261112412.85332" 
    capture_lex $P166
    .lex "hash", $P166
.annotate "line", 324
    .const 'Sub' $P173 = "22_1261112412.85332" 
    capture_lex $P173
    .lex "set_from_array", $P173
.annotate "line", 364
    .const 'Sub' $P195 = "24_1261112412.85332" 
    capture_lex $P195
    .lex "find_program", $P195
.annotate "line", 393
    .const 'Sub' $P260 = "27_1261112412.85332" 
    capture_lex $P260
    .lex "mkpath", $P260
.annotate "line", 424
    .const 'Sub' $P293 = "29_1261112412.85332" 
    capture_lex $P293
    .lex "test_dir_writable", $P293
.annotate "line", 452
    .const 'Sub' $P330 = "31_1261112412.85332" 
    capture_lex $P330
    .lex "user_home_dir", $P330
.annotate "line", 478
    .const 'Sub' $P344 = "32_1261112412.85332" 
    capture_lex $P344
    .lex "run", $P344
.annotate "line", 496
    .const 'Sub' $P354 = "33_1261112412.85332" 
    capture_lex $P354
    .lex "do_run", $P354
.annotate "line", 520
    .const 'Sub' $P381 = "35_1261112412.85332" 
    capture_lex $P381
    .lex "qx", $P381
.annotate "line", 555
    .const 'Sub' $P409 = "36_1261112412.85332" 
    capture_lex $P409
    .lex "store_dynlex_safely", $P409
.annotate "line", 675
    .const 'Sub' $P424 = "37_1261112412.85332" 
    capture_lex $P424
    .lex "replace_config_strings", $P424
.annotate "line", 687
    .const 'Sub' $P446 = "38_1261112412.85332" 
    capture_lex $P446
    .lex "config_value", $P446
.annotate "line", 67
    get_hll_global $P480, ["Hash"], "_block479" 
    capture_lex $P480
    $P480()
.annotate "line", 155
    get_hll_global $P555, ["Array"], "_block554" 
    capture_lex $P555
    $P555()
    find_lex $P576, "map"
    find_lex $P577, "grep"
    find_lex $P578, "reduce"
    find_lex $P579, "_reduce"
    find_lex $P580, "hash"
    find_lex $P581, "set_from_array"
    find_lex $P582, "find_program"
    find_lex $P583, "mkpath"
    find_lex $P584, "test_dir_writable"
    find_lex $P585, "user_home_dir"
    find_lex $P586, "run"
    find_lex $P587, "do_run"
    find_lex $P588, "qx"
    find_lex $P589, "store_dynlex_safely"
.annotate "line", 609
    find_lex $P590, "replace_config_strings"
    find_lex $P591, "config_value"
.annotate "line", 1
    .return ($P591)
.end


.namespace []
.sub "" :load :init :subid("post51") :outer("10_1261112412.85332")
.annotate "line", 0
    .const 'Sub' $P12 = "10_1261112412.85332" 
    .local pmc block
    set block, $P12
.annotate "line", 609
    .const 'Sub' $P593 = "50_1261112412.85332" 
    capture_lex $P593
    $P593()
.end


.namespace []
.sub "_block592"  :anon :subid("50_1261112412.85332") :outer("10_1261112412.85332")
.annotate "line", 612
    new $P594, "Undef"
    .lex "$interp", $P594
.annotate "line", 613
    new $P595, "ResizablePMCArray"
    .lex "@argv", $P595
.annotate "line", 614
    new $P596, "Undef"
    .lex "$config", $P596
.annotate "line", 617
    new $P597, "Hash"
    .lex "%VM", $P597
.annotate "line", 610
    load_bytecode "config.pbc"
.annotate "line", 612
    getinterp $P598
    store_lex "$interp", $P598
.annotate "line", 613
    find_lex $P599, "$interp"
    unless_null $P599, vivify_52
    new $P599, "ResizablePMCArray"
  vivify_52:
    set $P600, $P599[2]
    unless_null $P600, vivify_53
    new $P600, "Undef"
  vivify_53:
    store_lex "@argv", $P600
.annotate "line", 614
    find_lex $P601, "$interp"
    unless_null $P601, vivify_54
    new $P601, "ResizablePMCArray"
  vivify_54:
    set $P602, $P601[6]
    unless_null $P602, vivify_55
    new $P602, "Undef"
  vivify_55:
    store_lex "$config", $P602
    find_lex $P603, "%VM"
.annotate "line", 618
    find_lex $P604, "$config"
    find_lex $P605, "%VM"
    unless_null $P605, vivify_56
    new $P605, "Hash"
    store_lex "%VM", $P605
  vivify_56:
    set $P605["config"], $P604
.annotate "line", 619
    find_lex $P606, "%VM"
    "store_dynlex_safely"("%*VM", $P606)
.annotate "line", 622
    find_lex $P608, "@argv"
    if $P608, unless_607_end
    find_lex $P609, "@argv"
    $P609."unshift"("<anonymous>")
  unless_607_end:
.annotate "line", 623
    find_lex $P610, "@argv"
    $P611 = $P610."shift"()
    "store_dynlex_safely"("$*PROGRAM_NAME", $P611)
.annotate "line", 624
    find_lex $P612, "@argv"
    "store_dynlex_safely"("@*ARGS", $P612)
.annotate "line", 627
    interpinfo $S613, 19
    "store_dynlex_safely"("$*EXECUTABLE_NAME", $S613)
.annotate "line", 630
    sysinfo $S614, 4
    "store_dynlex_safely"("$*OSNAME", $S614)
.annotate "line", 631
    sysinfo $S615, 5
    "store_dynlex_safely"("%*OSVER", $S615)
.annotate "line", 634
    new $P616, "ResizablePMCArray"
    push $P616, "parrot"
    push $P616, "Env"
    root_new $P617, $P616
    "store_dynlex_safely"("%*ENV", $P617)
.annotate "line", 635
    new $P618, "ResizablePMCArray"
    push $P618, "parrot"
    push $P618, "OS"
    root_new $P619, $P618
    $P620 = "store_dynlex_safely"("$*OS", $P619)
.annotate "line", 609
    .return ($P620)
.end


.namespace []
.sub "map"  :subid("11_1261112412.85332") :outer("10_1261112412.85332")
    .param pmc param_16
    .param pmc param_17
.annotate "line", 203
    .const 'Sub' $P25 = "12_1261112412.85332" 
    capture_lex $P25
    new $P15, 'ExceptionHandler'
    set_addr $P15, control_14
    $P15."handle_types"(58)
    push_eh $P15
    .lex "&code", param_16
    .lex "@originals", param_17
.annotate "line", 204
    new $P18, "ResizablePMCArray"
    .lex "@mapped", $P18
.annotate "line", 203
    find_lex $P19, "@mapped"
.annotate "line", 206
    find_lex $P21, "@originals"
    defined $I22, $P21
    unless $I22, for_undef_57
    iter $P20, $P21
    new $P33, 'ExceptionHandler'
    set_addr $P33, loop32_handler
    $P33."handle_types"(65, 67, 66)
    push_eh $P33
  loop32_test:
    unless $P20, loop32_done
    shift $P23, $P20
  loop32_redo:
    .const 'Sub' $P25 = "12_1261112412.85332" 
    capture_lex $P25
    $P25($P23)
  loop32_next:
    goto loop32_test
  loop32_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P34, exception, 'type'
    eq $P34, 65, loop32_next
    eq $P34, 67, loop32_redo
  loop32_done:
    pop_eh 
  for_undef_57:
.annotate "line", 210
    new $P35, "Exception"
    set $P35['type'], 58
    find_lex $P36, "@mapped"
    setattribute $P35, 'payload', $P36
    throw $P35
.annotate "line", 203
    .return ()
  control_14:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P37, exception, "payload"
    .return ($P37)
.end


.namespace []
.sub "_block24"  :anon :subid("12_1261112412.85332") :outer("11_1261112412.85332")
    .param pmc param_26
.annotate "line", 206
    .lex "$_", param_26
.annotate "line", 207
    find_lex $P27, "@mapped"
    find_lex $P28, "&code"
    find_lex $P29, "$_"
    $P30 = $P28($P29)
    $P31 = $P27."push"($P30)
.annotate "line", 206
    .return ($P31)
.end


.namespace []
.sub "grep"  :subid("13_1261112412.85332") :outer("10_1261112412.85332")
    .param pmc param_41
    .param pmc param_42
.annotate "line", 223
    .const 'Sub' $P50 = "14_1261112412.85332" 
    capture_lex $P50
    new $P40, 'ExceptionHandler'
    set_addr $P40, control_39
    $P40."handle_types"(58)
    push_eh $P40
    .lex "&code", param_41
    .lex "@all", param_42
.annotate "line", 224
    new $P43, "ResizablePMCArray"
    .lex "@matches", $P43
.annotate "line", 223
    find_lex $P44, "@matches"
.annotate "line", 226
    find_lex $P46, "@all"
    defined $I47, $P46
    unless $I47, for_undef_58
    iter $P45, $P46
    new $P61, 'ExceptionHandler'
    set_addr $P61, loop60_handler
    $P61."handle_types"(65, 67, 66)
    push_eh $P61
  loop60_test:
    unless $P45, loop60_done
    shift $P48, $P45
  loop60_redo:
    .const 'Sub' $P50 = "14_1261112412.85332" 
    capture_lex $P50
    $P50($P48)
  loop60_next:
    goto loop60_test
  loop60_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P62, exception, 'type'
    eq $P62, 65, loop60_next
    eq $P62, 67, loop60_redo
  loop60_done:
    pop_eh 
  for_undef_58:
.annotate "line", 230
    new $P63, "Exception"
    set $P63['type'], 58
    find_lex $P64, "@matches"
    setattribute $P63, 'payload', $P64
    throw $P63
.annotate "line", 223
    .return ()
  control_39:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P65, exception, "payload"
    .return ($P65)
.end


.namespace []
.sub "_block49"  :anon :subid("14_1261112412.85332") :outer("13_1261112412.85332")
    .param pmc param_51
.annotate "line", 226
    .lex "$_", param_51
.annotate "line", 227
    find_lex $P54, "&code"
    find_lex $P55, "$_"
    $P56 = $P54($P55)
    if $P56, if_53
    set $P52, $P56
    goto if_53_end
  if_53:
    find_lex $P57, "@matches"
    find_lex $P58, "$_"
    $P59 = $P57."push"($P58)
    set $P52, $P59
  if_53_end:
.annotate "line", 226
    .return ($P52)
.end


.namespace []
.sub "reduce"  :subid("15_1261112412.85332") :outer("10_1261112412.85332")
    .param pmc param_69
    .param pmc param_70
    .param pmc param_71 :slurpy
.annotate "line", 255
    .const 'Sub' $P93 = "16_1261112412.85332" 
    capture_lex $P93
    new $P68, 'ExceptionHandler'
    set_addr $P68, control_67
    $P68."handle_types"(58)
    push_eh $P68
    .lex "&code", param_69
    .lex "@array", param_70
    .lex "@initial", param_71
.annotate "line", 256
    new $P72, "Undef"
    .lex "$init_elems", $P72
    find_lex $P73, "@initial"
    elements $I74, $P73
    new $P75, 'Integer'
    set $P75, $I74
    store_lex "$init_elems", $P75
.annotate "line", 257
    find_lex $P78, "$init_elems"
    set $N79, $P78
    isgt $I80, $N79, 1.0
    if $I80, if_77
.annotate "line", 260
    find_lex $P83, "$init_elems"
    set $N84, $P83
    iseq $I85, $N84, 1.0
    if $I85, if_82
.annotate "line", 263
    .const 'Sub' $P93 = "16_1261112412.85332" 
    capture_lex $P93
    $P139 = $P93()
    set $P81, $P139
.annotate "line", 260
    goto if_82_end
  if_82:
.annotate "line", 261
    new $P86, "Exception"
    set $P86['type'], 58
    find_lex $P87, "&code"
    find_lex $P88, "@array"
    find_lex $P89, "@initial"
    unless_null $P89, vivify_65
    new $P89, "ResizablePMCArray"
  vivify_65:
    set $P90, $P89[0]
    unless_null $P90, vivify_66
    new $P90, "Undef"
  vivify_66:
    $P91 = "_reduce"($P87, $P88, $P90)
    setattribute $P86, 'payload', $P91
    throw $P86
  if_82_end:
.annotate "line", 260
    set $P76, $P81
.annotate "line", 257
    goto if_77_end
  if_77:
.annotate "line", 258
    die "Only one initial value allowed in reduce()"
  if_77_end:
.annotate "line", 255
    .return ($P76)
  control_67:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P140, exception, "payload"
    .return ($P140)
.end


.namespace []
.sub "_block92"  :anon :subid("16_1261112412.85332") :outer("15_1261112412.85332")
.annotate "line", 263
    .const 'Sub' $P118 = "18_1261112412.85332" 
    capture_lex $P118
    .const 'Sub' $P104 = "17_1261112412.85332" 
    capture_lex $P104
.annotate "line", 264
    new $P94, "Undef"
    .lex "$array_elems", $P94
    find_lex $P95, "@array"
    elements $I96, $P95
    new $P97, 'Integer'
    set $P97, $I96
    store_lex "$array_elems", $P97
.annotate "line", 265
    find_lex $P100, "$array_elems"
    set $N101, $P100
    iseq $I102, $N101, 0.0
    if $I102, if_99
.annotate "line", 268
    find_lex $P111, "$array_elems"
    set $N112, $P111
    iseq $I113, $N112, 1.0
    if $I113, if_110
.annotate "line", 271
    .const 'Sub' $P118 = "18_1261112412.85332" 
    capture_lex $P118
    $P138 = $P118()
    set $P109, $P138
.annotate "line", 268
    goto if_110_end
  if_110:
.annotate "line", 269
    new $P114, "Exception"
    set $P114['type'], 58
    find_lex $P115, "@array"
    unless_null $P115, vivify_63
    new $P115, "ResizablePMCArray"
  vivify_63:
    set $P116, $P115[0]
    unless_null $P116, vivify_64
    new $P116, "Undef"
  vivify_64:
    setattribute $P114, 'payload', $P116
    throw $P114
  if_110_end:
.annotate "line", 268
    set $P98, $P109
.annotate "line", 265
    goto if_99_end
  if_99:
    .const 'Sub' $P104 = "17_1261112412.85332" 
    capture_lex $P104
    $P108 = $P104()
    set $P98, $P108
  if_99_end:
.annotate "line", 263
    .return ($P98)
.end


.namespace []
.sub "_block117"  :anon :subid("18_1261112412.85332") :outer("16_1261112412.85332")
.annotate "line", 272
    new $P119, "Undef"
    .lex "$initial", $P119
.annotate "line", 273
    new $P120, "Undef"
    .lex "$iter", $P120
.annotate "line", 272
    find_lex $P121, "&code"
    find_lex $P122, "@array"
    unless_null $P122, vivify_59
    new $P122, "ResizablePMCArray"
  vivify_59:
    set $P123, $P122[0]
    unless_null $P123, vivify_60
    new $P123, "Undef"
  vivify_60:
    find_lex $P124, "@array"
    unless_null $P124, vivify_61
    new $P124, "ResizablePMCArray"
  vivify_61:
    set $P125, $P124[1]
    unless_null $P125, vivify_62
    new $P125, "Undef"
  vivify_62:
    $P126 = $P121($P123, $P125)
    store_lex "$initial", $P126
.annotate "line", 273
    find_lex $P127, "@array"
    iter $P128, $P127
    store_lex "$iter", $P128
.annotate "line", 275
    find_lex $P129, "$iter"
    shift $P130, $P129
.annotate "line", 276
    find_lex $P131, "$iter"
    shift $P132, $P131
.annotate "line", 278
    new $P133, "Exception"
    set $P133['type'], 58
    find_lex $P134, "&code"
    find_lex $P135, "$iter"
    find_lex $P136, "$initial"
    $P137 = "_reduce"($P134, $P135, $P136)
    setattribute $P133, 'payload', $P137
    throw $P133
.annotate "line", 271
    .return ()
.end


.namespace []
.sub "_block103"  :anon :subid("17_1261112412.85332") :outer("16_1261112412.85332")
.annotate "line", 266
    new $P105, "Undef"
    .lex "$undef", $P105
    new $P106, "Exception"
    set $P106['type'], 58
    find_lex $P107, "$undef"
    setattribute $P106, 'payload', $P107
    throw $P106
.annotate "line", 265
    .return ()
.end


.namespace []
.sub "_reduce"  :subid("19_1261112412.85332") :outer("10_1261112412.85332")
    .param pmc param_144
    .param pmc param_145
    .param pmc param_146
.annotate "line", 283
    .const 'Sub' $P154 = "20_1261112412.85332" 
    capture_lex $P154
    new $P143, 'ExceptionHandler'
    set_addr $P143, control_142
    $P143."handle_types"(58)
    push_eh $P143
    .lex "&code", param_144
    .lex "$iter", param_145
    .lex "$initial", param_146
.annotate "line", 284
    new $P147, "Undef"
    .lex "$result", $P147
    find_lex $P148, "$initial"
    store_lex "$result", $P148
.annotate "line", 286
    find_lex $P150, "$iter"
    defined $I151, $P150
    unless $I151, for_undef_67
    iter $P149, $P150
    new $P161, 'ExceptionHandler'
    set_addr $P161, loop160_handler
    $P161."handle_types"(65, 67, 66)
    push_eh $P161
  loop160_test:
    unless $P149, loop160_done
    shift $P152, $P149
  loop160_redo:
    .const 'Sub' $P154 = "20_1261112412.85332" 
    capture_lex $P154
    $P154($P152)
  loop160_next:
    goto loop160_test
  loop160_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P162, exception, 'type'
    eq $P162, 65, loop160_next
    eq $P162, 67, loop160_redo
  loop160_done:
    pop_eh 
  for_undef_67:
.annotate "line", 290
    new $P163, "Exception"
    set $P163['type'], 58
    find_lex $P164, "$result"
    setattribute $P163, 'payload', $P164
    throw $P163
.annotate "line", 283
    .return ()
  control_142:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P165, exception, "payload"
    .return ($P165)
.end


.namespace []
.sub "_block153"  :anon :subid("20_1261112412.85332") :outer("19_1261112412.85332")
    .param pmc param_155
.annotate "line", 286
    .lex "$_", param_155
.annotate "line", 287
    find_lex $P156, "&code"
    find_lex $P157, "$result"
    find_lex $P158, "$_"
    $P159 = $P156($P157, $P158)
    store_lex "$result", $P159
.annotate "line", 286
    .return ($P159)
.end


.namespace []
.sub "hash"  :subid("21_1261112412.85332") :outer("10_1261112412.85332")
    .param pmc param_169 :slurpy :named
.annotate "line", 311
    new $P168, 'ExceptionHandler'
    set_addr $P168, control_167
    $P168."handle_types"(58)
    push_eh $P168
    .lex "%h", param_169
    new $P170, "Exception"
    set $P170['type'], 58
    find_lex $P171, "%h"
    setattribute $P170, 'payload', $P171
    throw $P170
    .return ()
  control_167:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P172, exception, "payload"
    .return ($P172)
.end


.namespace []
.sub "set_from_array"  :subid("22_1261112412.85332") :outer("10_1261112412.85332")
    .param pmc param_176
.annotate "line", 324
    .const 'Sub' $P184 = "23_1261112412.85332" 
    capture_lex $P184
    new $P175, 'ExceptionHandler'
    set_addr $P175, control_174
    $P175."handle_types"(58)
    push_eh $P175
    .lex "@array", param_176
.annotate "line", 325
    new $P177, "Hash"
    .lex "%set", $P177
.annotate "line", 324
    find_lex $P178, "%set"
.annotate "line", 327
    find_lex $P180, "@array"
    defined $I181, $P180
    unless $I181, for_undef_68
    iter $P179, $P180
    new $P190, 'ExceptionHandler'
    set_addr $P190, loop189_handler
    $P190."handle_types"(65, 67, 66)
    push_eh $P190
  loop189_test:
    unless $P179, loop189_done
    shift $P182, $P179
  loop189_redo:
    .const 'Sub' $P184 = "23_1261112412.85332" 
    capture_lex $P184
    $P184($P182)
  loop189_next:
    goto loop189_test
  loop189_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P191, exception, 'type'
    eq $P191, 65, loop189_next
    eq $P191, 67, loop189_redo
  loop189_done:
    pop_eh 
  for_undef_68:
.annotate "line", 331
    new $P192, "Exception"
    set $P192['type'], 58
    find_lex $P193, "%set"
    setattribute $P192, 'payload', $P193
    throw $P192
.annotate "line", 324
    .return ()
  control_174:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P194, exception, "payload"
    .return ($P194)
.end


.namespace []
.sub "_block183"  :anon :subid("23_1261112412.85332") :outer("22_1261112412.85332")
    .param pmc param_185
.annotate "line", 327
    .lex "$_", param_185
.annotate "line", 328
    new $P186, "Integer"
    assign $P186, 1
    find_lex $P187, "$_"
    find_lex $P188, "%set"
    unless_null $P188, vivify_69
    new $P188, "Hash"
    store_lex "%set", $P188
  vivify_69:
    set $P188[$P187], $P186
.annotate "line", 327
    .return ($P186)
.end


.namespace []
.sub "find_program"  :subid("24_1261112412.85332") :outer("10_1261112412.85332")
    .param pmc param_198
.annotate "line", 364
    .const 'Sub' $P227 = "25_1261112412.85332" 
    capture_lex $P227
    new $P197, 'ExceptionHandler'
    set_addr $P197, control_196
    $P197."handle_types"(58)
    push_eh $P197
    .lex "$program", param_198
.annotate "line", 365
    new $P199, "Undef"
    .lex "$path_sep", $P199
.annotate "line", 366
    new $P200, "ResizablePMCArray"
    .lex "@paths", $P200
.annotate "line", 367
    new $P201, "ResizablePMCArray"
    .lex "@exts", $P201
.annotate "line", 365
    find_dynamic_lex $P204, "$*OSNAME"
    unless_null $P204, vivify_70
    get_hll_global $P204, "$OSNAME"
    unless_null $P204, vivify_71
    die "Contextual $*OSNAME not found"
  vivify_71:
  vivify_70:
    set $S205, $P204
    iseq $I206, $S205, "MSWin32"
    if $I206, if_203
    new $P208, "String"
    assign $P208, ":"
    set $P202, $P208
    goto if_203_end
  if_203:
    new $P207, "String"
    assign $P207, ";"
    set $P202, $P207
  if_203_end:
    store_lex "$path_sep", $P202
.annotate "line", 366
    find_lex $P209, "$path_sep"
    set $S210, $P209
    find_dynamic_lex $P211, "%*ENV"
    unless_null $P211, vivify_72
    get_hll_global $P211, "%ENV"
    unless_null $P211, vivify_73
    die "Contextual %*ENV not found"
  vivify_73:
  vivify_72:
    set $P212, $P211["PATH"]
    unless_null $P212, vivify_74
    new $P212, "Undef"
  vivify_74:
    set $S213, $P212
    split $P214, $S210, $S213
    store_lex "@paths", $P214
.annotate "line", 367
    find_lex $P215, "$path_sep"
    set $S216, $P215
    find_dynamic_lex $P217, "%*ENV"
    unless_null $P217, vivify_75
    get_hll_global $P217, "%ENV"
    unless_null $P217, vivify_76
    die "Contextual %*ENV not found"
  vivify_76:
  vivify_75:
    set $P218, $P217["PATHEXT"]
    unless_null $P218, vivify_77
    new $P218, "Undef"
  vivify_77:
    set $S219, $P218
    split $P220, $S216, $S219
    store_lex "@exts", $P220
.annotate "line", 369
    find_lex $P221, "@exts"
    $P221."unshift"("")
.annotate "line", 371
    find_lex $P223, "@paths"
    defined $I224, $P223
    unless $I224, for_undef_78
    iter $P222, $P223
    new $P255, 'ExceptionHandler'
    set_addr $P255, loop254_handler
    $P255."handle_types"(65, 67, 66)
    push_eh $P255
  loop254_test:
    unless $P222, loop254_done
    shift $P225, $P222
  loop254_redo:
    .const 'Sub' $P227 = "25_1261112412.85332" 
    capture_lex $P227
    $P227($P225)
  loop254_next:
    goto loop254_test
  loop254_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P256, exception, 'type'
    eq $P256, 65, loop254_next
    eq $P256, 67, loop254_redo
  loop254_done:
    pop_eh 
  for_undef_78:
.annotate "line", 380
    new $P257, "Exception"
    set $P257['type'], 58
    new $P258, "String"
    assign $P258, ""
    setattribute $P257, 'payload', $P258
    throw $P257
.annotate "line", 364
    .return ()
  control_196:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P259, exception, "payload"
    .return ($P259)
.end


.namespace []
.sub "_block226"  :anon :subid("25_1261112412.85332") :outer("24_1261112412.85332")
    .param pmc param_228
.annotate "line", 371
    .const 'Sub' $P239 = "26_1261112412.85332" 
    capture_lex $P239
    .lex "$dir", param_228
.annotate "line", 372
    new $P229, "Undef"
    .lex "$path", $P229
    find_lex $P230, "$dir"
    new $P231, "ResizablePMCArray"
    push $P231, $P230
    find_lex $P232, "$program"
    $P233 = "fscat"($P231, $P232)
    store_lex "$path", $P233
.annotate "line", 374
    find_lex $P235, "@exts"
    defined $I236, $P235
    unless $I236, for_undef_79
    iter $P234, $P235
    new $P252, 'ExceptionHandler'
    set_addr $P252, loop251_handler
    $P252."handle_types"(65, 67, 66)
    push_eh $P252
  loop251_test:
    unless $P234, loop251_done
    shift $P237, $P234
  loop251_redo:
    .const 'Sub' $P239 = "26_1261112412.85332" 
    capture_lex $P239
    $P239($P237)
  loop251_next:
    goto loop251_test
  loop251_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P253, exception, 'type'
    eq $P253, 65, loop251_next
    eq $P253, 67, loop251_redo
  loop251_done:
    pop_eh 
  for_undef_79:
.annotate "line", 371
    .return ($P234)
.end


.namespace []
.sub "_block238"  :anon :subid("26_1261112412.85332") :outer("25_1261112412.85332")
    .param pmc param_240
.annotate "line", 374
    .lex "$ext", param_240
.annotate "line", 375
    new $P241, "Undef"
    .lex "$pathext", $P241
    find_lex $P242, "$path"
    find_lex $P243, "$ext"
    concat $P244, $P242, $P243
    store_lex "$pathext", $P244
.annotate "line", 376
    find_lex $P247, "$pathext"
    $P248 = "path_exists"($P247)
    if $P248, if_246
    set $P245, $P248
    goto if_246_end
  if_246:
    new $P249, "Exception"
    set $P249['type'], 58
    find_lex $P250, "$pathext"
    setattribute $P249, 'payload', $P250
    throw $P249
  if_246_end:
.annotate "line", 374
    .return ($P245)
.end


.namespace []
.sub "mkpath"  :subid("27_1261112412.85332") :outer("10_1261112412.85332")
    .param pmc param_263
.annotate "line", 393
    .const 'Sub' $P276 = "28_1261112412.85332" 
    capture_lex $P276
    new $P262, 'ExceptionHandler'
    set_addr $P262, control_261
    $P262."handle_types"(58)
    push_eh $P262
    .lex "$path", param_263
.annotate "line", 394
    new $P264, "ResizablePMCArray"
    .lex "@path", $P264
.annotate "line", 395
    new $P265, "Undef"
    .lex "$cur", $P265
.annotate "line", 394
    find_lex $P266, "$path"
    set $S267, $P266
    split $P268, "/", $S267
    store_lex "@path", $P268
.annotate "line", 395
    find_lex $P269, "@path"
    $P270 = $P269."shift"()
    store_lex "$cur", $P270
.annotate "line", 397
    find_lex $P272, "@path"
    defined $I273, $P272
    unless $I273, for_undef_80
    iter $P271, $P272
    new $P290, 'ExceptionHandler'
    set_addr $P290, loop289_handler
    $P290."handle_types"(65, 67, 66)
    push_eh $P290
  loop289_test:
    unless $P271, loop289_done
    shift $P274, $P271
  loop289_redo:
    .const 'Sub' $P276 = "28_1261112412.85332" 
    capture_lex $P276
    $P276($P274)
  loop289_next:
    goto loop289_test
  loop289_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P291, exception, 'type'
    eq $P291, 65, loop289_next
    eq $P291, 67, loop289_redo
  loop289_done:
    pop_eh 
  for_undef_80:
.annotate "line", 393
    .return ($P271)
  control_261:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P292, exception, "payload"
    .return ($P292)
.end


.namespace []
.sub "_block275"  :anon :subid("28_1261112412.85332") :outer("27_1261112412.85332")
    .param pmc param_277
.annotate "line", 397
    .lex "$dir", param_277
.annotate "line", 398
    find_lex $P278, "$cur"
    find_lex $P279, "$dir"
    new $P280, "ResizablePMCArray"
    push $P280, $P278
    push $P280, $P279
    $P281 = "fscat"($P280)
    store_lex "$cur", $P281
.annotate "line", 400
    find_lex $P284, "$cur"
    $P285 = "path_exists"($P284)
    unless $P285, unless_283
    set $P282, $P285
    goto unless_283_end
  unless_283:
.annotate "line", 401
    find_dynamic_lex $P286, "$*OS"
    unless_null $P286, vivify_81
    get_hll_global $P286, "$OS"
    unless_null $P286, vivify_82
    die "Contextual $*OS not found"
  vivify_82:
  vivify_81:
    find_lex $P287, "$cur"
    $P288 = $P286."mkdir"($P287, 511)
.annotate "line", 400
    set $P282, $P288
  unless_283_end:
.annotate "line", 397
    .return ($P282)
.end


.namespace []
.sub "test_dir_writable"  :subid("29_1261112412.85332") :outer("10_1261112412.85332")
    .param pmc param_296
.annotate "line", 424
    .const 'Sub' $P309 = "30_1261112412.85332" 
    capture_lex $P309
    new $P295, 'ExceptionHandler'
    set_addr $P295, control_294
    $P295."handle_types"(58)
    push_eh $P295
    .lex "$dir", param_296
.annotate "line", 425
    new $P297, "Undef"
    .lex "$test_file", $P297
    find_lex $P298, "$dir"
    new $P299, "ResizablePMCArray"
    push $P299, $P298
    $P300 = "fscat"($P299, "WrItAbLe.UtL")
    store_lex "$test_file", $P300
.annotate "line", 428
    find_lex $P302, "$test_file"
    $P303 = "path_exists"($P302)
    unless $P303, if_301_end
.annotate "line", 427
    new $P304, 'String'
    set $P304, "Test file '"
    find_lex $P305, "$test_file"
    concat $P306, $P304, $P305
    concat $P307, $P306, "'\nthat should never exist already does."
    die $P307
  if_301_end:
.annotate "line", 430
    .const 'Sub' $P309 = "30_1261112412.85332" 
    capture_lex $P309
    $P309()
.annotate "line", 434
    find_lex $P321, "$test_file"
    $P322 = "path_exists"($P321)
    if $P322, if_320
.annotate "line", 439
    new $P327, "Exception"
    set $P327['type'], 58
    new $P328, "Integer"
    assign $P328, 0
    setattribute $P327, 'payload', $P328
    throw $P327
.annotate "line", 438
    goto if_320_end
  if_320:
.annotate "line", 435
    find_dynamic_lex $P323, "$*OS"
    unless_null $P323, vivify_83
    get_hll_global $P323, "$OS"
    unless_null $P323, vivify_84
    die "Contextual $*OS not found"
  vivify_84:
  vivify_83:
    find_lex $P324, "$test_file"
    $P323."rm"($P324)
.annotate "line", 436
    new $P325, "Exception"
    set $P325['type'], 58
    new $P326, "Integer"
    assign $P326, 1
    setattribute $P325, 'payload', $P326
    throw $P325
  if_320_end:
.annotate "line", 424
    .return ($P319)
  control_294:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P329, exception, "payload"
    .return ($P329)
.end


.namespace []
.sub "_block308"  :anon :subid("30_1261112412.85332") :outer("29_1261112412.85332")
.annotate "line", 430
    new $P314, 'ExceptionHandler'
    set_addr $P314, control_313
    $P314."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P314
.annotate "line", 431
    find_lex $P310, "$test_file"
    $P311 = "spew"($P310, "test_dir_writable() test file.\n")
.annotate "line", 430
    pop_eh 
    goto skip_handler_312
  control_313:
    .local pmc exception 
    .get_results (exception) 
    new $P317, 'Integer'
    set $P317, 1
    set exception["handled"], $P317
    set $I318, exception["handled"]
    ne $I318, 1, nothandled_316
  handled_315:
    .return (exception)
  nothandled_316:
    rethrow exception
  skip_handler_312:
    .return ($P311)
.end


.namespace []
.sub "user_home_dir"  :subid("31_1261112412.85332") :outer("10_1261112412.85332")
.annotate "line", 452
    new $P332, 'ExceptionHandler'
    set_addr $P332, control_331
    $P332."handle_types"(58)
    push_eh $P332
.annotate "line", 453
    new $P333, "Exception"
    set $P333['type'], 58
    find_dynamic_lex $P335, "%*ENV"
    unless_null $P335, vivify_85
    get_hll_global $P335, "%ENV"
    unless_null $P335, vivify_86
    die "Contextual %*ENV not found"
  vivify_86:
  vivify_85:
    set $P336, $P335["HOMEDRIVE"]
    unless_null $P336, vivify_87
    new $P336, "Undef"
  vivify_87:
    set $P334, $P336
    defined $I338, $P334
    if $I338, default_337
    new $P339, "String"
    assign $P339, ""
    set $P334, $P339
  default_337:
    find_dynamic_lex $P340, "%*ENV"
    unless_null $P340, vivify_88
    get_hll_global $P340, "%ENV"
    unless_null $P340, vivify_89
    die "Contextual %*ENV not found"
  vivify_89:
  vivify_88:
    set $P341, $P340["HOME"]
    unless_null $P341, vivify_90
    new $P341, "Undef"
  vivify_90:
    concat $P342, $P334, $P341
    setattribute $P333, 'payload', $P342
    throw $P333
.annotate "line", 452
    .return ()
  control_331:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P343, exception, "payload"
    .return ($P343)
.end


.namespace []
.sub "run"  :subid("32_1261112412.85332") :outer("10_1261112412.85332")
    .param pmc param_347 :slurpy
.annotate "line", 478
    new $P346, 'ExceptionHandler'
    set_addr $P346, control_345
    $P346."handle_types"(58)
    push_eh $P346
    .lex "@command_and_args", param_347
.annotate "line", 479
    new $P348, "Exception"
    set $P348['type'], 58
    find_lex $P349, "@command_and_args"
    spawnw $I350, $P349
    new $P351, 'Integer'
    set $P351, $I350
    shr $P352, $P351, 8
    setattribute $P348, 'payload', $P352
    throw $P348
.annotate "line", 478
    .return ()
  control_345:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P353, exception, "payload"
    .return ($P353)
.end


.namespace []
.sub "do_run"  :subid("33_1261112412.85332") :outer("10_1261112412.85332")
    .param pmc param_357 :slurpy
.annotate "line", 496
    .const 'Sub' $P373 = "34_1261112412.85332" 
    capture_lex $P373
    new $P356, 'ExceptionHandler'
    set_addr $P356, control_355
    $P356."handle_types"(58)
    push_eh $P356
    new $P369, 'ExceptionHandler'
    set_addr $P369, control_368
    $P369."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P369
    .lex "@command_and_args", param_357
.annotate "line", 497
    find_lex $P358, "@command_and_args"
    join $S359, " ", $P358
    "say"($S359)
.annotate "line", 499
    new $P360, "Exception"
    set $P360['type'], 58
    find_lex $P363, "@command_and_args"
    spawnw $I364, $P363
    if $I364, if_362
    new $P366, "Integer"
    assign $P366, 1
    set $P361, $P366
    goto if_362_end
  if_362:
    new $P365, "Integer"
    assign $P365, 0
    set $P361, $P365
  if_362_end:
    setattribute $P360, 'payload', $P361
    throw $P360
.annotate "line", 496
    pop_eh 
    goto skip_handler_367
  control_368:
.annotate "line", 501
    .local pmc exception 
    .get_results (exception) 
    .const 'Sub' $P373 = "34_1261112412.85332" 
    capture_lex $P373
    $P373(exception)
    new $P378, 'Integer'
    set $P378, 1
    set exception["handled"], $P378
    set $I379, exception["handled"]
    ne $I379, 1, nothandled_371
  handled_370:
    .return (exception)
  nothandled_371:
    rethrow exception
  skip_handler_367:
.annotate "line", 496
    .return ()
  control_355:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P380, exception, "payload"
    .return ($P380)
.end


.namespace []
.sub "_block372"  :anon :subid("34_1261112412.85332") :outer("33_1261112412.85332")
    .param pmc param_374
.annotate "line", 501
    .lex "$_", param_374
    find_lex $P375, "$_"
    .lex "$!", $P375
.annotate "line", 502
    new $P376, "Exception"
    set $P376['type'], 58
    new $P377, "Integer"
    assign $P377, -1
    setattribute $P376, 'payload', $P377
    throw $P376
.annotate "line", 501
    .return ()
.end


.namespace []
.sub "qx"  :subid("35_1261112412.85332") :outer("10_1261112412.85332")
    .param pmc param_384 :slurpy
.annotate "line", 520
    new $P383, 'ExceptionHandler'
    set_addr $P383, control_382
    $P383."handle_types"(58)
    push_eh $P383
    .lex "@command_and_args", param_384
.annotate "line", 521
    new $P385, "Undef"
    .lex "$cmd", $P385
.annotate "line", 522
    new $P386, "Undef"
    .lex "$pipe", $P386
.annotate "line", 526
    new $P387, "Undef"
    .lex "$output", $P387
.annotate "line", 521
    find_lex $P388, "@command_and_args"
    join $S389, " ", $P388
    new $P390, 'String'
    set $P390, $S389
    store_lex "$cmd", $P390
.annotate "line", 522
    find_lex $P391, "$cmd"
    set $S392, $P391
    open $P393, $S392, "rp"
    store_lex "$pipe", $P393
.annotate "line", 523
    find_lex $P395, "$pipe"
    if $P395, unless_394_end
    new $P396, 'String'
    set $P396, "Unable to execute '"
    find_lex $P397, "$cmd"
    concat $P398, $P396, $P397
    concat $P399, $P398, "'"
    die $P399
  unless_394_end:
.annotate "line", 525
    find_lex $P400, "$pipe"
    $P400."encoding"("utf8")
.annotate "line", 526
    find_lex $P401, "$pipe"
    $P402 = $P401."readall"()
    store_lex "$output", $P402
.annotate "line", 527
    find_lex $P403, "$pipe"
    $P403."close"()
.annotate "line", 529
    find_lex $P404, "$pipe"
    $P405 = $P404."exit_status"()
    "store_dynlex_safely"("$!", $P405)
.annotate "line", 531
    new $P406, "Exception"
    set $P406['type'], 58
    find_lex $P407, "$output"
    setattribute $P406, 'payload', $P407
    throw $P406
.annotate "line", 520
    .return ()
  control_382:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P408, exception, "payload"
    .return ($P408)
.end


.namespace []
.sub "store_dynlex_safely"  :subid("36_1261112412.85332") :outer("10_1261112412.85332")
    .param pmc param_412
    .param pmc param_413
.annotate "line", 555
    new $P411, 'ExceptionHandler'
    set_addr $P411, control_410
    $P411."handle_types"(58)
    push_eh $P411
    .lex "$var_name", param_412
    .lex "$value", param_413
.annotate "line", 557
    find_lex $P416, "$var_name"
    set $S417, $P416
    find_dynamic_lex $P418, $S417
    isnull $I419, $P418
    unless $I419, unless_415
    new $P414, 'Integer'
    set $P414, $I419
    goto unless_415_end
  unless_415:
.annotate "line", 556
    find_lex $P420, "$var_name"
    set $S421, $P420
    find_lex $P422, "$value"
    store_dynamic_lex $S421, $P422
  unless_415_end:
.annotate "line", 555
    .return ($P414)
  control_410:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P423, exception, "payload"
    .return ($P423)
.end


.namespace []
.sub "replace_config_strings"  :subid("37_1261112412.85332") :outer("10_1261112412.85332")
    .param pmc param_427
.annotate "line", 675
    new $P426, 'ExceptionHandler'
    set_addr $P426, control_425
    $P426."handle_types"(58)
    push_eh $P426
    .lex "$original", param_427
.annotate "line", 676
    new $P428, "Undef"
    .lex "$new", $P428
    find_lex $P429, "$original"
    store_lex "$new", $P429
.annotate "line", 678
    new $P441, 'ExceptionHandler'
    set_addr $P441, loop440_handler
    $P441."handle_types"(65, 67, 66)
    push_eh $P441
    goto loop440_redo
  loop440_test:
.annotate "line", 682
    find_lex $P430, "$new"
    set $S431, $P430
    find_lex $P432, "$original"
    set $S433, $P432
    isne $I434, $S431, $S433
    unless $I434, loop440_done
  loop440_redo:
.annotate "line", 679
    find_lex $P435, "$new"
    store_lex "$original", $P435
.annotate "line", 680
    find_lex $P436, "$original"
    $P437 = "rx"("\\#<ident>\\#")
    get_hll_global $P438, "config_value"
    $P439 = "subst"($P436, $P437, $P438)
    store_lex "$new", $P439
  loop440_next:
.annotate "line", 678
    goto loop440_test
  loop440_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P442, exception, 'type'
    eq $P442, 65, loop440_next
    eq $P442, 67, loop440_redo
  loop440_done:
    pop_eh 
.annotate "line", 684
    new $P443, "Exception"
    set $P443['type'], 58
    find_lex $P444, "$new"
    setattribute $P443, 'payload', $P444
    throw $P443
.annotate "line", 675
    .return ()
  control_425:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P445, exception, "payload"
    .return ($P445)
.end


.namespace []
.sub "config_value"  :subid("38_1261112412.85332") :outer("10_1261112412.85332")
    .param pmc param_449
.annotate "line", 687
    new $P448, 'ExceptionHandler'
    set_addr $P448, control_447
    $P448."handle_types"(58)
    push_eh $P448
    .lex "$match", param_449
.annotate "line", 688
    new $P450, "Undef"
    .lex "$key", $P450
.annotate "line", 689
    new $P451, "Undef"
    .lex "$config", $P451
.annotate "line", 688
    find_lex $P452, "$match"
    unless_null $P452, vivify_91
    new $P452, "Hash"
  vivify_91:
    set $P453, $P452["ident"]
    unless_null $P453, vivify_92
    new $P453, "Undef"
  vivify_92:
    store_lex "$key", $P453
.annotate "line", 690
    find_lex $P462, "$key"
    find_dynamic_lex $P463, "%*CONF"
    unless_null $P463, vivify_93
    get_hll_global $P463, "%CONF"
    unless_null $P463, vivify_94
    die "Contextual %*CONF not found"
  vivify_94:
  vivify_93:
    set $P464, $P463[$P462]
    unless_null $P464, vivify_95
    new $P464, "Undef"
  vivify_95:
    unless $P464, unless_461
    set $P460, $P464
    goto unless_461_end
  unless_461:
    find_lex $P465, "$key"
    find_dynamic_lex $P466, "%*VM"
    unless_null $P466, vivify_96
    get_hll_global $P466, "%VM"
    unless_null $P466, vivify_97
    die "Contextual %*VM not found"
  vivify_97:
  vivify_96:
    set $P467, $P466["config"]
    unless_null $P467, vivify_98
    new $P467, "Hash"
  vivify_98:
    set $P468, $P467[$P465]
    unless_null $P468, vivify_99
    new $P468, "Undef"
  vivify_99:
    set $P460, $P468
  unless_461_end:
    unless $P460, unless_459
    set $P458, $P460
    goto unless_459_end
  unless_459:
    find_lex $P469, "$key"
    find_dynamic_lex $P470, "%*BIN"
    unless_null $P470, vivify_100
    get_hll_global $P470, "%BIN"
    unless_null $P470, vivify_101
    die "Contextual %*BIN not found"
  vivify_101:
  vivify_100:
    set $P471, $P470[$P469]
    unless_null $P471, vivify_102
    new $P471, "Undef"
  vivify_102:
    set $P458, $P471
  unless_459_end:
.annotate "line", 691
    unless $P458, unless_457
    set $P456, $P458
    goto unless_457_end
  unless_457:
    find_lex $P472, "$key"
    find_dynamic_lex $P473, "%*ENV"
    unless_null $P473, vivify_103
    get_hll_global $P473, "%ENV"
    unless_null $P473, vivify_104
    die "Contextual %*ENV not found"
  vivify_104:
  vivify_103:
    set $P474, $P473[$P472]
    unless_null $P474, vivify_105
    new $P474, "Undef"
  vivify_105:
    set $P456, $P474
  unless_457_end:
.annotate "line", 692
    unless $P456, unless_455
    set $P454, $P456
    goto unless_455_end
  unless_455:
    new $P475, "String"
    assign $P475, ""
    set $P454, $P475
  unless_455_end:
.annotate "line", 693
    store_lex "$config", $P454
.annotate "line", 695
    new $P476, "Exception"
    set $P476['type'], 58
    find_lex $P477, "$config"
    setattribute $P476, 'payload', $P477
    throw $P476
.annotate "line", 687
    .return ()
  control_447:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P478, exception, "payload"
    .return ($P478)
.end


.namespace ["Hash"]
.sub "_block479"  :subid("39_1261112412.85332") :outer("10_1261112412.85332")
.annotate "line", 67
    .const 'Sub' $P530 = "45_1261112412.85332" 
    capture_lex $P530
    .const 'Sub' $P509 = "43_1261112412.85332" 
    capture_lex $P509
    .const 'Sub' $P488 = "41_1261112412.85332" 
    capture_lex $P488
    .const 'Sub' $P481 = "40_1261112412.85332" 
    capture_lex $P481
.annotate "line", 130
    .const 'Sub' $P530 = "45_1261112412.85332" 
    capture_lex $P530
.annotate "line", 67
    .return ($P530)
.end


.namespace ["Hash"]
.sub "exists"  :subid("40_1261112412.85332") :method :outer("39_1261112412.85332")
    .param pmc param_484
.annotate "line", 80
    new $P483, 'ExceptionHandler'
    set_addr $P483, control_482
    $P483."handle_types"(58)
    push_eh $P483
    .lex "self", self
    .lex "$key", param_484
.annotate "line", 81
    new $P485, "Exception"
    set $P485['type'], 58

            $P1 = find_lex '$key'
            $I0 = exists self[$P1]
            $P486  = box $I0
        
    setattribute $P485, 'payload', $P486
    throw $P485
.annotate "line", 80
    .return ()
  control_482:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P487, exception, "payload"
    .return ($P487)
.end


.namespace ["Hash"]
.sub "keys"  :subid("41_1261112412.85332") :method :outer("39_1261112412.85332")
.annotate "line", 97
    .const 'Sub' $P498 = "42_1261112412.85332" 
    capture_lex $P498
    new $P490, 'ExceptionHandler'
    set_addr $P490, control_489
    $P490."handle_types"(58)
    push_eh $P490
    .lex "self", self
.annotate "line", 98
    new $P491, "ResizablePMCArray"
    .lex "@keys", $P491
.annotate "line", 97
    find_lex $P492, "@keys"
.annotate "line", 99
    find_lex $P494, "self"
    defined $I495, $P494
    unless $I495, for_undef_106
    iter $P493, $P494
    new $P505, 'ExceptionHandler'
    set_addr $P505, loop504_handler
    $P505."handle_types"(65, 67, 66)
    push_eh $P505
  loop504_test:
    unless $P493, loop504_done
    shift $P496, $P493
  loop504_redo:
    .const 'Sub' $P498 = "42_1261112412.85332" 
    capture_lex $P498
    $P498($P496)
  loop504_next:
    goto loop504_test
  loop504_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P506, exception, 'type'
    eq $P506, 65, loop504_next
    eq $P506, 67, loop504_redo
  loop504_done:
    pop_eh 
  for_undef_106:
    find_lex $P507, "@keys"
.annotate "line", 97
    .return ($P507)
  control_489:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P508, exception, "payload"
    .return ($P508)
.end


.namespace ["Hash"]
.sub "_block497"  :anon :subid("42_1261112412.85332") :outer("41_1261112412.85332")
    .param pmc param_499
.annotate "line", 99
    .lex "$_", param_499
    find_lex $P500, "@keys"
    find_lex $P501, "$_"
    $P502 = $P501."key"()
    $P503 = $P500."push"($P502)
    .return ($P503)
.end


.namespace ["Hash"]
.sub "values"  :subid("43_1261112412.85332") :method :outer("39_1261112412.85332")
.annotate "line", 112
    .const 'Sub' $P519 = "44_1261112412.85332" 
    capture_lex $P519
    new $P511, 'ExceptionHandler'
    set_addr $P511, control_510
    $P511."handle_types"(58)
    push_eh $P511
    .lex "self", self
.annotate "line", 113
    new $P512, "ResizablePMCArray"
    .lex "@values", $P512
.annotate "line", 112
    find_lex $P513, "@values"
.annotate "line", 114
    find_lex $P515, "self"
    defined $I516, $P515
    unless $I516, for_undef_107
    iter $P514, $P515
    new $P526, 'ExceptionHandler'
    set_addr $P526, loop525_handler
    $P526."handle_types"(65, 67, 66)
    push_eh $P526
  loop525_test:
    unless $P514, loop525_done
    shift $P517, $P514
  loop525_redo:
    .const 'Sub' $P519 = "44_1261112412.85332" 
    capture_lex $P519
    $P519($P517)
  loop525_next:
    goto loop525_test
  loop525_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P527, exception, 'type'
    eq $P527, 65, loop525_next
    eq $P527, 67, loop525_redo
  loop525_done:
    pop_eh 
  for_undef_107:
    find_lex $P528, "@values"
.annotate "line", 112
    .return ($P528)
  control_510:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P529, exception, "payload"
    .return ($P529)
.end


.namespace ["Hash"]
.sub "_block518"  :anon :subid("44_1261112412.85332") :outer("43_1261112412.85332")
    .param pmc param_520
.annotate "line", 114
    .lex "$_", param_520
    find_lex $P521, "@values"
    find_lex $P522, "$_"
    $P523 = $P522."value"()
    $P524 = $P521."push"($P523)
    .return ($P524)
.end


.namespace ["Hash"]
.sub "kv"  :subid("45_1261112412.85332") :method :outer("39_1261112412.85332")
.annotate "line", 130
    .const 'Sub' $P540 = "46_1261112412.85332" 
    capture_lex $P540
    new $P532, 'ExceptionHandler'
    set_addr $P532, control_531
    $P532."handle_types"(58)
    push_eh $P532
    .lex "self", self
.annotate "line", 131
    new $P533, "ResizablePMCArray"
    .lex "@kv", $P533
.annotate "line", 130
    find_lex $P534, "@kv"
.annotate "line", 132
    find_lex $P536, "self"
    defined $I537, $P536
    unless $I537, for_undef_108
    iter $P535, $P536
    new $P550, 'ExceptionHandler'
    set_addr $P550, loop549_handler
    $P550."handle_types"(65, 67, 66)
    push_eh $P550
  loop549_test:
    unless $P535, loop549_done
    shift $P538, $P535
  loop549_redo:
    .const 'Sub' $P540 = "46_1261112412.85332" 
    capture_lex $P540
    $P540($P538)
  loop549_next:
    goto loop549_test
  loop549_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P551, exception, 'type'
    eq $P551, 65, loop549_next
    eq $P551, 67, loop549_redo
  loop549_done:
    pop_eh 
  for_undef_108:
    find_lex $P552, "@kv"
.annotate "line", 130
    .return ($P552)
  control_531:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P553, exception, "payload"
    .return ($P553)
.end


.namespace ["Hash"]
.sub "_block539"  :anon :subid("46_1261112412.85332") :outer("45_1261112412.85332")
    .param pmc param_541
.annotate "line", 132
    .lex "$_", param_541
    find_lex $P542, "@kv"
    find_lex $P543, "$_"
    $P544 = $P543."key"()
    $P542."push"($P544)
    find_lex $P545, "@kv"
    find_lex $P546, "$_"
    $P547 = $P546."value"()
    $P548 = $P545."push"($P547)
    .return ($P548)
.end


.namespace ["Array"]
.sub "_block554"  :subid("47_1261112412.85332") :outer("10_1261112412.85332")
.annotate "line", 155
    .const 'Sub' $P556 = "48_1261112412.85332" 
    capture_lex $P556
.annotate "line", 168
    .const 'Sub' $P556 = "48_1261112412.85332" 
    capture_lex $P556
.annotate "line", 155
    .return ($P556)
.end


.namespace ["Array"]
.sub "reverse"  :subid("48_1261112412.85332") :method :outer("47_1261112412.85332")
.annotate "line", 168
    .const 'Sub' $P566 = "49_1261112412.85332" 
    capture_lex $P566
    new $P558, 'ExceptionHandler'
    set_addr $P558, control_557
    $P558."handle_types"(58)
    push_eh $P558
    .lex "self", self
.annotate "line", 169
    new $P559, "ResizablePMCArray"
    .lex "@reversed", $P559
.annotate "line", 168
    find_lex $P560, "@reversed"
.annotate "line", 170
    find_lex $P562, "self"
    defined $I563, $P562
    unless $I563, for_undef_109
    iter $P561, $P562
    new $P572, 'ExceptionHandler'
    set_addr $P572, loop571_handler
    $P572."handle_types"(65, 67, 66)
    push_eh $P572
  loop571_test:
    unless $P561, loop571_done
    shift $P564, $P561
  loop571_redo:
    .const 'Sub' $P566 = "49_1261112412.85332" 
    capture_lex $P566
    $P566($P564)
  loop571_next:
    goto loop571_test
  loop571_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P573, exception, 'type'
    eq $P573, 65, loop571_next
    eq $P573, 67, loop571_redo
  loop571_done:
    pop_eh 
  for_undef_109:
    find_lex $P574, "@reversed"
.annotate "line", 168
    .return ($P574)
  control_557:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P575, exception, "payload"
    .return ($P575)
.end


.namespace ["Array"]
.sub "_block565"  :anon :subid("49_1261112412.85332") :outer("48_1261112412.85332")
    .param pmc param_567
.annotate "line", 170
    .lex "$_", param_567
    find_lex $P568, "@reversed"
    find_lex $P569, "$_"
    $P570 = $P568."unshift"($P569)
    .return ($P570)
.end

