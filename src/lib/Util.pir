
.namespace []
.sub "_block11"  :anon :subid("10_1261111400.42562")
.annotate "line", 0
    .const 'Sub' $P592 = "50_1261111400.42562" 
    capture_lex $P592
    get_hll_global $P554, ["Array"], "_block553" 
    capture_lex $P554
    get_hll_global $P479, ["Hash"], "_block478" 
    capture_lex $P479
    .const 'Sub' $P445 = "38_1261111400.42562" 
    capture_lex $P445
    .const 'Sub' $P423 = "37_1261111400.42562" 
    capture_lex $P423
    .const 'Sub' $P408 = "36_1261111400.42562" 
    capture_lex $P408
    .const 'Sub' $P380 = "35_1261111400.42562" 
    capture_lex $P380
    .const 'Sub' $P353 = "33_1261111400.42562" 
    capture_lex $P353
    .const 'Sub' $P343 = "32_1261111400.42562" 
    capture_lex $P343
    .const 'Sub' $P329 = "31_1261111400.42562" 
    capture_lex $P329
    .const 'Sub' $P292 = "29_1261111400.42562" 
    capture_lex $P292
    .const 'Sub' $P260 = "27_1261111400.42562" 
    capture_lex $P260
    .const 'Sub' $P195 = "24_1261111400.42562" 
    capture_lex $P195
    .const 'Sub' $P173 = "22_1261111400.42562" 
    capture_lex $P173
    .const 'Sub' $P166 = "21_1261111400.42562" 
    capture_lex $P166
    .const 'Sub' $P141 = "19_1261111400.42562" 
    capture_lex $P141
    .const 'Sub' $P66 = "15_1261111400.42562" 
    capture_lex $P66
    .const 'Sub' $P38 = "13_1261111400.42562" 
    capture_lex $P38
    .const 'Sub' $P13 = "11_1261111400.42562" 
    capture_lex $P13
.annotate "line", 203
    .const 'Sub' $P13 = "11_1261111400.42562" 
    capture_lex $P13
    .lex "map", $P13
.annotate "line", 223
    .const 'Sub' $P38 = "13_1261111400.42562" 
    capture_lex $P38
    .lex "grep", $P38
.annotate "line", 255
    .const 'Sub' $P66 = "15_1261111400.42562" 
    capture_lex $P66
    .lex "reduce", $P66
.annotate "line", 283
    .const 'Sub' $P141 = "19_1261111400.42562" 
    capture_lex $P141
    .lex "_reduce", $P141
.annotate "line", 311
    .const 'Sub' $P166 = "21_1261111400.42562" 
    capture_lex $P166
    .lex "hash", $P166
.annotate "line", 324
    .const 'Sub' $P173 = "22_1261111400.42562" 
    capture_lex $P173
    .lex "set_from_array", $P173
.annotate "line", 364
    .const 'Sub' $P195 = "24_1261111400.42562" 
    capture_lex $P195
    .lex "find_program", $P195
.annotate "line", 393
    .const 'Sub' $P260 = "27_1261111400.42562" 
    capture_lex $P260
    .lex "mkpath", $P260
.annotate "line", 424
    .const 'Sub' $P292 = "29_1261111400.42562" 
    capture_lex $P292
    .lex "test_dir_writable", $P292
.annotate "line", 452
    .const 'Sub' $P329 = "31_1261111400.42562" 
    capture_lex $P329
    .lex "user_home_dir", $P329
.annotate "line", 478
    .const 'Sub' $P343 = "32_1261111400.42562" 
    capture_lex $P343
    .lex "run", $P343
.annotate "line", 496
    .const 'Sub' $P353 = "33_1261111400.42562" 
    capture_lex $P353
    .lex "do_run", $P353
.annotate "line", 520
    .const 'Sub' $P380 = "35_1261111400.42562" 
    capture_lex $P380
    .lex "qx", $P380
.annotate "line", 555
    .const 'Sub' $P408 = "36_1261111400.42562" 
    capture_lex $P408
    .lex "store_dynlex_safely", $P408
.annotate "line", 675
    .const 'Sub' $P423 = "37_1261111400.42562" 
    capture_lex $P423
    .lex "replace_config_strings", $P423
.annotate "line", 687
    .const 'Sub' $P445 = "38_1261111400.42562" 
    capture_lex $P445
    .lex "config_value", $P445
.annotate "line", 67
    get_hll_global $P479, ["Hash"], "_block478" 
    capture_lex $P479
    $P479()
.annotate "line", 155
    get_hll_global $P554, ["Array"], "_block553" 
    capture_lex $P554
    $P554()
    find_lex $P575, "map"
    find_lex $P576, "grep"
    find_lex $P577, "reduce"
    find_lex $P578, "_reduce"
    find_lex $P579, "hash"
    find_lex $P580, "set_from_array"
    find_lex $P581, "find_program"
    find_lex $P582, "mkpath"
    find_lex $P583, "test_dir_writable"
    find_lex $P584, "user_home_dir"
    find_lex $P585, "run"
    find_lex $P586, "do_run"
    find_lex $P587, "qx"
    find_lex $P588, "store_dynlex_safely"
.annotate "line", 609
    find_lex $P589, "replace_config_strings"
    find_lex $P590, "config_value"
.annotate "line", 1
    .return ($P590)
.end


.namespace []
.sub "" :load :init :subid("post51") :outer("10_1261111400.42562")
.annotate "line", 0
    .const 'Sub' $P12 = "10_1261111400.42562" 
    .local pmc block
    set block, $P12
.annotate "line", 609
    .const 'Sub' $P592 = "50_1261111400.42562" 
    capture_lex $P592
    $P592()
.end


.namespace []
.sub "_block591"  :anon :subid("50_1261111400.42562") :outer("10_1261111400.42562")
.annotate "line", 612
    new $P593, "Undef"
    .lex "$interp", $P593
.annotate "line", 613
    new $P594, "ResizablePMCArray"
    .lex "@argv", $P594
.annotate "line", 614
    new $P595, "Undef"
    .lex "$config", $P595
.annotate "line", 617
    new $P596, "Hash"
    .lex "%VM", $P596
.annotate "line", 610
    load_bytecode "config.pbc"
.annotate "line", 612
    getinterp $P597
    store_lex "$interp", $P597
.annotate "line", 613
    find_lex $P598, "$interp"
    unless_null $P598, vivify_52
    new $P598, "ResizablePMCArray"
  vivify_52:
    set $P599, $P598[2]
    unless_null $P599, vivify_53
    new $P599, "Undef"
  vivify_53:
    store_lex "@argv", $P599
.annotate "line", 614
    find_lex $P600, "$interp"
    unless_null $P600, vivify_54
    new $P600, "ResizablePMCArray"
  vivify_54:
    set $P601, $P600[6]
    unless_null $P601, vivify_55
    new $P601, "Undef"
  vivify_55:
    store_lex "$config", $P601
    find_lex $P602, "%VM"
.annotate "line", 618
    find_lex $P603, "$config"
    find_lex $P604, "%VM"
    unless_null $P604, vivify_56
    new $P604, "Hash"
    store_lex "%VM", $P604
  vivify_56:
    set $P604["config"], $P603
.annotate "line", 619
    find_lex $P605, "%VM"
    "store_dynlex_safely"("%*VM", $P605)
.annotate "line", 622
    find_lex $P607, "@argv"
    if $P607, unless_606_end
    find_lex $P608, "@argv"
    $P608."unshift"("<anonymous>")
  unless_606_end:
.annotate "line", 623
    find_lex $P609, "@argv"
    $P610 = $P609."shift"()
    "store_dynlex_safely"("$*PROGRAM_NAME", $P610)
.annotate "line", 624
    find_lex $P611, "@argv"
    "store_dynlex_safely"("@*ARGS", $P611)
.annotate "line", 627
    interpinfo $S612, 19
    "store_dynlex_safely"("$*EXECUTABLE_NAME", $S612)
.annotate "line", 630
    sysinfo $S613, 4
    "store_dynlex_safely"("$*OSNAME", $S613)
.annotate "line", 631
    sysinfo $S614, 5
    "store_dynlex_safely"("%*OSVER", $S614)
.annotate "line", 634
    new $P615, "ResizablePMCArray"
    push $P615, "parrot"
    push $P615, "Env"
    root_new $P616, $P615
    "store_dynlex_safely"("%*ENV", $P616)
.annotate "line", 635
    new $P617, "ResizablePMCArray"
    push $P617, "parrot"
    push $P617, "OS"
    root_new $P618, $P617
    $P619 = "store_dynlex_safely"("$*OS", $P618)
.annotate "line", 609
    .return ($P619)
.end


.namespace []
.sub "map"  :subid("11_1261111400.42562") :outer("10_1261111400.42562")
    .param pmc param_16
    .param pmc param_17
.annotate "line", 203
    .const 'Sub' $P25 = "12_1261111400.42562" 
    capture_lex $P25
    new $P15, 'ExceptionHandler'
    set_addr $P15, control_14
    $P15."handle_types"(58)
    push_eh $P15
    .lex "&code", param_16
    .lex "@originals", param_17
.annotate "line", 204
    new $P18, "ResizablePMCArray"
    .lex "@mapped", $P18
.annotate "line", 203
    find_lex $P19, "@mapped"
.annotate "line", 206
    find_lex $P21, "@originals"
    defined $I22, $P21
    unless $I22, for_undef_57
    iter $P20, $P21
    new $P33, 'ExceptionHandler'
    set_addr $P33, loop32_handler
    $P33."handle_types"(65, 67, 66)
    push_eh $P33
  loop32_test:
    unless $P20, loop32_done
    shift $P23, $P20
  loop32_redo:
    .const 'Sub' $P25 = "12_1261111400.42562" 
    capture_lex $P25
    $P25($P23)
  loop32_next:
    goto loop32_test
  loop32_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P34, exception, 'type'
    eq $P34, 65, loop32_next
    eq $P34, 67, loop32_redo
  loop32_done:
    pop_eh 
  for_undef_57:
.annotate "line", 210
    new $P35, "Exception"
    set $P35['type'], 58
    find_lex $P36, "@mapped"
    setattribute $P35, 'payload', $P36
    throw $P35
.annotate "line", 203
    .return ()
  control_14:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P37, exception, "payload"
    .return ($P37)
.end


.namespace []
.sub "_block24"  :anon :subid("12_1261111400.42562") :outer("11_1261111400.42562")
    .param pmc param_26
.annotate "line", 206
    .lex "$_", param_26
.annotate "line", 207
    find_lex $P27, "@mapped"
    find_lex $P28, "&code"
    find_lex $P29, "$_"
    $P30 = $P28($P29)
    $P31 = $P27."push"($P30)
.annotate "line", 206
    .return ($P31)
.end


.namespace []
.sub "grep"  :subid("13_1261111400.42562") :outer("10_1261111400.42562")
    .param pmc param_41
    .param pmc param_42
.annotate "line", 223
    .const 'Sub' $P50 = "14_1261111400.42562" 
    capture_lex $P50
    new $P40, 'ExceptionHandler'
    set_addr $P40, control_39
    $P40."handle_types"(58)
    push_eh $P40
    .lex "&code", param_41
    .lex "@all", param_42
.annotate "line", 224
    new $P43, "ResizablePMCArray"
    .lex "@matches", $P43
.annotate "line", 223
    find_lex $P44, "@matches"
.annotate "line", 226
    find_lex $P46, "@all"
    defined $I47, $P46
    unless $I47, for_undef_58
    iter $P45, $P46
    new $P61, 'ExceptionHandler'
    set_addr $P61, loop60_handler
    $P61."handle_types"(65, 67, 66)
    push_eh $P61
  loop60_test:
    unless $P45, loop60_done
    shift $P48, $P45
  loop60_redo:
    .const 'Sub' $P50 = "14_1261111400.42562" 
    capture_lex $P50
    $P50($P48)
  loop60_next:
    goto loop60_test
  loop60_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P62, exception, 'type'
    eq $P62, 65, loop60_next
    eq $P62, 67, loop60_redo
  loop60_done:
    pop_eh 
  for_undef_58:
.annotate "line", 230
    new $P63, "Exception"
    set $P63['type'], 58
    find_lex $P64, "@matches"
    setattribute $P63, 'payload', $P64
    throw $P63
.annotate "line", 223
    .return ()
  control_39:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P65, exception, "payload"
    .return ($P65)
.end


.namespace []
.sub "_block49"  :anon :subid("14_1261111400.42562") :outer("13_1261111400.42562")
    .param pmc param_51
.annotate "line", 226
    .lex "$_", param_51
.annotate "line", 227
    find_lex $P54, "&code"
    find_lex $P55, "$_"
    $P56 = $P54($P55)
    if $P56, if_53
    set $P52, $P56
    goto if_53_end
  if_53:
    find_lex $P57, "@matches"
    find_lex $P58, "$_"
    $P59 = $P57."push"($P58)
    set $P52, $P59
  if_53_end:
.annotate "line", 226
    .return ($P52)
.end


.namespace []
.sub "reduce"  :subid("15_1261111400.42562") :outer("10_1261111400.42562")
    .param pmc param_69
    .param pmc param_70
    .param pmc param_71 :slurpy
.annotate "line", 255
    .const 'Sub' $P93 = "16_1261111400.42562" 
    capture_lex $P93
    new $P68, 'ExceptionHandler'
    set_addr $P68, control_67
    $P68."handle_types"(58)
    push_eh $P68
    .lex "&code", param_69
    .lex "@array", param_70
    .lex "@initial", param_71
.annotate "line", 256
    new $P72, "Undef"
    .lex "$init_elems", $P72
    find_lex $P73, "@initial"
    elements $I74, $P73
    new $P75, 'Integer'
    set $P75, $I74
    store_lex "$init_elems", $P75
.annotate "line", 257
    find_lex $P78, "$init_elems"
    set $N79, $P78
    isgt $I80, $N79, 1.0
    if $I80, if_77
.annotate "line", 260
    find_lex $P83, "$init_elems"
    set $N84, $P83
    iseq $I85, $N84, 1.0
    if $I85, if_82
.annotate "line", 263
    .const 'Sub' $P93 = "16_1261111400.42562" 
    capture_lex $P93
    $P139 = $P93()
    set $P81, $P139
.annotate "line", 260
    goto if_82_end
  if_82:
.annotate "line", 261
    new $P86, "Exception"
    set $P86['type'], 58
    find_lex $P87, "&code"
    find_lex $P88, "@array"
    find_lex $P89, "@initial"
    unless_null $P89, vivify_65
    new $P89, "ResizablePMCArray"
  vivify_65:
    set $P90, $P89[0]
    unless_null $P90, vivify_66
    new $P90, "Undef"
  vivify_66:
    $P91 = "_reduce"($P87, $P88, $P90)
    setattribute $P86, 'payload', $P91
    throw $P86
  if_82_end:
.annotate "line", 260
    set $P76, $P81
.annotate "line", 257
    goto if_77_end
  if_77:
.annotate "line", 258
    die "Only one initial value allowed in reduce()"
  if_77_end:
.annotate "line", 255
    .return ($P76)
  control_67:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P140, exception, "payload"
    .return ($P140)
.end


.namespace []
.sub "_block92"  :anon :subid("16_1261111400.42562") :outer("15_1261111400.42562")
.annotate "line", 263
    .const 'Sub' $P118 = "18_1261111400.42562" 
    capture_lex $P118
    .const 'Sub' $P104 = "17_1261111400.42562" 
    capture_lex $P104
.annotate "line", 264
    new $P94, "Undef"
    .lex "$array_elems", $P94
    find_lex $P95, "@array"
    elements $I96, $P95
    new $P97, 'Integer'
    set $P97, $I96
    store_lex "$array_elems", $P97
.annotate "line", 265
    find_lex $P100, "$array_elems"
    set $N101, $P100
    iseq $I102, $N101, 0.0
    if $I102, if_99
.annotate "line", 268
    find_lex $P111, "$array_elems"
    set $N112, $P111
    iseq $I113, $N112, 1.0
    if $I113, if_110
.annotate "line", 271
    .const 'Sub' $P118 = "18_1261111400.42562" 
    capture_lex $P118
    $P138 = $P118()
    set $P109, $P138
.annotate "line", 268
    goto if_110_end
  if_110:
.annotate "line", 269
    new $P114, "Exception"
    set $P114['type'], 58
    find_lex $P115, "@array"
    unless_null $P115, vivify_63
    new $P115, "ResizablePMCArray"
  vivify_63:
    set $P116, $P115[0]
    unless_null $P116, vivify_64
    new $P116, "Undef"
  vivify_64:
    setattribute $P114, 'payload', $P116
    throw $P114
  if_110_end:
.annotate "line", 268
    set $P98, $P109
.annotate "line", 265
    goto if_99_end
  if_99:
    .const 'Sub' $P104 = "17_1261111400.42562" 
    capture_lex $P104
    $P108 = $P104()
    set $P98, $P108
  if_99_end:
.annotate "line", 263
    .return ($P98)
.end


.namespace []
.sub "_block117"  :anon :subid("18_1261111400.42562") :outer("16_1261111400.42562")
.annotate "line", 272
    new $P119, "Undef"
    .lex "$initial", $P119
.annotate "line", 273
    new $P120, "Undef"
    .lex "$iter", $P120
.annotate "line", 272
    find_lex $P121, "&code"
    find_lex $P122, "@array"
    unless_null $P122, vivify_59
    new $P122, "ResizablePMCArray"
  vivify_59:
    set $P123, $P122[0]
    unless_null $P123, vivify_60
    new $P123, "Undef"
  vivify_60:
    find_lex $P124, "@array"
    unless_null $P124, vivify_61
    new $P124, "ResizablePMCArray"
  vivify_61:
    set $P125, $P124[1]
    unless_null $P125, vivify_62
    new $P125, "Undef"
  vivify_62:
    $P126 = $P121($P123, $P125)
    store_lex "$initial", $P126
.annotate "line", 273
    find_lex $P127, "@array"
    iter $P128, $P127
    store_lex "$iter", $P128
.annotate "line", 275
    find_lex $P129, "$iter"
    shift $P130, $P129
.annotate "line", 276
    find_lex $P131, "$iter"
    shift $P132, $P131
.annotate "line", 278
    new $P133, "Exception"
    set $P133['type'], 58
    find_lex $P134, "&code"
    find_lex $P135, "$iter"
    find_lex $P136, "$initial"
    $P137 = "_reduce"($P134, $P135, $P136)
    setattribute $P133, 'payload', $P137
    throw $P133
.annotate "line", 271
    .return ()
.end


.namespace []
.sub "_block103"  :anon :subid("17_1261111400.42562") :outer("16_1261111400.42562")
.annotate "line", 266
    new $P105, "Undef"
    .lex "$undef", $P105
    new $P106, "Exception"
    set $P106['type'], 58
    find_lex $P107, "$undef"
    setattribute $P106, 'payload', $P107
    throw $P106
.annotate "line", 265
    .return ()
.end


.namespace []
.sub "_reduce"  :subid("19_1261111400.42562") :outer("10_1261111400.42562")
    .param pmc param_144
    .param pmc param_145
    .param pmc param_146
.annotate "line", 283
    .const 'Sub' $P154 = "20_1261111400.42562" 
    capture_lex $P154
    new $P143, 'ExceptionHandler'
    set_addr $P143, control_142
    $P143."handle_types"(58)
    push_eh $P143
    .lex "&code", param_144
    .lex "$iter", param_145
    .lex "$initial", param_146
.annotate "line", 284
    new $P147, "Undef"
    .lex "$result", $P147
    find_lex $P148, "$initial"
    store_lex "$result", $P148
.annotate "line", 286
    find_lex $P150, "$iter"
    defined $I151, $P150
    unless $I151, for_undef_67
    iter $P149, $P150
    new $P161, 'ExceptionHandler'
    set_addr $P161, loop160_handler
    $P161."handle_types"(65, 67, 66)
    push_eh $P161
  loop160_test:
    unless $P149, loop160_done
    shift $P152, $P149
  loop160_redo:
    .const 'Sub' $P154 = "20_1261111400.42562" 
    capture_lex $P154
    $P154($P152)
  loop160_next:
    goto loop160_test
  loop160_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P162, exception, 'type'
    eq $P162, 65, loop160_next
    eq $P162, 67, loop160_redo
  loop160_done:
    pop_eh 
  for_undef_67:
.annotate "line", 290
    new $P163, "Exception"
    set $P163['type'], 58
    find_lex $P164, "$result"
    setattribute $P163, 'payload', $P164
    throw $P163
.annotate "line", 283
    .return ()
  control_142:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P165, exception, "payload"
    .return ($P165)
.end


.namespace []
.sub "_block153"  :anon :subid("20_1261111400.42562") :outer("19_1261111400.42562")
    .param pmc param_155
.annotate "line", 286
    .lex "$_", param_155
.annotate "line", 287
    find_lex $P156, "&code"
    find_lex $P157, "$result"
    find_lex $P158, "$_"
    $P159 = $P156($P157, $P158)
    store_lex "$result", $P159
.annotate "line", 286
    .return ($P159)
.end


.namespace []
.sub "hash"  :subid("21_1261111400.42562") :outer("10_1261111400.42562")
    .param pmc param_169 :slurpy :named
.annotate "line", 311
    new $P168, 'ExceptionHandler'
    set_addr $P168, control_167
    $P168."handle_types"(58)
    push_eh $P168
    .lex "%h", param_169
    new $P170, "Exception"
    set $P170['type'], 58
    find_lex $P171, "%h"
    setattribute $P170, 'payload', $P171
    throw $P170
    .return ()
  control_167:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P172, exception, "payload"
    .return ($P172)
.end


.namespace []
.sub "set_from_array"  :subid("22_1261111400.42562") :outer("10_1261111400.42562")
    .param pmc param_176
.annotate "line", 324
    .const 'Sub' $P184 = "23_1261111400.42562" 
    capture_lex $P184
    new $P175, 'ExceptionHandler'
    set_addr $P175, control_174
    $P175."handle_types"(58)
    push_eh $P175
    .lex "@array", param_176
.annotate "line", 325
    new $P177, "Hash"
    .lex "%set", $P177
.annotate "line", 324
    find_lex $P178, "%set"
.annotate "line", 327
    find_lex $P180, "@array"
    defined $I181, $P180
    unless $I181, for_undef_68
    iter $P179, $P180
    new $P190, 'ExceptionHandler'
    set_addr $P190, loop189_handler
    $P190."handle_types"(65, 67, 66)
    push_eh $P190
  loop189_test:
    unless $P179, loop189_done
    shift $P182, $P179
  loop189_redo:
    .const 'Sub' $P184 = "23_1261111400.42562" 
    capture_lex $P184
    $P184($P182)
  loop189_next:
    goto loop189_test
  loop189_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P191, exception, 'type'
    eq $P191, 65, loop189_next
    eq $P191, 67, loop189_redo
  loop189_done:
    pop_eh 
  for_undef_68:
.annotate "line", 331
    new $P192, "Exception"
    set $P192['type'], 58
    find_lex $P193, "%set"
    setattribute $P192, 'payload', $P193
    throw $P192
.annotate "line", 324
    .return ()
  control_174:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P194, exception, "payload"
    .return ($P194)
.end


.namespace []
.sub "_block183"  :anon :subid("23_1261111400.42562") :outer("22_1261111400.42562")
    .param pmc param_185
.annotate "line", 327
    .lex "$_", param_185
.annotate "line", 328
    new $P186, "Integer"
    assign $P186, 1
    find_lex $P187, "$_"
    find_lex $P188, "%set"
    unless_null $P188, vivify_69
    new $P188, "Hash"
    store_lex "%set", $P188
  vivify_69:
    set $P188[$P187], $P186
.annotate "line", 327
    .return ($P186)
.end


.namespace []
.sub "find_program"  :subid("24_1261111400.42562") :outer("10_1261111400.42562")
    .param pmc param_198
.annotate "line", 364
    .const 'Sub' $P227 = "25_1261111400.42562" 
    capture_lex $P227
    new $P197, 'ExceptionHandler'
    set_addr $P197, control_196
    $P197."handle_types"(58)
    push_eh $P197
    .lex "$program", param_198
.annotate "line", 365
    new $P199, "Undef"
    .lex "$path_sep", $P199
.annotate "line", 366
    new $P200, "ResizablePMCArray"
    .lex "@paths", $P200
.annotate "line", 367
    new $P201, "ResizablePMCArray"
    .lex "@exts", $P201
.annotate "line", 365
    find_dynamic_lex $P204, "$*OSNAME"
    unless_null $P204, vivify_70
    get_hll_global $P204, "$OSNAME"
    unless_null $P204, vivify_71
    die "Contextual $*OSNAME not found"
  vivify_71:
  vivify_70:
    set $S205, $P204
    iseq $I206, $S205, "MSWin32"
    if $I206, if_203
    new $P208, "String"
    assign $P208, ":"
    set $P202, $P208
    goto if_203_end
  if_203:
    new $P207, "String"
    assign $P207, ";"
    set $P202, $P207
  if_203_end:
    store_lex "$path_sep", $P202
.annotate "line", 366
    find_lex $P209, "$path_sep"
    set $S210, $P209
    find_dynamic_lex $P211, "%*ENV"
    unless_null $P211, vivify_72
    get_hll_global $P211, "%ENV"
    unless_null $P211, vivify_73
    die "Contextual %*ENV not found"
  vivify_73:
  vivify_72:
    set $P212, $P211["PATH"]
    unless_null $P212, vivify_74
    new $P212, "Undef"
  vivify_74:
    set $S213, $P212
    split $P214, $S210, $S213
    store_lex "@paths", $P214
.annotate "line", 367
    find_lex $P215, "$path_sep"
    set $S216, $P215
    find_dynamic_lex $P217, "%*ENV"
    unless_null $P217, vivify_75
    get_hll_global $P217, "%ENV"
    unless_null $P217, vivify_76
    die "Contextual %*ENV not found"
  vivify_76:
  vivify_75:
    set $P218, $P217["PATHEXT"]
    unless_null $P218, vivify_77
    new $P218, "Undef"
  vivify_77:
    set $S219, $P218
    split $P220, $S216, $S219
    store_lex "@exts", $P220
.annotate "line", 369
    find_lex $P221, "@exts"
    $P221."unshift"("")
.annotate "line", 371
    find_lex $P223, "@paths"
    defined $I224, $P223
    unless $I224, for_undef_78
    iter $P222, $P223
    new $P255, 'ExceptionHandler'
    set_addr $P255, loop254_handler
    $P255."handle_types"(65, 67, 66)
    push_eh $P255
  loop254_test:
    unless $P222, loop254_done
    shift $P225, $P222
  loop254_redo:
    .const 'Sub' $P227 = "25_1261111400.42562" 
    capture_lex $P227
    $P227($P225)
  loop254_next:
    goto loop254_test
  loop254_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P256, exception, 'type'
    eq $P256, 65, loop254_next
    eq $P256, 67, loop254_redo
  loop254_done:
    pop_eh 
  for_undef_78:
.annotate "line", 380
    new $P257, "Exception"
    set $P257['type'], 58
    new $P258, "String"
    assign $P258, ""
    setattribute $P257, 'payload', $P258
    throw $P257
.annotate "line", 364
    .return ()
  control_196:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P259, exception, "payload"
    .return ($P259)
.end


.namespace []
.sub "_block226"  :anon :subid("25_1261111400.42562") :outer("24_1261111400.42562")
    .param pmc param_228
.annotate "line", 371
    .const 'Sub' $P239 = "26_1261111400.42562" 
    capture_lex $P239
    .lex "$dir", param_228
.annotate "line", 372
    new $P229, "Undef"
    .lex "$path", $P229
    find_lex $P230, "$dir"
    new $P231, "ResizablePMCArray"
    push $P231, $P230
    find_lex $P232, "$program"
    $P233 = "fscat"($P231, $P232)
    store_lex "$path", $P233
.annotate "line", 374
    find_lex $P235, "@exts"
    defined $I236, $P235
    unless $I236, for_undef_79
    iter $P234, $P235
    new $P252, 'ExceptionHandler'
    set_addr $P252, loop251_handler
    $P252."handle_types"(65, 67, 66)
    push_eh $P252
  loop251_test:
    unless $P234, loop251_done
    shift $P237, $P234
  loop251_redo:
    .const 'Sub' $P239 = "26_1261111400.42562" 
    capture_lex $P239
    $P239($P237)
  loop251_next:
    goto loop251_test
  loop251_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P253, exception, 'type'
    eq $P253, 65, loop251_next
    eq $P253, 67, loop251_redo
  loop251_done:
    pop_eh 
  for_undef_79:
.annotate "line", 371
    .return ($P234)
.end


.namespace []
.sub "_block238"  :anon :subid("26_1261111400.42562") :outer("25_1261111400.42562")
    .param pmc param_240
.annotate "line", 374
    .lex "$ext", param_240
.annotate "line", 375
    new $P241, "Undef"
    .lex "$pathext", $P241
    find_lex $P242, "$path"
    find_lex $P243, "$ext"
    concat $P244, $P242, $P243
    store_lex "$pathext", $P244
.annotate "line", 376
    find_lex $P247, "$pathext"
    $P248 = "path_exists"($P247)
    if $P248, if_246
    set $P245, $P248
    goto if_246_end
  if_246:
    new $P249, "Exception"
    set $P249['type'], 58
    find_lex $P250, "$pathext"
    setattribute $P249, 'payload', $P250
    throw $P249
  if_246_end:
.annotate "line", 374
    .return ($P245)
.end


.namespace []
.sub "mkpath"  :subid("27_1261111400.42562") :outer("10_1261111400.42562")
    .param pmc param_263
.annotate "line", 393
    .const 'Sub' $P276 = "28_1261111400.42562" 
    capture_lex $P276
    new $P262, 'ExceptionHandler'
    set_addr $P262, control_261
    $P262."handle_types"(58)
    push_eh $P262
    .lex "$path", param_263
.annotate "line", 394
    new $P264, "ResizablePMCArray"
    .lex "@path", $P264
.annotate "line", 395
    new $P265, "Undef"
    .lex "$cur", $P265
.annotate "line", 394
    find_lex $P266, "$path"
    set $S267, $P266
    split $P268, "/", $S267
    store_lex "@path", $P268
.annotate "line", 395
    find_lex $P269, "@path"
    $P270 = $P269."shift"()
    store_lex "$cur", $P270
.annotate "line", 397
    find_lex $P272, "@path"
    defined $I273, $P272
    unless $I273, for_undef_80
    iter $P271, $P272
    new $P289, 'ExceptionHandler'
    set_addr $P289, loop288_handler
    $P289."handle_types"(65, 67, 66)
    push_eh $P289
  loop288_test:
    unless $P271, loop288_done
    shift $P274, $P271
  loop288_redo:
    .const 'Sub' $P276 = "28_1261111400.42562" 
    capture_lex $P276
    $P276($P274)
  loop288_next:
    goto loop288_test
  loop288_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P290, exception, 'type'
    eq $P290, 65, loop288_next
    eq $P290, 67, loop288_redo
  loop288_done:
    pop_eh 
  for_undef_80:
.annotate "line", 393
    .return ($P271)
  control_261:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P291, exception, "payload"
    .return ($P291)
.end


.namespace []
.sub "_block275"  :anon :subid("28_1261111400.42562") :outer("27_1261111400.42562")
    .param pmc param_277
.annotate "line", 397
    .lex "$dir", param_277
.annotate "line", 398
    find_lex $P278, "$cur"
    find_lex $P279, "$dir"
    new $P280, "ResizablePMCArray"
    push $P280, $P278
    push $P280, $P279
    $P281 = "fscat"($P280)
    store_lex "$cur", $P281
.annotate "line", 400
    find_lex $P284, "$cur"
    $P285 = "path_exists"($P284)
    unless $P285, unless_283
    set $P282, $P285
    goto unless_283_end
  unless_283:
.annotate "line", 401
    find_lex $P286, "$cur"
    $P287 = "mkdir"($P286)
.annotate "line", 400
    set $P282, $P287
  unless_283_end:
.annotate "line", 397
    .return ($P282)
.end


.namespace []
.sub "test_dir_writable"  :subid("29_1261111400.42562") :outer("10_1261111400.42562")
    .param pmc param_295
.annotate "line", 424
    .const 'Sub' $P308 = "30_1261111400.42562" 
    capture_lex $P308
    new $P294, 'ExceptionHandler'
    set_addr $P294, control_293
    $P294."handle_types"(58)
    push_eh $P294
    .lex "$dir", param_295
.annotate "line", 425
    new $P296, "Undef"
    .lex "$test_file", $P296
    find_lex $P297, "$dir"
    new $P298, "ResizablePMCArray"
    push $P298, $P297
    $P299 = "fscat"($P298, "WrItAbLe.UtL")
    store_lex "$test_file", $P299
.annotate "line", 428
    find_lex $P301, "$test_file"
    $P302 = "path_exists"($P301)
    unless $P302, if_300_end
.annotate "line", 427
    new $P303, 'String'
    set $P303, "Test file '"
    find_lex $P304, "$test_file"
    concat $P305, $P303, $P304
    concat $P306, $P305, "'\nthat should never exist already does."
    die $P306
  if_300_end:
.annotate "line", 430
    .const 'Sub' $P308 = "30_1261111400.42562" 
    capture_lex $P308
    $P308()
.annotate "line", 434
    find_lex $P320, "$test_file"
    $P321 = "path_exists"($P320)
    if $P321, if_319
.annotate "line", 439
    new $P326, "Exception"
    set $P326['type'], 58
    new $P327, "Integer"
    assign $P327, 0
    setattribute $P326, 'payload', $P327
    throw $P326
.annotate "line", 438
    goto if_319_end
  if_319:
.annotate "line", 435
    find_dynamic_lex $P322, "$*OS"
    unless_null $P322, vivify_81
    get_hll_global $P322, "$OS"
    unless_null $P322, vivify_82
    die "Contextual $*OS not found"
  vivify_82:
  vivify_81:
    find_lex $P323, "$test_file"
    $P322."rm"($P323)
.annotate "line", 436
    new $P324, "Exception"
    set $P324['type'], 58
    new $P325, "Integer"
    assign $P325, 1
    setattribute $P324, 'payload', $P325
    throw $P324
  if_319_end:
.annotate "line", 424
    .return ($P318)
  control_293:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P328, exception, "payload"
    .return ($P328)
.end


.namespace []
.sub "_block307"  :anon :subid("30_1261111400.42562") :outer("29_1261111400.42562")
.annotate "line", 430
    new $P313, 'ExceptionHandler'
    set_addr $P313, control_312
    $P313."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P313
.annotate "line", 431
    find_lex $P309, "$test_file"
    $P310 = "spew"($P309, "test_dir_writable() test file.\n")
.annotate "line", 430
    pop_eh 
    goto skip_handler_311
  control_312:
    .local pmc exception 
    .get_results (exception) 
    new $P316, 'Integer'
    set $P316, 1
    set exception["handled"], $P316
    set $I317, exception["handled"]
    ne $I317, 1, nothandled_315
  handled_314:
    .return (exception)
  nothandled_315:
    rethrow exception
  skip_handler_311:
    .return ($P310)
.end


.namespace []
.sub "user_home_dir"  :subid("31_1261111400.42562") :outer("10_1261111400.42562")
.annotate "line", 452
    new $P331, 'ExceptionHandler'
    set_addr $P331, control_330
    $P331."handle_types"(58)
    push_eh $P331
.annotate "line", 453
    new $P332, "Exception"
    set $P332['type'], 58
    find_dynamic_lex $P334, "%*ENV"
    unless_null $P334, vivify_83
    get_hll_global $P334, "%ENV"
    unless_null $P334, vivify_84
    die "Contextual %*ENV not found"
  vivify_84:
  vivify_83:
    set $P335, $P334["HOMEDRIVE"]
    unless_null $P335, vivify_85
    new $P335, "Undef"
  vivify_85:
    set $P333, $P335
    defined $I337, $P333
    if $I337, default_336
    new $P338, "String"
    assign $P338, ""
    set $P333, $P338
  default_336:
    find_dynamic_lex $P339, "%*ENV"
    unless_null $P339, vivify_86
    get_hll_global $P339, "%ENV"
    unless_null $P339, vivify_87
    die "Contextual %*ENV not found"
  vivify_87:
  vivify_86:
    set $P340, $P339["HOME"]
    unless_null $P340, vivify_88
    new $P340, "Undef"
  vivify_88:
    concat $P341, $P333, $P340
    setattribute $P332, 'payload', $P341
    throw $P332
.annotate "line", 452
    .return ()
  control_330:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P342, exception, "payload"
    .return ($P342)
.end


.namespace []
.sub "run"  :subid("32_1261111400.42562") :outer("10_1261111400.42562")
    .param pmc param_346 :slurpy
.annotate "line", 478
    new $P345, 'ExceptionHandler'
    set_addr $P345, control_344
    $P345."handle_types"(58)
    push_eh $P345
    .lex "@command_and_args", param_346
.annotate "line", 479
    new $P347, "Exception"
    set $P347['type'], 58
    find_lex $P348, "@command_and_args"
    spawnw $I349, $P348
    new $P350, 'Integer'
    set $P350, $I349
    shr $P351, $P350, 8
    setattribute $P347, 'payload', $P351
    throw $P347
.annotate "line", 478
    .return ()
  control_344:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P352, exception, "payload"
    .return ($P352)
.end


.namespace []
.sub "do_run"  :subid("33_1261111400.42562") :outer("10_1261111400.42562")
    .param pmc param_356 :slurpy
.annotate "line", 496
    .const 'Sub' $P372 = "34_1261111400.42562" 
    capture_lex $P372
    new $P355, 'ExceptionHandler'
    set_addr $P355, control_354
    $P355."handle_types"(58)
    push_eh $P355
    new $P368, 'ExceptionHandler'
    set_addr $P368, control_367
    $P368."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P368
    .lex "@command_and_args", param_356
.annotate "line", 497
    find_lex $P357, "@command_and_args"
    join $S358, " ", $P357
    "say"($S358)
.annotate "line", 499
    new $P359, "Exception"
    set $P359['type'], 58
    find_lex $P362, "@command_and_args"
    spawnw $I363, $P362
    if $I363, if_361
    new $P365, "Integer"
    assign $P365, 1
    set $P360, $P365
    goto if_361_end
  if_361:
    new $P364, "Integer"
    assign $P364, 0
    set $P360, $P364
  if_361_end:
    setattribute $P359, 'payload', $P360
    throw $P359
.annotate "line", 496
    pop_eh 
    goto skip_handler_366
  control_367:
.annotate "line", 501
    .local pmc exception 
    .get_results (exception) 
    .const 'Sub' $P372 = "34_1261111400.42562" 
    capture_lex $P372
    $P372(exception)
    new $P377, 'Integer'
    set $P377, 1
    set exception["handled"], $P377
    set $I378, exception["handled"]
    ne $I378, 1, nothandled_370
  handled_369:
    .return (exception)
  nothandled_370:
    rethrow exception
  skip_handler_366:
.annotate "line", 496
    .return ()
  control_354:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P379, exception, "payload"
    .return ($P379)
.end


.namespace []
.sub "_block371"  :anon :subid("34_1261111400.42562") :outer("33_1261111400.42562")
    .param pmc param_373
.annotate "line", 501
    .lex "$_", param_373
    find_lex $P374, "$_"
    .lex "$!", $P374
.annotate "line", 502
    new $P375, "Exception"
    set $P375['type'], 58
    new $P376, "Integer"
    assign $P376, -1
    setattribute $P375, 'payload', $P376
    throw $P375
.annotate "line", 501
    .return ()
.end


.namespace []
.sub "qx"  :subid("35_1261111400.42562") :outer("10_1261111400.42562")
    .param pmc param_383 :slurpy
.annotate "line", 520
    new $P382, 'ExceptionHandler'
    set_addr $P382, control_381
    $P382."handle_types"(58)
    push_eh $P382
    .lex "@command_and_args", param_383
.annotate "line", 521
    new $P384, "Undef"
    .lex "$cmd", $P384
.annotate "line", 522
    new $P385, "Undef"
    .lex "$pipe", $P385
.annotate "line", 526
    new $P386, "Undef"
    .lex "$output", $P386
.annotate "line", 521
    find_lex $P387, "@command_and_args"
    join $S388, " ", $P387
    new $P389, 'String'
    set $P389, $S388
    store_lex "$cmd", $P389
.annotate "line", 522
    find_lex $P390, "$cmd"
    set $S391, $P390
    open $P392, $S391, "rp"
    store_lex "$pipe", $P392
.annotate "line", 523
    find_lex $P394, "$pipe"
    if $P394, unless_393_end
    new $P395, 'String'
    set $P395, "Unable to execute '"
    find_lex $P396, "$cmd"
    concat $P397, $P395, $P396
    concat $P398, $P397, "'"
    die $P398
  unless_393_end:
.annotate "line", 525
    find_lex $P399, "$pipe"
    $P399."encoding"("utf8")
.annotate "line", 526
    find_lex $P400, "$pipe"
    $P401 = $P400."readall"()
    store_lex "$output", $P401
.annotate "line", 527
    find_lex $P402, "$pipe"
    $P402."close"()
.annotate "line", 529
    find_lex $P403, "$pipe"
    $P404 = $P403."exit_status"()
    "store_dynlex_safely"("$!", $P404)
.annotate "line", 531
    new $P405, "Exception"
    set $P405['type'], 58
    find_lex $P406, "$output"
    setattribute $P405, 'payload', $P406
    throw $P405
.annotate "line", 520
    .return ()
  control_381:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P407, exception, "payload"
    .return ($P407)
.end


.namespace []
.sub "store_dynlex_safely"  :subid("36_1261111400.42562") :outer("10_1261111400.42562")
    .param pmc param_411
    .param pmc param_412
.annotate "line", 555
    new $P410, 'ExceptionHandler'
    set_addr $P410, control_409
    $P410."handle_types"(58)
    push_eh $P410
    .lex "$var_name", param_411
    .lex "$value", param_412
.annotate "line", 557
    find_lex $P415, "$var_name"
    set $S416, $P415
    find_dynamic_lex $P417, $S416
    isnull $I418, $P417
    unless $I418, unless_414
    new $P413, 'Integer'
    set $P413, $I418
    goto unless_414_end
  unless_414:
.annotate "line", 556
    find_lex $P419, "$var_name"
    set $S420, $P419
    find_lex $P421, "$value"
    store_dynamic_lex $S420, $P421
  unless_414_end:
.annotate "line", 555
    .return ($P413)
  control_409:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P422, exception, "payload"
    .return ($P422)
.end


.namespace []
.sub "replace_config_strings"  :subid("37_1261111400.42562") :outer("10_1261111400.42562")
    .param pmc param_426
.annotate "line", 675
    new $P425, 'ExceptionHandler'
    set_addr $P425, control_424
    $P425."handle_types"(58)
    push_eh $P425
    .lex "$original", param_426
.annotate "line", 676
    new $P427, "Undef"
    .lex "$new", $P427
    find_lex $P428, "$original"
    store_lex "$new", $P428
.annotate "line", 678
    new $P440, 'ExceptionHandler'
    set_addr $P440, loop439_handler
    $P440."handle_types"(65, 67, 66)
    push_eh $P440
    goto loop439_redo
  loop439_test:
.annotate "line", 682
    find_lex $P429, "$new"
    set $S430, $P429
    find_lex $P431, "$original"
    set $S432, $P431
    isne $I433, $S430, $S432
    unless $I433, loop439_done
  loop439_redo:
.annotate "line", 679
    find_lex $P434, "$new"
    store_lex "$original", $P434
.annotate "line", 680
    find_lex $P435, "$original"
    $P436 = "rx"("\\#<ident>\\#")
    get_hll_global $P437, "config_value"
    $P438 = "subst"($P435, $P436, $P437)
    store_lex "$new", $P438
  loop439_next:
.annotate "line", 678
    goto loop439_test
  loop439_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P441, exception, 'type'
    eq $P441, 65, loop439_next
    eq $P441, 67, loop439_redo
  loop439_done:
    pop_eh 
.annotate "line", 684
    new $P442, "Exception"
    set $P442['type'], 58
    find_lex $P443, "$new"
    setattribute $P442, 'payload', $P443
    throw $P442
.annotate "line", 675
    .return ()
  control_424:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P444, exception, "payload"
    .return ($P444)
.end


.namespace []
.sub "config_value"  :subid("38_1261111400.42562") :outer("10_1261111400.42562")
    .param pmc param_448
.annotate "line", 687
    new $P447, 'ExceptionHandler'
    set_addr $P447, control_446
    $P447."handle_types"(58)
    push_eh $P447
    .lex "$match", param_448
.annotate "line", 688
    new $P449, "Undef"
    .lex "$key", $P449
.annotate "line", 689
    new $P450, "Undef"
    .lex "$config", $P450
.annotate "line", 688
    find_lex $P451, "$match"
    unless_null $P451, vivify_89
    new $P451, "Hash"
  vivify_89:
    set $P452, $P451["ident"]
    unless_null $P452, vivify_90
    new $P452, "Undef"
  vivify_90:
    store_lex "$key", $P452
.annotate "line", 690
    find_lex $P461, "$key"
    find_dynamic_lex $P462, "%*CONF"
    unless_null $P462, vivify_91
    get_hll_global $P462, "%CONF"
    unless_null $P462, vivify_92
    die "Contextual %*CONF not found"
  vivify_92:
  vivify_91:
    set $P463, $P462[$P461]
    unless_null $P463, vivify_93
    new $P463, "Undef"
  vivify_93:
    unless $P463, unless_460
    set $P459, $P463
    goto unless_460_end
  unless_460:
    find_lex $P464, "$key"
    find_dynamic_lex $P465, "%*VM"
    unless_null $P465, vivify_94
    get_hll_global $P465, "%VM"
    unless_null $P465, vivify_95
    die "Contextual %*VM not found"
  vivify_95:
  vivify_94:
    set $P466, $P465["config"]
    unless_null $P466, vivify_96
    new $P466, "Hash"
  vivify_96:
    set $P467, $P466[$P464]
    unless_null $P467, vivify_97
    new $P467, "Undef"
  vivify_97:
    set $P459, $P467
  unless_460_end:
    unless $P459, unless_458
    set $P457, $P459
    goto unless_458_end
  unless_458:
    find_lex $P468, "$key"
    find_dynamic_lex $P469, "%*BIN"
    unless_null $P469, vivify_98
    get_hll_global $P469, "%BIN"
    unless_null $P469, vivify_99
    die "Contextual %*BIN not found"
  vivify_99:
  vivify_98:
    set $P470, $P469[$P468]
    unless_null $P470, vivify_100
    new $P470, "Undef"
  vivify_100:
    set $P457, $P470
  unless_458_end:
.annotate "line", 691
    unless $P457, unless_456
    set $P455, $P457
    goto unless_456_end
  unless_456:
    find_lex $P471, "$key"
    find_dynamic_lex $P472, "%*ENV"
    unless_null $P472, vivify_101
    get_hll_global $P472, "%ENV"
    unless_null $P472, vivify_102
    die "Contextual %*ENV not found"
  vivify_102:
  vivify_101:
    set $P473, $P472[$P471]
    unless_null $P473, vivify_103
    new $P473, "Undef"
  vivify_103:
    set $P455, $P473
  unless_456_end:
.annotate "line", 692
    unless $P455, unless_454
    set $P453, $P455
    goto unless_454_end
  unless_454:
    new $P474, "String"
    assign $P474, ""
    set $P453, $P474
  unless_454_end:
.annotate "line", 693
    store_lex "$config", $P453
.annotate "line", 695
    new $P475, "Exception"
    set $P475['type'], 58
    find_lex $P476, "$config"
    setattribute $P475, 'payload', $P476
    throw $P475
.annotate "line", 687
    .return ()
  control_446:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P477, exception, "payload"
    .return ($P477)
.end


.namespace ["Hash"]
.sub "_block478"  :subid("39_1261111400.42562") :outer("10_1261111400.42562")
.annotate "line", 67
    .const 'Sub' $P529 = "45_1261111400.42562" 
    capture_lex $P529
    .const 'Sub' $P508 = "43_1261111400.42562" 
    capture_lex $P508
    .const 'Sub' $P487 = "41_1261111400.42562" 
    capture_lex $P487
    .const 'Sub' $P480 = "40_1261111400.42562" 
    capture_lex $P480
.annotate "line", 130
    .const 'Sub' $P529 = "45_1261111400.42562" 
    capture_lex $P529
.annotate "line", 67
    .return ($P529)
.end


.namespace ["Hash"]
.sub "exists"  :subid("40_1261111400.42562") :method :outer("39_1261111400.42562")
    .param pmc param_483
.annotate "line", 80
    new $P482, 'ExceptionHandler'
    set_addr $P482, control_481
    $P482."handle_types"(58)
    push_eh $P482
    .lex "self", self
    .lex "$key", param_483
.annotate "line", 81
    new $P484, "Exception"
    set $P484['type'], 58

            $P1 = find_lex '$key'
            $I0 = exists self[$P1]
            $P485  = box $I0
        
    setattribute $P484, 'payload', $P485
    throw $P484
.annotate "line", 80
    .return ()
  control_481:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P486, exception, "payload"
    .return ($P486)
.end


.namespace ["Hash"]
.sub "keys"  :subid("41_1261111400.42562") :method :outer("39_1261111400.42562")
.annotate "line", 97
    .const 'Sub' $P497 = "42_1261111400.42562" 
    capture_lex $P497
    new $P489, 'ExceptionHandler'
    set_addr $P489, control_488
    $P489."handle_types"(58)
    push_eh $P489
    .lex "self", self
.annotate "line", 98
    new $P490, "ResizablePMCArray"
    .lex "@keys", $P490
.annotate "line", 97
    find_lex $P491, "@keys"
.annotate "line", 99
    find_lex $P493, "self"
    defined $I494, $P493
    unless $I494, for_undef_104
    iter $P492, $P493
    new $P504, 'ExceptionHandler'
    set_addr $P504, loop503_handler
    $P504."handle_types"(65, 67, 66)
    push_eh $P504
  loop503_test:
    unless $P492, loop503_done
    shift $P495, $P492
  loop503_redo:
    .const 'Sub' $P497 = "42_1261111400.42562" 
    capture_lex $P497
    $P497($P495)
  loop503_next:
    goto loop503_test
  loop503_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P505, exception, 'type'
    eq $P505, 65, loop503_next
    eq $P505, 67, loop503_redo
  loop503_done:
    pop_eh 
  for_undef_104:
    find_lex $P506, "@keys"
.annotate "line", 97
    .return ($P506)
  control_488:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P507, exception, "payload"
    .return ($P507)
.end


.namespace ["Hash"]
.sub "_block496"  :anon :subid("42_1261111400.42562") :outer("41_1261111400.42562")
    .param pmc param_498
.annotate "line", 99
    .lex "$_", param_498
    find_lex $P499, "@keys"
    find_lex $P500, "$_"
    $P501 = $P500."key"()
    $P502 = $P499."push"($P501)
    .return ($P502)
.end


.namespace ["Hash"]
.sub "values"  :subid("43_1261111400.42562") :method :outer("39_1261111400.42562")
.annotate "line", 112
    .const 'Sub' $P518 = "44_1261111400.42562" 
    capture_lex $P518
    new $P510, 'ExceptionHandler'
    set_addr $P510, control_509
    $P510."handle_types"(58)
    push_eh $P510
    .lex "self", self
.annotate "line", 113
    new $P511, "ResizablePMCArray"
    .lex "@values", $P511
.annotate "line", 112
    find_lex $P512, "@values"
.annotate "line", 114
    find_lex $P514, "self"
    defined $I515, $P514
    unless $I515, for_undef_105
    iter $P513, $P514
    new $P525, 'ExceptionHandler'
    set_addr $P525, loop524_handler
    $P525."handle_types"(65, 67, 66)
    push_eh $P525
  loop524_test:
    unless $P513, loop524_done
    shift $P516, $P513
  loop524_redo:
    .const 'Sub' $P518 = "44_1261111400.42562" 
    capture_lex $P518
    $P518($P516)
  loop524_next:
    goto loop524_test
  loop524_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P526, exception, 'type'
    eq $P526, 65, loop524_next
    eq $P526, 67, loop524_redo
  loop524_done:
    pop_eh 
  for_undef_105:
    find_lex $P527, "@values"
.annotate "line", 112
    .return ($P527)
  control_509:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P528, exception, "payload"
    .return ($P528)
.end


.namespace ["Hash"]
.sub "_block517"  :anon :subid("44_1261111400.42562") :outer("43_1261111400.42562")
    .param pmc param_519
.annotate "line", 114
    .lex "$_", param_519
    find_lex $P520, "@values"
    find_lex $P521, "$_"
    $P522 = $P521."value"()
    $P523 = $P520."push"($P522)
    .return ($P523)
.end


.namespace ["Hash"]
.sub "kv"  :subid("45_1261111400.42562") :method :outer("39_1261111400.42562")
.annotate "line", 130
    .const 'Sub' $P539 = "46_1261111400.42562" 
    capture_lex $P539
    new $P531, 'ExceptionHandler'
    set_addr $P531, control_530
    $P531."handle_types"(58)
    push_eh $P531
    .lex "self", self
.annotate "line", 131
    new $P532, "ResizablePMCArray"
    .lex "@kv", $P532
.annotate "line", 130
    find_lex $P533, "@kv"
.annotate "line", 132
    find_lex $P535, "self"
    defined $I536, $P535
    unless $I536, for_undef_106
    iter $P534, $P535
    new $P549, 'ExceptionHandler'
    set_addr $P549, loop548_handler
    $P549."handle_types"(65, 67, 66)
    push_eh $P549
  loop548_test:
    unless $P534, loop548_done
    shift $P537, $P534
  loop548_redo:
    .const 'Sub' $P539 = "46_1261111400.42562" 
    capture_lex $P539
    $P539($P537)
  loop548_next:
    goto loop548_test
  loop548_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P550, exception, 'type'
    eq $P550, 65, loop548_next
    eq $P550, 67, loop548_redo
  loop548_done:
    pop_eh 
  for_undef_106:
    find_lex $P551, "@kv"
.annotate "line", 130
    .return ($P551)
  control_530:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P552, exception, "payload"
    .return ($P552)
.end


.namespace ["Hash"]
.sub "_block538"  :anon :subid("46_1261111400.42562") :outer("45_1261111400.42562")
    .param pmc param_540
.annotate "line", 132
    .lex "$_", param_540
    find_lex $P541, "@kv"
    find_lex $P542, "$_"
    $P543 = $P542."key"()
    $P541."push"($P543)
    find_lex $P544, "@kv"
    find_lex $P545, "$_"
    $P546 = $P545."value"()
    $P547 = $P544."push"($P546)
    .return ($P547)
.end


.namespace ["Array"]
.sub "_block553"  :subid("47_1261111400.42562") :outer("10_1261111400.42562")
.annotate "line", 155
    .const 'Sub' $P555 = "48_1261111400.42562" 
    capture_lex $P555
.annotate "line", 168
    .const 'Sub' $P555 = "48_1261111400.42562" 
    capture_lex $P555
.annotate "line", 155
    .return ($P555)
.end


.namespace ["Array"]
.sub "reverse"  :subid("48_1261111400.42562") :method :outer("47_1261111400.42562")
.annotate "line", 168
    .const 'Sub' $P565 = "49_1261111400.42562" 
    capture_lex $P565
    new $P557, 'ExceptionHandler'
    set_addr $P557, control_556
    $P557."handle_types"(58)
    push_eh $P557
    .lex "self", self
.annotate "line", 169
    new $P558, "ResizablePMCArray"
    .lex "@reversed", $P558
.annotate "line", 168
    find_lex $P559, "@reversed"
.annotate "line", 170
    find_lex $P561, "self"
    defined $I562, $P561
    unless $I562, for_undef_107
    iter $P560, $P561
    new $P571, 'ExceptionHandler'
    set_addr $P571, loop570_handler
    $P571."handle_types"(65, 67, 66)
    push_eh $P571
  loop570_test:
    unless $P560, loop570_done
    shift $P563, $P560
  loop570_redo:
    .const 'Sub' $P565 = "49_1261111400.42562" 
    capture_lex $P565
    $P565($P563)
  loop570_next:
    goto loop570_test
  loop570_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P572, exception, 'type'
    eq $P572, 65, loop570_next
    eq $P572, 67, loop570_redo
  loop570_done:
    pop_eh 
  for_undef_107:
    find_lex $P573, "@reversed"
.annotate "line", 168
    .return ($P573)
  control_556:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P574, exception, "payload"
    .return ($P574)
.end


.namespace ["Array"]
.sub "_block564"  :anon :subid("49_1261111400.42562") :outer("48_1261111400.42562")
    .param pmc param_566
.annotate "line", 170
    .lex "$_", param_566
    find_lex $P567, "@reversed"
    find_lex $P568, "$_"
    $P569 = $P567."unshift"($P568)
    .return ($P569)
.end

