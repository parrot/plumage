
.namespace []
.sub "_block11"  :anon :subid("10_1277245056.4363")
.annotate 'line', 0
    .const 'Sub' $P854 = "64_1277245056.4363" 
    capture_lex $P854
    get_hll_global $P802, ["Array"], "_block801" 
    capture_lex $P802
    get_hll_global $P726, ["Hash"], "_block725" 
    capture_lex $P726
    .const 'Sub' $P709 = "51_1277245056.4363" 
    capture_lex $P709
    .const 'Sub' $P687 = "50_1277245056.4363" 
    capture_lex $P687
    .const 'Sub' $P658 = "49_1277245056.4363" 
    capture_lex $P658
    .const 'Sub' $P629 = "47_1277245056.4363" 
    capture_lex $P629
    .const 'Sub' $P615 = "46_1277245056.4363" 
    capture_lex $P615
    .const 'Sub' $P580 = "44_1277245056.4363" 
    capture_lex $P580
    .const 'Sub' $P505 = "41_1277245056.4363" 
    capture_lex $P505
    .const 'Sub' $P466 = "39_1277245056.4363" 
    capture_lex $P466
    .const 'Sub' $P438 = "37_1277245056.4363" 
    capture_lex $P438
    .const 'Sub' $P411 = "35_1277245056.4363" 
    capture_lex $P411
    .const 'Sub' $P393 = "34_1277245056.4363" 
    capture_lex $P393
    .const 'Sub' $P362 = "33_1277245056.4363" 
    capture_lex $P362
    .const 'Sub' $P347 = "32_1277245056.4363" 
    capture_lex $P347
    .const 'Sub' $P332 = "31_1277245056.4363" 
    capture_lex $P332
    .const 'Sub' $P316 = "30_1277245056.4363" 
    capture_lex $P316
    .const 'Sub' $P308 = "29_1277245056.4363" 
    capture_lex $P308
    .const 'Sub' $P291 = "27_1277245056.4363" 
    capture_lex $P291
    .const 'Sub' $P229 = "25_1277245056.4363" 
    capture_lex $P229
    .const 'Sub' $P201 = "24_1277245056.4363" 
    capture_lex $P201
    .const 'Sub' $P178 = "22_1277245056.4363" 
    capture_lex $P178
    .const 'Sub' $P170 = "21_1277245056.4363" 
    capture_lex $P170
    .const 'Sub' $P144 = "19_1277245056.4363" 
    capture_lex $P144
    .const 'Sub' $P68 = "15_1277245056.4363" 
    capture_lex $P68
    .const 'Sub' $P39 = "13_1277245056.4363" 
    capture_lex $P39
    .const 'Sub' $P13 = "11_1277245056.4363" 
    capture_lex $P13
.annotate 'line', 216
    .const 'Sub' $P13 = "11_1277245056.4363" 
    newclosure $P38, $P13
    .lex "map", $P38
.annotate 'line', 236
    .const 'Sub' $P39 = "13_1277245056.4363" 
    newclosure $P67, $P39
    .lex "grep", $P67
.annotate 'line', 268
    .const 'Sub' $P68 = "15_1277245056.4363" 
    newclosure $P143, $P68
    .lex "reduce", $P143
.annotate 'line', 296
    .const 'Sub' $P144 = "19_1277245056.4363" 
    newclosure $P169, $P144
    .lex "_reduce", $P169
.annotate 'line', 324
    .const 'Sub' $P170 = "21_1277245056.4363" 
    newclosure $P177, $P170
    .lex "hash", $P177
.annotate 'line', 337
    .const 'Sub' $P178 = "22_1277245056.4363" 
    newclosure $P200, $P178
    .lex "set_from_array", $P200
.annotate 'line', 364
    .const 'Sub' $P201 = "24_1277245056.4363" 
    newclosure $P228, $P201
    .lex "all_matches", $P228
.annotate 'line', 391
    .const 'Sub' $P229 = "25_1277245056.4363" 
    newclosure $P290, $P229
    .lex "subst", $P290
.annotate 'line', 440
    .const 'Sub' $P291 = "27_1277245056.4363" 
    newclosure $P307, $P291
    .lex "print", $P307
.annotate 'line', 455
    .const 'Sub' $P308 = "29_1277245056.4363" 
    newclosure $P315, $P308
    .lex "say", $P315
.annotate 'line', 468
    .const 'Sub' $P316 = "30_1277245056.4363" 
    newclosure $P331, $P316
    .lex "slurp", $P331
.annotate 'line', 486
    .const 'Sub' $P332 = "31_1277245056.4363" 
    newclosure $P346, $P332
    .lex "spew", $P346
.annotate 'line', 502
    .const 'Sub' $P347 = "32_1277245056.4363" 
    newclosure $P361, $P347
    .lex "append", $P361
.annotate 'line', 531
    .const 'Sub' $P362 = "33_1277245056.4363" 
    newclosure $P392, $P362
    .lex "fscat", $P392
.annotate 'line', 551
    .const 'Sub' $P393 = "34_1277245056.4363" 
    newclosure $P410, $P393
    .lex "user_home_dir", $P410
.annotate 'line', 566
    .const 'Sub' $P411 = "35_1277245056.4363" 
    newclosure $P437, $P411
    .lex "path_exists", $P437
.annotate 'line', 585
    .const 'Sub' $P438 = "37_1277245056.4363" 
    newclosure $P465, $P438
    .lex "is_dir", $P465
.annotate 'line', 612
    .const 'Sub' $P466 = "39_1277245056.4363" 
    newclosure $P504, $P466
    .lex "test_dir_writable", $P504
.annotate 'line', 651
    .const 'Sub' $P505 = "41_1277245056.4363" 
    newclosure $P579, $P505
    .lex "find_program", $P579
.annotate 'line', 682
    .const 'Sub' $P580 = "44_1277245056.4363" 
    newclosure $P614, $P580
    .lex "mkpath", $P614
.annotate 'line', 717
    .const 'Sub' $P615 = "46_1277245056.4363" 
    newclosure $P628, $P615
    .lex "run", $P628
.annotate 'line', 742
    .const 'Sub' $P629 = "47_1277245056.4363" 
    newclosure $P657, $P629
    .lex "do_run", $P657
.annotate 'line', 766
    .const 'Sub' $P658 = "49_1277245056.4363" 
    newclosure $P686, $P658
    .lex "qx", $P686
.annotate 'line', 801
    .const 'Sub' $P687 = "50_1277245056.4363" 
    newclosure $P708, $P687
    .lex "eval", $P708
.annotate 'line', 831
    .const 'Sub' $P709 = "51_1277245056.4363" 
    newclosure $P724, $P709
    .lex "store_dynlex_safely", $P724
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 81
    get_hll_global $P726, ["Hash"], "_block725" 
    capture_lex $P726
    $P726()
.annotate 'line', 169
    get_hll_global $P802, ["Array"], "_block801" 
    capture_lex $P802
    $P802()
    find_lex $P824, "map"
    find_lex $P825, "grep"
    find_lex $P826, "reduce"
    find_lex $P827, "_reduce"
    find_lex $P828, "hash"
    find_lex $P829, "set_from_array"
    find_lex $P830, "all_matches"
    find_lex $P831, "subst"
    find_lex $P832, "print"
    find_lex $P833, "say"
    find_lex $P834, "slurp"
    find_lex $P835, "spew"
    find_lex $P836, "append"
    find_lex $P837, "fscat"
    find_lex $P838, "user_home_dir"
    find_lex $P839, "path_exists"
    find_lex $P840, "is_dir"
    find_lex $P841, "test_dir_writable"
    find_lex $P842, "find_program"
    find_lex $P843, "mkpath"
    find_lex $P844, "run"
    find_lex $P845, "do_run"
    find_lex $P846, "qx"
    find_lex $P847, "eval"
    find_lex $P848, "store_dynlex_safely"
.annotate 'line', 1
    .return ()
    .const 'Sub' $P850 = "63_1277245056.4363" 
    .return ($P850)
.end


.namespace []
.sub "" :load :init :subid("post65") :outer("10_1277245056.4363")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1277245056.4363" 
    .local pmc block
    set block, $P12
.annotate 'line', 885
    .const 'Sub' $P854 = "64_1277245056.4363" 
    capture_lex $P854
    $P854()
.end


.namespace []
.sub "_block853"  :anon :subid("64_1277245056.4363") :outer("10_1277245056.4363")
.annotate 'line', 890
    new $P855, "Undef"
    .lex "$interp", $P855
.annotate 'line', 891
    $P856 = root_new ['parrot';'ResizablePMCArray']
    .lex "@argv", $P856
.annotate 'line', 892
    new $P857, "Undef"
    .lex "$config", $P857
.annotate 'line', 893
    new $P858, "Undef"
    .lex "$os", $P858
.annotate 'line', 896
    $P859 = root_new ['parrot';'Hash']
    .lex "%vm", $P859
.annotate 'line', 887
    load_bytecode "config.pbc"
.annotate 'line', 888
    load_bytecode "P6Regex.pbc"
.annotate 'line', 890
    getinterp $P860
    store_lex "$interp", $P860
.annotate 'line', 891
    find_lex $P861, "$interp"
    unless_null $P861, vivify_66
    $P861 = root_new ['parrot';'ResizablePMCArray']
  vivify_66:
    set $P862, $P861[2]
    unless_null $P862, vivify_67
    new $P862, "Undef"
  vivify_67:
    store_lex "@argv", $P862
.annotate 'line', 892
    find_lex $P863, "$interp"
    unless_null $P863, vivify_68
    $P863 = root_new ['parrot';'ResizablePMCArray']
  vivify_68:
    set $P864, $P863[6]
    unless_null $P864, vivify_69
    new $P864, "Undef"
  vivify_69:
    store_lex "$config", $P864
.annotate 'line', 893
    new $P865, "String"
    assign $P865, "os"
    set $S866, $P865
    loadlib $P867, $S866
    store_lex "$os", $P867
    find_lex $P868, "%vm"
.annotate 'line', 897
    find_lex $P869, "$config"
    find_lex $P870, "%vm"
    unless_null $P870, vivify_70
    $P870 = root_new ['parrot';'Hash']
    store_lex "%vm", $P870
  vivify_70:
    set $P870["config"], $P869
.annotate 'line', 898
    find_lex $P871, "%vm"
    "store_dynlex_safely"("%*VM", $P871)
.annotate 'line', 901
    find_lex $P873, "@argv"
    if $P873, unless_872_end
    find_lex $P874, "@argv"
    $P874."unshift"("<anonymous>")
  unless_872_end:
.annotate 'line', 902
    find_lex $P875, "@argv"
    $P876 = $P875."shift"()
    "store_dynlex_safely"("$*PROGRAM_NAME", $P876)
.annotate 'line', 903
    find_lex $P877, "@argv"
    "store_dynlex_safely"("@*ARGS", $P877)
.annotate 'line', 906
    interpinfo $S878, 19
    "store_dynlex_safely"("$*EXECUTABLE_NAME", $S878)
.annotate 'line', 908
    new $P879, "String"
    assign $P879, "osname"
    set $I880, $P879
    find_lex $P881, "$interp"
    unless_null $P881, vivify_71
    $P881 = root_new ['parrot';'ResizablePMCArray']
  vivify_71:
    set $P882, $P881[8]
    unless_null $P882, vivify_72
    $P882 = root_new ['parrot';'ResizablePMCArray']
  vivify_72:
    set $P883, $P882[$I880]
    unless_null $P883, vivify_73
    new $P883, "Undef"
  vivify_73:
    "store_dynlex_safely"("$*OSNAME", $P883)
.annotate 'line', 909
    new $P884, "String"
    assign $P884, "VERSION"
    set $I885, $P884
    find_lex $P886, "$interp"
    unless_null $P886, vivify_74
    $P886 = root_new ['parrot';'ResizablePMCArray']
  vivify_74:
    set $P887, $P886[8]
    unless_null $P887, vivify_75
    $P887 = root_new ['parrot';'ResizablePMCArray']
  vivify_75:
    set $P888, $P887[$I885]
    unless_null $P888, vivify_76
    new $P888, "Undef"
  vivify_76:
    "store_dynlex_safely"("%*OSVER", $P888)
.annotate 'line', 912
    new $P889, "ResizablePMCArray"
    push $P889, "parrot"
    push $P889, "Env"
    root_new $P890, $P889
    "store_dynlex_safely"("%*ENV", $P890)
.annotate 'line', 913
    new $P891, "ResizablePMCArray"
    push $P891, "parrot"
    push $P891, "OS"
    root_new $P892, $P891
    $P893 = "store_dynlex_safely"("$*OS", $P892)
.annotate 'line', 885
    .return ($P893)
.end


.namespace []
.include "except_types.pasm"
.sub "map"  :subid("11_1277245056.4363") :outer("10_1277245056.4363")
    .param pmc param_16
    .param pmc param_17
.annotate 'line', 216
    .const 'Sub' $P25 = "12_1277245056.4363" 
    capture_lex $P25
    new $P15, 'ExceptionHandler'
    set_addr $P15, control_14
    $P15."handle_types"(.CONTROL_RETURN)
    push_eh $P15
    .lex "&code", param_16
    .lex "@originals", param_17
.annotate 'line', 217
    $P18 = root_new ['parrot';'ResizablePMCArray']
    .lex "@mapped", $P18
.annotate 'line', 216
    find_lex $P19, "@mapped"
.annotate 'line', 219
    find_lex $P21, "@originals"
    defined $I22, $P21
    unless $I22, for_undef_77
    iter $P20, $P21
    new $P33, 'ExceptionHandler'
    set_addr $P33, loop32_handler
    $P33."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P33
  loop32_test:
    unless $P20, loop32_done
    shift $P23, $P20
  loop32_redo:
    .const 'Sub' $P25 = "12_1277245056.4363" 
    capture_lex $P25
    $P25($P23)
  loop32_next:
    goto loop32_test
  loop32_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P34, exception, 'type'
    eq $P34, .CONTROL_LOOP_NEXT, loop32_next
    eq $P34, .CONTROL_LOOP_REDO, loop32_redo
  loop32_done:
    pop_eh 
  for_undef_77:
.annotate 'line', 223
    new $P35, "Exception"
    set $P35['type'], .CONTROL_RETURN
    find_lex $P36, "@mapped"
    setattribute $P35, 'payload', $P36
    throw $P35
.annotate 'line', 216
    .return ()
  control_14:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P37, exception, "payload"
    .return ($P37)
.end


.namespace []
.sub "_block24"  :anon :subid("12_1277245056.4363") :outer("11_1277245056.4363")
    .param pmc param_26
.annotate 'line', 219
    .lex "$_", param_26
.annotate 'line', 220
    find_lex $P27, "@mapped"
    find_lex $P28, "&code"
    find_lex $P29, "$_"
    $P30 = $P28($P29)
    $P31 = $P27."push"($P30)
.annotate 'line', 219
    .return ($P31)
.end


.namespace []
.include "except_types.pasm"
.sub "grep"  :subid("13_1277245056.4363") :outer("10_1277245056.4363")
    .param pmc param_42
    .param pmc param_43
.annotate 'line', 236
    .const 'Sub' $P51 = "14_1277245056.4363" 
    capture_lex $P51
    new $P41, 'ExceptionHandler'
    set_addr $P41, control_40
    $P41."handle_types"(.CONTROL_RETURN)
    push_eh $P41
    .lex "&code", param_42
    .lex "@all", param_43
.annotate 'line', 237
    $P44 = root_new ['parrot';'ResizablePMCArray']
    .lex "@matches", $P44
.annotate 'line', 236
    find_lex $P45, "@matches"
.annotate 'line', 239
    find_lex $P47, "@all"
    defined $I48, $P47
    unless $I48, for_undef_78
    iter $P46, $P47
    new $P62, 'ExceptionHandler'
    set_addr $P62, loop61_handler
    $P62."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P62
  loop61_test:
    unless $P46, loop61_done
    shift $P49, $P46
  loop61_redo:
    .const 'Sub' $P51 = "14_1277245056.4363" 
    capture_lex $P51
    $P51($P49)
  loop61_next:
    goto loop61_test
  loop61_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P63, exception, 'type'
    eq $P63, .CONTROL_LOOP_NEXT, loop61_next
    eq $P63, .CONTROL_LOOP_REDO, loop61_redo
  loop61_done:
    pop_eh 
  for_undef_78:
.annotate 'line', 243
    new $P64, "Exception"
    set $P64['type'], .CONTROL_RETURN
    find_lex $P65, "@matches"
    setattribute $P64, 'payload', $P65
    throw $P64
.annotate 'line', 236
    .return ()
  control_40:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P66, exception, "payload"
    .return ($P66)
.end


.namespace []
.sub "_block50"  :anon :subid("14_1277245056.4363") :outer("13_1277245056.4363")
    .param pmc param_52
.annotate 'line', 239
    .lex "$_", param_52
.annotate 'line', 240
    find_lex $P55, "&code"
    find_lex $P56, "$_"
    $P57 = $P55($P56)
    if $P57, if_54
    set $P53, $P57
    goto if_54_end
  if_54:
    find_lex $P58, "@matches"
    find_lex $P59, "$_"
    $P60 = $P58."push"($P59)
    set $P53, $P60
  if_54_end:
.annotate 'line', 239
    .return ($P53)
.end


.namespace []
.include "except_types.pasm"
.sub "reduce"  :subid("15_1277245056.4363") :outer("10_1277245056.4363")
    .param pmc param_71
    .param pmc param_72
    .param pmc param_73 :slurpy
.annotate 'line', 268
    .const 'Sub' $P95 = "16_1277245056.4363" 
    capture_lex $P95
    new $P70, 'ExceptionHandler'
    set_addr $P70, control_69
    $P70."handle_types"(.CONTROL_RETURN)
    push_eh $P70
    .lex "&code", param_71
    .lex "@array", param_72
    .lex "@initial", param_73
.annotate 'line', 269
    new $P74, "Undef"
    .lex "$init_elems", $P74
    find_lex $P75, "@initial"
    elements $I76, $P75
    new $P77, 'Integer'
    set $P77, $I76
    store_lex "$init_elems", $P77
.annotate 'line', 270
    find_lex $P80, "$init_elems"
    set $N81, $P80
    isgt $I82, $N81, 1.0
    if $I82, if_79
.annotate 'line', 273
    find_lex $P85, "$init_elems"
    set $N86, $P85
    iseq $I87, $N86, 1.0
    if $I87, if_84
.annotate 'line', 276
    .const 'Sub' $P95 = "16_1277245056.4363" 
    capture_lex $P95
    $P141 = $P95()
    set $P83, $P141
.annotate 'line', 273
    goto if_84_end
  if_84:
.annotate 'line', 274
    new $P88, "Exception"
    set $P88['type'], .CONTROL_RETURN
    find_lex $P89, "&code"
    find_lex $P90, "@array"
    find_lex $P91, "@initial"
    unless_null $P91, vivify_85
    $P91 = root_new ['parrot';'ResizablePMCArray']
  vivify_85:
    set $P92, $P91[0]
    unless_null $P92, vivify_86
    new $P92, "Undef"
  vivify_86:
    $P93 = "_reduce"($P89, $P90, $P92)
    setattribute $P88, 'payload', $P93
    throw $P88
  if_84_end:
.annotate 'line', 273
    set $P78, $P83
.annotate 'line', 270
    goto if_79_end
  if_79:
.annotate 'line', 271
    die "Only one initial value allowed in reduce()"
  if_79_end:
.annotate 'line', 268
    .return ($P78)
  control_69:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P142, exception, "payload"
    .return ($P142)
.end


.namespace []
.include "except_types.pasm"
.sub "_block94"  :anon :subid("16_1277245056.4363") :outer("15_1277245056.4363")
.annotate 'line', 276
    .const 'Sub' $P120 = "18_1277245056.4363" 
    capture_lex $P120
    .const 'Sub' $P106 = "17_1277245056.4363" 
    capture_lex $P106
.annotate 'line', 277
    new $P96, "Undef"
    .lex "$array_elems", $P96
    find_lex $P97, "@array"
    elements $I98, $P97
    new $P99, 'Integer'
    set $P99, $I98
    store_lex "$array_elems", $P99
.annotate 'line', 278
    find_lex $P102, "$array_elems"
    set $N103, $P102
    iseq $I104, $N103, 0.0
    if $I104, if_101
.annotate 'line', 281
    find_lex $P113, "$array_elems"
    set $N114, $P113
    iseq $I115, $N114, 1.0
    if $I115, if_112
.annotate 'line', 284
    .const 'Sub' $P120 = "18_1277245056.4363" 
    capture_lex $P120
    $P140 = $P120()
    set $P111, $P140
.annotate 'line', 281
    goto if_112_end
  if_112:
.annotate 'line', 282
    new $P116, "Exception"
    set $P116['type'], .CONTROL_RETURN
    find_lex $P117, "@array"
    unless_null $P117, vivify_83
    $P117 = root_new ['parrot';'ResizablePMCArray']
  vivify_83:
    set $P118, $P117[0]
    unless_null $P118, vivify_84
    new $P118, "Undef"
  vivify_84:
    setattribute $P116, 'payload', $P118
    throw $P116
  if_112_end:
.annotate 'line', 281
    set $P100, $P111
.annotate 'line', 278
    goto if_101_end
  if_101:
    .const 'Sub' $P106 = "17_1277245056.4363" 
    capture_lex $P106
    $P110 = $P106()
    set $P100, $P110
  if_101_end:
.annotate 'line', 276
    .return ($P100)
.end


.namespace []
.include "except_types.pasm"
.sub "_block119"  :anon :subid("18_1277245056.4363") :outer("16_1277245056.4363")
.annotate 'line', 285
    new $P121, "Undef"
    .lex "$initial", $P121
.annotate 'line', 286
    new $P122, "Undef"
    .lex "$iter", $P122
.annotate 'line', 285
    find_lex $P123, "&code"
    find_lex $P124, "@array"
    unless_null $P124, vivify_79
    $P124 = root_new ['parrot';'ResizablePMCArray']
  vivify_79:
    set $P125, $P124[0]
    unless_null $P125, vivify_80
    new $P125, "Undef"
  vivify_80:
    find_lex $P126, "@array"
    unless_null $P126, vivify_81
    $P126 = root_new ['parrot';'ResizablePMCArray']
  vivify_81:
    set $P127, $P126[1]
    unless_null $P127, vivify_82
    new $P127, "Undef"
  vivify_82:
    $P128 = $P123($P125, $P127)
    store_lex "$initial", $P128
.annotate 'line', 286
    find_lex $P129, "@array"
    iter $P130, $P129
    store_lex "$iter", $P130
.annotate 'line', 288
    find_lex $P131, "$iter"
    shift $P132, $P131
.annotate 'line', 289
    find_lex $P133, "$iter"
    shift $P134, $P133
.annotate 'line', 291
    new $P135, "Exception"
    set $P135['type'], .CONTROL_RETURN
    find_lex $P136, "&code"
    find_lex $P137, "$iter"
    find_lex $P138, "$initial"
    $P139 = "_reduce"($P136, $P137, $P138)
    setattribute $P135, 'payload', $P139
    throw $P135
.annotate 'line', 284
    .return ()
.end


.namespace []
.include "except_types.pasm"
.sub "_block105"  :anon :subid("17_1277245056.4363") :outer("16_1277245056.4363")
.annotate 'line', 279
    new $P107, "Undef"
    .lex "$undef", $P107
    new $P108, "Exception"
    set $P108['type'], .CONTROL_RETURN
    find_lex $P109, "$undef"
    setattribute $P108, 'payload', $P109
    throw $P108
.annotate 'line', 278
    .return ()
.end


.namespace []
.include "except_types.pasm"
.sub "_reduce"  :subid("19_1277245056.4363") :outer("10_1277245056.4363")
    .param pmc param_147
    .param pmc param_148
    .param pmc param_149
.annotate 'line', 296
    .const 'Sub' $P157 = "20_1277245056.4363" 
    capture_lex $P157
    new $P146, 'ExceptionHandler'
    set_addr $P146, control_145
    $P146."handle_types"(.CONTROL_RETURN)
    push_eh $P146
    .lex "&code", param_147
    .lex "$iter", param_148
    .lex "$initial", param_149
.annotate 'line', 297
    new $P150, "Undef"
    .lex "$result", $P150
    find_lex $P151, "$initial"
    store_lex "$result", $P151
.annotate 'line', 299
    find_lex $P153, "$iter"
    defined $I154, $P153
    unless $I154, for_undef_87
    iter $P152, $P153
    new $P164, 'ExceptionHandler'
    set_addr $P164, loop163_handler
    $P164."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P164
  loop163_test:
    unless $P152, loop163_done
    shift $P155, $P152
  loop163_redo:
    .const 'Sub' $P157 = "20_1277245056.4363" 
    capture_lex $P157
    $P157($P155)
  loop163_next:
    goto loop163_test
  loop163_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P165, exception, 'type'
    eq $P165, .CONTROL_LOOP_NEXT, loop163_next
    eq $P165, .CONTROL_LOOP_REDO, loop163_redo
  loop163_done:
    pop_eh 
  for_undef_87:
.annotate 'line', 303
    new $P166, "Exception"
    set $P166['type'], .CONTROL_RETURN
    find_lex $P167, "$result"
    setattribute $P166, 'payload', $P167
    throw $P166
.annotate 'line', 296
    .return ()
  control_145:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P168, exception, "payload"
    .return ($P168)
.end


.namespace []
.sub "_block156"  :anon :subid("20_1277245056.4363") :outer("19_1277245056.4363")
    .param pmc param_158
.annotate 'line', 299
    .lex "$_", param_158
.annotate 'line', 300
    find_lex $P159, "&code"
    find_lex $P160, "$result"
    find_lex $P161, "$_"
    $P162 = $P159($P160, $P161)
    store_lex "$result", $P162
.annotate 'line', 299
    .return ($P162)
.end


.namespace []
.include "except_types.pasm"
.sub "hash"  :subid("21_1277245056.4363") :outer("10_1277245056.4363")
    .param pmc param_173 :slurpy :named
.annotate 'line', 324
    new $P172, 'ExceptionHandler'
    set_addr $P172, control_171
    $P172."handle_types"(.CONTROL_RETURN)
    push_eh $P172
    .lex "%h", param_173
    new $P174, "Exception"
    set $P174['type'], .CONTROL_RETURN
    find_lex $P175, "%h"
    setattribute $P174, 'payload', $P175
    throw $P174
    .return ()
  control_171:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P176, exception, "payload"
    .return ($P176)
.end


.namespace []
.include "except_types.pasm"
.sub "set_from_array"  :subid("22_1277245056.4363") :outer("10_1277245056.4363")
    .param pmc param_181
.annotate 'line', 337
    .const 'Sub' $P189 = "23_1277245056.4363" 
    capture_lex $P189
    new $P180, 'ExceptionHandler'
    set_addr $P180, control_179
    $P180."handle_types"(.CONTROL_RETURN)
    push_eh $P180
    .lex "@array", param_181
.annotate 'line', 338
    $P182 = root_new ['parrot';'Hash']
    .lex "%set", $P182
.annotate 'line', 337
    find_lex $P183, "%set"
.annotate 'line', 340
    find_lex $P185, "@array"
    defined $I186, $P185
    unless $I186, for_undef_88
    iter $P184, $P185
    new $P195, 'ExceptionHandler'
    set_addr $P195, loop194_handler
    $P195."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P195
  loop194_test:
    unless $P184, loop194_done
    shift $P187, $P184
  loop194_redo:
    .const 'Sub' $P189 = "23_1277245056.4363" 
    capture_lex $P189
    $P189($P187)
  loop194_next:
    goto loop194_test
  loop194_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P196, exception, 'type'
    eq $P196, .CONTROL_LOOP_NEXT, loop194_next
    eq $P196, .CONTROL_LOOP_REDO, loop194_redo
  loop194_done:
    pop_eh 
  for_undef_88:
.annotate 'line', 344
    new $P197, "Exception"
    set $P197['type'], .CONTROL_RETURN
    find_lex $P198, "%set"
    setattribute $P197, 'payload', $P198
    throw $P197
.annotate 'line', 337
    .return ()
  control_179:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P199, exception, "payload"
    .return ($P199)
.end


.namespace []
.sub "_block188"  :anon :subid("23_1277245056.4363") :outer("22_1277245056.4363")
    .param pmc param_190
.annotate 'line', 340
    .lex "$_", param_190
.annotate 'line', 341
    new $P191, "Integer"
    assign $P191, 1
    find_lex $P192, "$_"
    find_lex $P193, "%set"
    unless_null $P193, vivify_89
    $P193 = root_new ['parrot';'Hash']
    store_lex "%set", $P193
  vivify_89:
    set $P193[$P192], $P191
.annotate 'line', 340
    .return ($P191)
.end


.namespace []
.include "except_types.pasm"
.sub "all_matches"  :subid("24_1277245056.4363") :outer("10_1277245056.4363")
    .param pmc param_204
    .param pmc param_205
.annotate 'line', 364
    new $P203, 'ExceptionHandler'
    set_addr $P203, control_202
    $P203."handle_types"(.CONTROL_RETURN)
    push_eh $P203
    .lex "$regex", param_204
    .lex "$text", param_205
.annotate 'line', 365
    $P206 = root_new ['parrot';'ResizablePMCArray']
    .lex "@matches", $P206
.annotate 'line', 367
    new $P207, "Undef"
    .lex "$match", $P207
.annotate 'line', 364
    find_lex $P208, "@matches"
.annotate 'line', 367
    find_lex $P209, "$regex"
    find_lex $P210, "$text"
    $P211 = $P209."ACCEPTS"($P210)
    store_lex "$match", $P211
.annotate 'line', 368
    new $P223, 'ExceptionHandler'
    set_addr $P223, loop222_handler
    $P223."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P223
  loop222_test:
    find_lex $P212, "$match"
    unless $P212, loop222_done
  loop222_redo:
.annotate 'line', 369
    find_lex $P213, "@matches"
    find_lex $P214, "$match"
    $P213."push"($P214)
.annotate 'line', 370
    find_lex $P215, "$match"
    $P216 = $P215."CURSOR"()
    find_lex $P217, "$text"
    find_lex $P218, "$regex"
    find_lex $P219, "$match"
    $P220 = $P219."to"()
    $P221 = $P216."parse"($P217, $P218 :named("rule"), $P220 :named("c"))
    store_lex "$match", $P221
  loop222_next:
.annotate 'line', 368
    goto loop222_test
  loop222_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P224, exception, 'type'
    eq $P224, .CONTROL_LOOP_NEXT, loop222_next
    eq $P224, .CONTROL_LOOP_REDO, loop222_redo
  loop222_done:
    pop_eh 
.annotate 'line', 373
    new $P225, "Exception"
    set $P225['type'], .CONTROL_RETURN
    find_lex $P226, "@matches"
    setattribute $P225, 'payload', $P226
    throw $P225
.annotate 'line', 364
    .return ()
  control_202:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P227, exception, "payload"
    .return ($P227)
.end


.namespace []
.include "except_types.pasm"
.sub "subst"  :subid("25_1277245056.4363") :outer("10_1277245056.4363")
    .param pmc param_232
    .param pmc param_233
    .param pmc param_234
.annotate 'line', 391
    .const 'Sub' $P253 = "26_1277245056.4363" 
    capture_lex $P253
    new $P231, 'ExceptionHandler'
    set_addr $P231, control_230
    $P231."handle_types"(.CONTROL_RETURN)
    push_eh $P231
    .lex "$original", param_232
    .lex "$regex", param_233
    .lex "$replacement", param_234
.annotate 'line', 392
    $P235 = root_new ['parrot';'ResizablePMCArray']
    .lex "@matches", $P235
.annotate 'line', 393
    new $P236, "Undef"
    .lex "$edited", $P236
.annotate 'line', 394
    new $P237, "Undef"
    .lex "$is_sub", $P237
.annotate 'line', 395
    new $P238, "Undef"
    .lex "$offset", $P238
.annotate 'line', 392
    find_lex $P239, "$regex"
    find_lex $P240, "$original"
    $P241 = "all_matches"($P239, $P240)
    store_lex "@matches", $P241
.annotate 'line', 393
    find_lex $P242, "$original"
    clone $P243, $P242
    store_lex "$edited", $P243
.annotate 'line', 394
    find_lex $P244, "$replacement"
    isa $I245, $P244, "Sub"
    new $P246, 'Integer'
    set $P246, $I245
    store_lex "$is_sub", $P246
.annotate 'line', 395
    new $P247, "Integer"
    assign $P247, 0
    store_lex "$offset", $P247
.annotate 'line', 397
    find_lex $P249, "@matches"
    defined $I250, $P249
    unless $I250, for_undef_90
    iter $P248, $P249
    new $P285, 'ExceptionHandler'
    set_addr $P285, loop284_handler
    $P285."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P285
  loop284_test:
    unless $P248, loop284_done
    shift $P251, $P248
  loop284_redo:
    .const 'Sub' $P253 = "26_1277245056.4363" 
    capture_lex $P253
    $P253($P251)
  loop284_next:
    goto loop284_test
  loop284_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P286, exception, 'type'
    eq $P286, .CONTROL_LOOP_NEXT, loop284_next
    eq $P286, .CONTROL_LOOP_REDO, loop284_redo
  loop284_done:
    pop_eh 
  for_undef_90:
.annotate 'line', 419
    new $P287, "Exception"
    set $P287['type'], .CONTROL_RETURN
    find_lex $P288, "$edited"
    setattribute $P287, 'payload', $P288
    throw $P287
.annotate 'line', 391
    .return ()
  control_230:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P289, exception, "payload"
    .return ($P289)
.end


.namespace []
.sub "_block252"  :anon :subid("26_1277245056.4363") :outer("25_1277245056.4363")
    .param pmc param_254
.annotate 'line', 397
    .lex "$match", param_254
.annotate 'line', 398
    new $P255, "Undef"
    .lex "$replace_string", $P255
.annotate 'line', 399
    new $P256, "Undef"
    .lex "$replace_len", $P256
.annotate 'line', 400
    new $P257, "Undef"
    .lex "$match_len", $P257
.annotate 'line', 401
    new $P258, "Undef"
    .lex "$real_from", $P258
.annotate 'line', 398
    find_lex $P261, "$is_sub"
    if $P261, if_260
    find_lex $P265, "$replacement"
    set $P259, $P265
    goto if_260_end
  if_260:
    find_lex $P262, "$replacement"
    find_lex $P263, "$match"
    $P264 = $P262($P263)
    set $P259, $P264
  if_260_end:
    store_lex "$replace_string", $P259
.annotate 'line', 399
    find_lex $P266, "$replace_string"
    set $S267, $P266
    length $I268, $S267
    new $P269, 'Integer'
    set $P269, $I268
    store_lex "$replace_len", $P269
.annotate 'line', 400
    find_lex $P270, "$match"
    $P271 = $P270."to"()
    find_lex $P272, "$match"
    $N273 = $P272."from"()
    sub $P274, $P271, $N273
    store_lex "$match_len", $P274
.annotate 'line', 401
    find_lex $P275, "$match"
    $P276 = $P275."from"()
    find_lex $P277, "$offset"
    add $P278, $P276, $P277
    store_lex "$real_from", $P278
.annotate 'line', 403

             $P0 = find_lex '$edited'
	     $S0 = $P0
	     $P1 = find_lex '$real_from'
	     $I0 = $P1
	     $P2 = find_lex '$match_len'
	     $I1 = $P2
	     $P3 = find_lex '$replace_string'
	     $S1 = $P3
	     replace $S0, $S0, $I0, $I1, $S1
	     $P0 = $S0
	
.annotate 'line', 416
    find_lex $P279, "$offset"
    find_lex $P280, "$match_len"
    sub $P281, $P279, $P280
    find_lex $P282, "$replace_len"
    add $P283, $P281, $P282
    store_lex "$offset", $P283
.annotate 'line', 397
    .return ($P283)
.end


.namespace []
.include "except_types.pasm"
.sub "print"  :subid("27_1277245056.4363") :outer("10_1277245056.4363")
    .param pmc param_294 :slurpy
.annotate 'line', 440
    .const 'Sub' $P300 = "28_1277245056.4363" 
    capture_lex $P300
    new $P293, 'ExceptionHandler'
    set_addr $P293, control_292
    $P293."handle_types"(.CONTROL_RETURN)
    push_eh $P293
    .lex "@strings", param_294
.annotate 'line', 441
    find_lex $P296, "@strings"
    defined $I297, $P296
    unless $I297, for_undef_91
    iter $P295, $P296
    new $P304, 'ExceptionHandler'
    set_addr $P304, loop303_handler
    $P304."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P304
  loop303_test:
    unless $P295, loop303_done
    shift $P298, $P295
  loop303_redo:
    .const 'Sub' $P300 = "28_1277245056.4363" 
    capture_lex $P300
    $P300($P298)
  loop303_next:
    goto loop303_test
  loop303_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P305, exception, 'type'
    eq $P305, .CONTROL_LOOP_NEXT, loop303_next
    eq $P305, .CONTROL_LOOP_REDO, loop303_redo
  loop303_done:
    pop_eh 
  for_undef_91:
.annotate 'line', 440
    .return ($P295)
  control_292:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P306, exception, "payload"
    .return ($P306)
.end


.namespace []
.sub "_block299"  :anon :subid("28_1277245056.4363") :outer("27_1277245056.4363")
    .param pmc param_301
.annotate 'line', 441
    .lex "$_", param_301
.annotate 'line', 442
    find_lex $P302, "$_"
    print $P302
.annotate 'line', 441
    .return ()
.end


.namespace []
.include "except_types.pasm"
.sub "say"  :subid("29_1277245056.4363") :outer("10_1277245056.4363")
    .param pmc param_311 :slurpy
.annotate 'line', 455
    new $P310, 'ExceptionHandler'
    set_addr $P310, control_309
    $P310."handle_types"(.CONTROL_RETURN)
    push_eh $P310
    .lex "@strings", param_311
.annotate 'line', 456
    find_lex $P312, "@strings"
    $P313 = "print"($P312 :flat, "\n")
.annotate 'line', 455
    .return ($P313)
  control_309:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P314, exception, "payload"
    .return ($P314)
.end


.namespace []
.include "except_types.pasm"
.sub "slurp"  :subid("30_1277245056.4363") :outer("10_1277245056.4363")
    .param pmc param_319
.annotate 'line', 468
    new $P318, 'ExceptionHandler'
    set_addr $P318, control_317
    $P318."handle_types"(.CONTROL_RETURN)
    push_eh $P318
    .lex "$filename", param_319
.annotate 'line', 469
    new $P320, "Undef"
    .lex "$fh", $P320
.annotate 'line', 471
    new $P321, "Undef"
    .lex "$contents", $P321
.annotate 'line', 469
    new $P322, "FileHandle"
    store_lex "$fh", $P322
.annotate 'line', 470
    find_lex $P323, "$fh"
    find_lex $P324, "$filename"
    $P323."open"($P324, "r")
.annotate 'line', 471
    find_lex $P325, "$fh"
    $P326 = $P325."readall"()
    store_lex "$contents", $P326
.annotate 'line', 472
    find_lex $P327, "$fh"
    $P327."close"()
.annotate 'line', 474
    new $P328, "Exception"
    set $P328['type'], .CONTROL_RETURN
    find_lex $P329, "$contents"
    setattribute $P328, 'payload', $P329
    throw $P328
.annotate 'line', 468
    .return ()
  control_317:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P330, exception, "payload"
    .return ($P330)
.end


.namespace []
.include "except_types.pasm"
.sub "spew"  :subid("31_1277245056.4363") :outer("10_1277245056.4363")
    .param pmc param_335
    .param pmc param_336
.annotate 'line', 486
    new $P334, 'ExceptionHandler'
    set_addr $P334, control_333
    $P334."handle_types"(.CONTROL_RETURN)
    push_eh $P334
    .lex "$filename", param_335
    .lex "$contents", param_336
.annotate 'line', 487
    new $P337, "Undef"
    .lex "$fh", $P337
    new $P338, "FileHandle"
    store_lex "$fh", $P338
.annotate 'line', 488
    find_lex $P339, "$fh"
    find_lex $P340, "$filename"
    $P339."open"($P340, "w")
.annotate 'line', 489
    find_lex $P341, "$fh"
    find_lex $P342, "$contents"
    $P341."print"($P342)
.annotate 'line', 490
    find_lex $P343, "$fh"
    $P344 = $P343."close"()
.annotate 'line', 486
    .return ($P344)
  control_333:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P345, exception, "payload"
    .return ($P345)
.end


.namespace []
.include "except_types.pasm"
.sub "append"  :subid("32_1277245056.4363") :outer("10_1277245056.4363")
    .param pmc param_350
    .param pmc param_351
.annotate 'line', 502
    new $P349, 'ExceptionHandler'
    set_addr $P349, control_348
    $P349."handle_types"(.CONTROL_RETURN)
    push_eh $P349
    .lex "$filename", param_350
    .lex "$contents", param_351
.annotate 'line', 503
    new $P352, "Undef"
    .lex "$fh", $P352
    new $P353, "FileHandle"
    store_lex "$fh", $P353
.annotate 'line', 504
    find_lex $P354, "$fh"
    find_lex $P355, "$filename"
    $P354."open"($P355, "a")
.annotate 'line', 505
    find_lex $P356, "$fh"
    find_lex $P357, "$contents"
    $P356."print"($P357)
.annotate 'line', 506
    find_lex $P358, "$fh"
    $P359 = $P358."close"()
.annotate 'line', 502
    .return ($P359)
  control_348:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P360, exception, "payload"
    .return ($P360)
.end


.namespace []
.include "except_types.pasm"
.sub "fscat"  :subid("33_1277245056.4363") :outer("10_1277245056.4363")
    .param pmc param_365
    .param pmc param_366 :slurpy
.annotate 'line', 531
    new $P364, 'ExceptionHandler'
    set_addr $P364, control_363
    $P364."handle_types"(.CONTROL_RETURN)
    push_eh $P364
    .lex "@path_parts", param_365
    .lex "@filename", param_366
.annotate 'line', 535
    new $P367, "Undef"
    .lex "$sep", $P367
.annotate 'line', 536
    new $P368, "Undef"
    .lex "$joined", $P368
.annotate 'line', 533
    find_lex $P370, "@filename"
    set $N371, $P370
    isgt $I372, $N371, 1.0
    unless $I372, if_369_end
.annotate 'line', 532
    die "Only one filename allowed in fscat()"
  if_369_end:
.annotate 'line', 535
    getinterp $P373
    set $P374, $P373[6]
    unless_null $P374, vivify_92
    $P374 = root_new ['parrot';'Hash']
  vivify_92:
    set $P375, $P374["slash"]
    unless_null $P375, vivify_93
    new $P375, "Undef"
  vivify_93:
    store_lex "$sep", $P375
.annotate 'line', 536
    find_lex $P376, "$sep"
    set $S377, $P376
    find_lex $P378, "@path_parts"
    join $S379, $S377, $P378
    new $P380, 'String'
    set $P380, $S379
    store_lex "$joined", $P380
.annotate 'line', 537
    find_lex $P382, "@filename"
    unless $P382, if_381_end
    find_lex $P383, "$joined"
    find_lex $P384, "$sep"
    concat $P385, $P383, $P384
    find_lex $P386, "@filename"
    unless_null $P386, vivify_94
    $P386 = root_new ['parrot';'ResizablePMCArray']
  vivify_94:
    set $P387, $P386[0]
    unless_null $P387, vivify_95
    new $P387, "Undef"
  vivify_95:
    concat $P388, $P385, $P387
    store_lex "$joined", $P388
  if_381_end:
.annotate 'line', 539
    new $P389, "Exception"
    set $P389['type'], .CONTROL_RETURN
    find_lex $P390, "$joined"
    setattribute $P389, 'payload', $P390
    throw $P389
.annotate 'line', 531
    .return ()
  control_363:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P391, exception, "payload"
    .return ($P391)
.end


.namespace []
.include "except_types.pasm"
.sub "user_home_dir"  :subid("34_1277245056.4363") :outer("10_1277245056.4363")
.annotate 'line', 551
    new $P395, 'ExceptionHandler'
    set_addr $P395, control_394
    $P395."handle_types"(.CONTROL_RETURN)
    push_eh $P395
.annotate 'line', 552
    $P396 = root_new ['parrot';'Hash']
    .lex "%env", $P396
    new $P397, "ResizablePMCArray"
    push $P397, "parrot"
    push $P397, "Env"
    root_new $P398, $P397
    store_lex "%env", $P398
.annotate 'line', 553
    new $P399, "Exception"
    set $P399['type'], .CONTROL_RETURN
    find_lex $P401, "%env"
    unless_null $P401, vivify_96
    $P401 = root_new ['parrot';'Hash']
  vivify_96:
    set $P402, $P401["HOMEDRIVE"]
    unless_null $P402, vivify_97
    new $P402, "Undef"
  vivify_97:
    set $P400, $P402
    defined $I404, $P400
    if $I404, default_403
    new $P405, "String"
    assign $P405, ""
    set $P400, $P405
  default_403:
    find_lex $P406, "%env"
    unless_null $P406, vivify_98
    $P406 = root_new ['parrot';'Hash']
  vivify_98:
    set $P407, $P406["HOME"]
    unless_null $P407, vivify_99
    new $P407, "Undef"
  vivify_99:
    concat $P408, $P400, $P407
    setattribute $P399, 'payload', $P408
    throw $P399
.annotate 'line', 551
    .return ()
  control_394:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P409, exception, "payload"
    .return ($P409)
.end


.namespace []
.include "except_types.pasm"
.sub "path_exists"  :subid("35_1277245056.4363") :outer("10_1277245056.4363")
    .param pmc param_414
.annotate 'line', 566
    .const 'Sub' $P428 = "36_1277245056.4363" 
    capture_lex $P428
    new $P413, 'ExceptionHandler'
    set_addr $P413, control_412
    $P413."handle_types"(.CONTROL_RETURN)
    push_eh $P413
    new $P424, 'ExceptionHandler'
    set_addr $P424, control_423
    $P424."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P424
    .lex "$path", param_414
.annotate 'line', 567
    $P415 = root_new ['parrot';'ResizablePMCArray']
    .lex "@stat", $P415
    new $P416, "ResizablePMCArray"
    push $P416, "parrot"
    push $P416, "OS"
    root_new $P417, $P416
    find_lex $P418, "$path"
    $P419 = $P417."stat"($P418)
    store_lex "@stat", $P419
.annotate 'line', 568
    new $P420, "Exception"
    set $P420['type'], .CONTROL_RETURN
    new $P421, "Integer"
    assign $P421, 1
    setattribute $P420, 'payload', $P421
    throw $P420
.annotate 'line', 566
    pop_eh 
    goto skip_handler_422
  control_423:
.annotate 'line', 570
    .local pmc exception 
    .get_results (exception) 
    .const 'Sub' $P428 = "36_1277245056.4363" 
    newclosure $P433, $P428
    $P433(exception)
    new $P434, 'Integer'
    set $P434, 1
    set exception["handled"], $P434
    set $I435, exception["handled"]
    ne $I435, 1, nothandled_426
  handled_425:
    .return (exception)
  nothandled_426:
    rethrow exception
  skip_handler_422:
.annotate 'line', 566
    .return ()
  control_412:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P436, exception, "payload"
    .return ($P436)
.end


.namespace []
.include "except_types.pasm"
.sub "_block427"  :anon :subid("36_1277245056.4363") :outer("35_1277245056.4363")
    .param pmc param_429
.annotate 'line', 570
    .lex "$_", param_429
    find_lex $P430, "$_"
    .lex "$!", $P430
.annotate 'line', 571
    new $P431, "Exception"
    set $P431['type'], .CONTROL_RETURN
    new $P432, "Integer"
    assign $P432, 0
    setattribute $P431, 'payload', $P432
    throw $P431
.annotate 'line', 570
    .return ()
.end


.namespace []
.include "except_types.pasm"
.sub "is_dir"  :subid("37_1277245056.4363") :outer("10_1277245056.4363")
    .param pmc param_441
.annotate 'line', 585
    .const 'Sub' $P456 = "38_1277245056.4363" 
    capture_lex $P456
    new $P440, 'ExceptionHandler'
    set_addr $P440, control_439
    $P440."handle_types"(.CONTROL_RETURN)
    push_eh $P440
    new $P452, 'ExceptionHandler'
    set_addr $P452, control_451
    $P452."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P452
    .lex "$path", param_441
.annotate 'line', 586
    $P442 = root_new ['parrot';'ResizablePMCArray']
    .lex "@stat", $P442
    new $P443, "ResizablePMCArray"
    push $P443, "parrot"
    push $P443, "OS"
    root_new $P444, $P443
    find_lex $P445, "$path"
    $P446 = $P444."stat"($P445)
    store_lex "@stat", $P446
.annotate 'line', 587
    new $P447, "Exception"
    set $P447['type'], .CONTROL_RETURN
    find_lex $P448, "@stat"
    unless_null $P448, vivify_100
    $P448 = root_new ['parrot';'ResizablePMCArray']
  vivify_100:
    set $P449, $P448[2]
    unless_null $P449, vivify_101
    new $P449, "Undef"
  vivify_101:
    setattribute $P447, 'payload', $P449
    throw $P447
.annotate 'line', 585
    pop_eh 
    goto skip_handler_450
  control_451:
.annotate 'line', 589
    .local pmc exception 
    .get_results (exception) 
    .const 'Sub' $P456 = "38_1277245056.4363" 
    newclosure $P461, $P456
    $P461(exception)
    new $P462, 'Integer'
    set $P462, 1
    set exception["handled"], $P462
    set $I463, exception["handled"]
    ne $I463, 1, nothandled_454
  handled_453:
    .return (exception)
  nothandled_454:
    rethrow exception
  skip_handler_450:
.annotate 'line', 585
    .return ()
  control_439:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P464, exception, "payload"
    .return ($P464)
.end


.namespace []
.include "except_types.pasm"
.sub "_block455"  :anon :subid("38_1277245056.4363") :outer("37_1277245056.4363")
    .param pmc param_457
.annotate 'line', 589
    .lex "$_", param_457
    find_lex $P458, "$_"
    .lex "$!", $P458
.annotate 'line', 590
    new $P459, "Exception"
    set $P459['type'], .CONTROL_RETURN
    new $P460, "Integer"
    assign $P460, 0
    setattribute $P459, 'payload', $P460
    throw $P459
.annotate 'line', 589
    .return ()
.end


.namespace []
.include "except_types.pasm"
.sub "test_dir_writable"  :subid("39_1277245056.4363") :outer("10_1277245056.4363")
    .param pmc param_469
.annotate 'line', 612
    .const 'Sub' $P482 = "40_1277245056.4363" 
    capture_lex $P482
    new $P468, 'ExceptionHandler'
    set_addr $P468, control_467
    $P468."handle_types"(.CONTROL_RETURN)
    push_eh $P468
    .lex "$dir", param_469
.annotate 'line', 613
    new $P470, "Undef"
    .lex "$test_file", $P470
    find_lex $P471, "$dir"
    new $P472, "ResizablePMCArray"
    push $P472, $P471
    $P473 = "fscat"($P472, "WrItAbLe.UtL")
    store_lex "$test_file", $P473
.annotate 'line', 616
    find_lex $P475, "$test_file"
    $P476 = "path_exists"($P475)
    unless $P476, if_474_end
.annotate 'line', 615
    new $P477, 'String'
    set $P477, "Test file '"
    find_lex $P478, "$test_file"
    concat $P479, $P477, $P478
    concat $P480, $P479, "'\nthat should never exist already does."
    die $P480
  if_474_end:
.annotate 'line', 618
    .const 'Sub' $P482 = "40_1277245056.4363" 
    capture_lex $P482
    $P482()
.annotate 'line', 622
    find_lex $P494, "$test_file"
    $P495 = "path_exists"($P494)
    if $P495, if_493
.annotate 'line', 627
    new $P501, "Exception"
    set $P501['type'], .CONTROL_RETURN
    new $P502, "Integer"
    assign $P502, 0
    setattribute $P501, 'payload', $P502
    throw $P501
.annotate 'line', 626
    goto if_493_end
  if_493:
.annotate 'line', 623
    new $P496, "ResizablePMCArray"
    push $P496, "parrot"
    push $P496, "OS"
    root_new $P497, $P496
    find_lex $P498, "$test_file"
    $P497."rm"($P498)
.annotate 'line', 624
    new $P499, "Exception"
    set $P499['type'], .CONTROL_RETURN
    new $P500, "Integer"
    assign $P500, 1
    setattribute $P499, 'payload', $P500
    throw $P499
  if_493_end:
.annotate 'line', 612
    .return ($P492)
  control_467:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P503, exception, "payload"
    .return ($P503)
.end


.namespace []
.include "except_types.pasm"
.sub "_block481"  :anon :subid("40_1277245056.4363") :outer("39_1277245056.4363")
.annotate 'line', 618
    new $P487, 'ExceptionHandler'
    set_addr $P487, control_486
    $P487."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P487
.annotate 'line', 619
    find_lex $P483, "$test_file"
    $P484 = "spew"($P483, "test_dir_writable() test file.\n")
.annotate 'line', 618
    pop_eh 
    goto skip_handler_485
  control_486:
    .local pmc exception 
    .get_results (exception) 
    new $P490, 'Integer'
    set $P490, 1
    set exception["handled"], $P490
    set $I491, exception["handled"]
    ne $I491, 1, nothandled_489
  handled_488:
    .return (exception)
  nothandled_489:
    rethrow exception
  skip_handler_485:
    .return ($P484)
.end


.namespace []
.include "except_types.pasm"
.sub "find_program"  :subid("41_1277245056.4363") :outer("10_1277245056.4363")
    .param pmc param_508
.annotate 'line', 651
    .const 'Sub' $P546 = "42_1277245056.4363" 
    capture_lex $P546
    new $P507, 'ExceptionHandler'
    set_addr $P507, control_506
    $P507."handle_types"(.CONTROL_RETURN)
    push_eh $P507
    .lex "$program", param_508
.annotate 'line', 652
    new $P509, "Undef"
    .lex "$interp", $P509
.annotate 'line', 653
    new $P510, "Undef"
    .lex "$path_sep", $P510
.annotate 'line', 654
    $P511 = root_new ['parrot';'Hash']
    .lex "%env", $P511
.annotate 'line', 655
    $P512 = root_new ['parrot';'ResizablePMCArray']
    .lex "@paths", $P512
.annotate 'line', 656
    $P513 = root_new ['parrot';'ResizablePMCArray']
    .lex "@exts", $P513
.annotate 'line', 652
    getinterp $P514
    store_lex "$interp", $P514
.annotate 'line', 653
    new $P517, "String"
    assign $P517, "osname"
    set $I518, $P517
    get_hll_global $P519, "interp"
    unless_null $P519, vivify_102
    $P519 = root_new ['parrot';'ResizablePMCArray']
  vivify_102:
    set $P520, $P519[8]
    unless_null $P520, vivify_103
    $P520 = root_new ['parrot';'ResizablePMCArray']
  vivify_103:
    set $P521, $P520[$I518]
    unless_null $P521, vivify_104
    new $P521, "Undef"
  vivify_104:
    set $S522, $P521
    iseq $I523, $S522, "MSWin32"
    if $I523, if_516
    new $P525, "String"
    assign $P525, ":"
    set $P515, $P525
    goto if_516_end
  if_516:
    new $P524, "String"
    assign $P524, ";"
    set $P515, $P524
  if_516_end:
    store_lex "$path_sep", $P515
.annotate 'line', 654
    new $P526, "ResizablePMCArray"
    push $P526, "parrot"
    push $P526, "Env"
    root_new $P527, $P526
    store_lex "%env", $P527
.annotate 'line', 655
    find_lex $P528, "$path_sep"
    set $S529, $P528
    find_lex $P530, "%env"
    unless_null $P530, vivify_105
    $P530 = root_new ['parrot';'Hash']
  vivify_105:
    set $P531, $P530["PATH"]
    unless_null $P531, vivify_106
    new $P531, "Undef"
  vivify_106:
    set $S532, $P531
    split $P533, $S529, $S532
    store_lex "@paths", $P533
.annotate 'line', 656
    find_lex $P534, "$path_sep"
    set $S535, $P534
    find_lex $P536, "%env"
    unless_null $P536, vivify_107
    $P536 = root_new ['parrot';'Hash']
  vivify_107:
    set $P537, $P536["PATHEXT"]
    unless_null $P537, vivify_108
    new $P537, "Undef"
  vivify_108:
    set $S538, $P537
    split $P539, $S535, $S538
    store_lex "@exts", $P539
.annotate 'line', 658
    find_lex $P540, "@exts"
    $P540."unshift"("")
.annotate 'line', 660
    find_lex $P542, "@paths"
    defined $I543, $P542
    unless $I543, for_undef_109
    iter $P541, $P542
    new $P574, 'ExceptionHandler'
    set_addr $P574, loop573_handler
    $P574."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P574
  loop573_test:
    unless $P541, loop573_done
    shift $P544, $P541
  loop573_redo:
    .const 'Sub' $P546 = "42_1277245056.4363" 
    capture_lex $P546
    $P546($P544)
  loop573_next:
    goto loop573_test
  loop573_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P575, exception, 'type'
    eq $P575, .CONTROL_LOOP_NEXT, loop573_next
    eq $P575, .CONTROL_LOOP_REDO, loop573_redo
  loop573_done:
    pop_eh 
  for_undef_109:
.annotate 'line', 669
    new $P576, "Exception"
    set $P576['type'], .CONTROL_RETURN
    new $P577, "String"
    assign $P577, ""
    setattribute $P576, 'payload', $P577
    throw $P576
.annotate 'line', 651
    .return ()
  control_506:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P578, exception, "payload"
    .return ($P578)
.end


.namespace []
.include "except_types.pasm"
.sub "_block545"  :anon :subid("42_1277245056.4363") :outer("41_1277245056.4363")
    .param pmc param_547
.annotate 'line', 660
    .const 'Sub' $P558 = "43_1277245056.4363" 
    capture_lex $P558
    .lex "$dir", param_547
.annotate 'line', 661
    new $P548, "Undef"
    .lex "$path", $P548
    find_lex $P549, "$dir"
    new $P550, "ResizablePMCArray"
    push $P550, $P549
    find_lex $P551, "$program"
    $P552 = "fscat"($P550, $P551)
    store_lex "$path", $P552
.annotate 'line', 663
    find_lex $P554, "@exts"
    defined $I555, $P554
    unless $I555, for_undef_110
    iter $P553, $P554
    new $P571, 'ExceptionHandler'
    set_addr $P571, loop570_handler
    $P571."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P571
  loop570_test:
    unless $P553, loop570_done
    shift $P556, $P553
  loop570_redo:
    .const 'Sub' $P558 = "43_1277245056.4363" 
    capture_lex $P558
    $P558($P556)
  loop570_next:
    goto loop570_test
  loop570_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P572, exception, 'type'
    eq $P572, .CONTROL_LOOP_NEXT, loop570_next
    eq $P572, .CONTROL_LOOP_REDO, loop570_redo
  loop570_done:
    pop_eh 
  for_undef_110:
.annotate 'line', 660
    .return ($P553)
.end


.namespace []
.include "except_types.pasm"
.sub "_block557"  :anon :subid("43_1277245056.4363") :outer("42_1277245056.4363")
    .param pmc param_559
.annotate 'line', 663
    .lex "$ext", param_559
.annotate 'line', 664
    new $P560, "Undef"
    .lex "$pathext", $P560
    find_lex $P561, "$path"
    find_lex $P562, "$ext"
    concat $P563, $P561, $P562
    store_lex "$pathext", $P563
.annotate 'line', 665
    find_lex $P566, "$pathext"
    $P567 = "path_exists"($P566)
    if $P567, if_565
    set $P564, $P567
    goto if_565_end
  if_565:
    new $P568, "Exception"
    set $P568['type'], .CONTROL_RETURN
    find_lex $P569, "$pathext"
    setattribute $P568, 'payload', $P569
    throw $P568
  if_565_end:
.annotate 'line', 663
    .return ($P564)
.end


.namespace []
.include "except_types.pasm"
.sub "mkpath"  :subid("44_1277245056.4363") :outer("10_1277245056.4363")
    .param pmc param_583
.annotate 'line', 682
    .const 'Sub' $P596 = "45_1277245056.4363" 
    capture_lex $P596
    new $P582, 'ExceptionHandler'
    set_addr $P582, control_581
    $P582."handle_types"(.CONTROL_RETURN)
    push_eh $P582
    .lex "$path", param_583
.annotate 'line', 683
    $P584 = root_new ['parrot';'ResizablePMCArray']
    .lex "@path", $P584
.annotate 'line', 684
    new $P585, "Undef"
    .lex "$cur", $P585
.annotate 'line', 683
    find_lex $P586, "$path"
    set $S587, $P586
    split $P588, "/", $S587
    store_lex "@path", $P588
.annotate 'line', 684
    find_lex $P589, "@path"
    $P590 = $P589."shift"()
    store_lex "$cur", $P590
.annotate 'line', 686
    find_lex $P592, "@path"
    defined $I593, $P592
    unless $I593, for_undef_111
    iter $P591, $P592
    new $P611, 'ExceptionHandler'
    set_addr $P611, loop610_handler
    $P611."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P611
  loop610_test:
    unless $P591, loop610_done
    shift $P594, $P591
  loop610_redo:
    .const 'Sub' $P596 = "45_1277245056.4363" 
    capture_lex $P596
    $P596($P594)
  loop610_next:
    goto loop610_test
  loop610_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P612, exception, 'type'
    eq $P612, .CONTROL_LOOP_NEXT, loop610_next
    eq $P612, .CONTROL_LOOP_REDO, loop610_redo
  loop610_done:
    pop_eh 
  for_undef_111:
.annotate 'line', 682
    .return ($P591)
  control_581:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P613, exception, "payload"
    .return ($P613)
.end


.namespace []
.sub "_block595"  :anon :subid("45_1277245056.4363") :outer("44_1277245056.4363")
    .param pmc param_597
.annotate 'line', 686
    .lex "$dir", param_597
.annotate 'line', 687
    find_lex $P598, "$cur"
    find_lex $P599, "$dir"
    new $P600, "ResizablePMCArray"
    push $P600, $P598
    push $P600, $P599
    $P601 = "fscat"($P600)
    store_lex "$cur", $P601
.annotate 'line', 689
    find_lex $P604, "$cur"
    $P605 = "path_exists"($P604)
    unless $P605, unless_603
    set $P602, $P605
    goto unless_603_end
  unless_603:
.annotate 'line', 690
    new $P606, "ResizablePMCArray"
    push $P606, "parrot"
    push $P606, "OS"
    root_new $P607, $P606
    find_lex $P608, "$cur"
    $P609 = $P607."mkdir"($P608, 511)
.annotate 'line', 689
    set $P602, $P609
  unless_603_end:
.annotate 'line', 686
    .return ($P602)
.end


.namespace []
.include "except_types.pasm"
.sub "run"  :subid("46_1277245056.4363") :outer("10_1277245056.4363")
    .param pmc param_618 :slurpy
.annotate 'line', 717
    new $P617, 'ExceptionHandler'
    set_addr $P617, control_616
    $P617."handle_types"(.CONTROL_RETURN)
    push_eh $P617
    .lex "@command_and_args", param_618
.annotate 'line', 718
    new $P619, "Undef"
    .lex "$aux", $P619
.annotate 'line', 719
    new $P620, "Undef"
    .lex "$ret", $P620
.annotate 'line', 718
    find_lex $P621, "@command_and_args"
    spawnw $I622, $P621
    new $P623, 'Integer'
    set $P623, $I622
    store_lex "$aux", $P623
.annotate 'line', 719

        $P0 = find_lex '$aux'
        $I0 = $P0
        $I1 = shr $I0, 8
        $P624 = box $I1
    
    store_lex "$ret", $P624
.annotate 'line', 725
    new $P625, "Exception"
    set $P625['type'], .CONTROL_RETURN
    find_lex $P626, "$ret"
    setattribute $P625, 'payload', $P626
    throw $P625
.annotate 'line', 717
    .return ()
  control_616:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P627, exception, "payload"
    .return ($P627)
.end


.namespace []
.include "except_types.pasm"
.sub "do_run"  :subid("47_1277245056.4363") :outer("10_1277245056.4363")
    .param pmc param_632 :slurpy
.annotate 'line', 742
    .const 'Sub' $P648 = "48_1277245056.4363" 
    capture_lex $P648
    new $P631, 'ExceptionHandler'
    set_addr $P631, control_630
    $P631."handle_types"(.CONTROL_RETURN)
    push_eh $P631
    new $P644, 'ExceptionHandler'
    set_addr $P644, control_643
    $P644."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P644
    .lex "@command_and_args", param_632
.annotate 'line', 743
    find_lex $P633, "@command_and_args"
    join $S634, " ", $P633
    "say"($S634)
.annotate 'line', 745
    new $P635, "Exception"
    set $P635['type'], .CONTROL_RETURN
    find_lex $P638, "@command_and_args"
    spawnw $I639, $P638
    if $I639, if_637
    new $P641, "Integer"
    assign $P641, 1
    set $P636, $P641
    goto if_637_end
  if_637:
    new $P640, "Integer"
    assign $P640, 0
    set $P636, $P640
  if_637_end:
    setattribute $P635, 'payload', $P636
    throw $P635
.annotate 'line', 742
    pop_eh 
    goto skip_handler_642
  control_643:
.annotate 'line', 747
    .local pmc exception 
    .get_results (exception) 
    .const 'Sub' $P648 = "48_1277245056.4363" 
    newclosure $P653, $P648
    $P653(exception)
    new $P654, 'Integer'
    set $P654, 1
    set exception["handled"], $P654
    set $I655, exception["handled"]
    ne $I655, 1, nothandled_646
  handled_645:
    .return (exception)
  nothandled_646:
    rethrow exception
  skip_handler_642:
.annotate 'line', 742
    .return ()
  control_630:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P656, exception, "payload"
    .return ($P656)
.end


.namespace []
.include "except_types.pasm"
.sub "_block647"  :anon :subid("48_1277245056.4363") :outer("47_1277245056.4363")
    .param pmc param_649
.annotate 'line', 747
    .lex "$_", param_649
    find_lex $P650, "$_"
    .lex "$!", $P650
.annotate 'line', 748
    new $P651, "Exception"
    set $P651['type'], .CONTROL_RETURN
    new $P652, "Integer"
    assign $P652, 0
    setattribute $P651, 'payload', $P652
    throw $P651
.annotate 'line', 747
    .return ()
.end


.namespace []
.include "except_types.pasm"
.sub "qx"  :subid("49_1277245056.4363") :outer("10_1277245056.4363")
    .param pmc param_661 :slurpy
.annotate 'line', 766
    new $P660, 'ExceptionHandler'
    set_addr $P660, control_659
    $P660."handle_types"(.CONTROL_RETURN)
    push_eh $P660
    .lex "@command_and_args", param_661
.annotate 'line', 767
    new $P662, "Undef"
    .lex "$cmd", $P662
.annotate 'line', 768
    new $P663, "Undef"
    .lex "$pipe", $P663
.annotate 'line', 773
    new $P664, "Undef"
    .lex "$output", $P664
.annotate 'line', 767
    find_lex $P665, "@command_and_args"
    join $S666, " ", $P665
    new $P667, 'String'
    set $P667, $S666
    store_lex "$cmd", $P667
.annotate 'line', 768
    new $P668, "FileHandle"
    store_lex "$pipe", $P668
.annotate 'line', 769
    find_lex $P669, "$pipe"
    find_lex $P670, "$cmd"
    $P669."open"($P670, "rp")
.annotate 'line', 770
    find_lex $P672, "$pipe"
    if $P672, unless_671_end
    new $P673, 'String'
    set $P673, "Unable to execute '"
    find_lex $P674, "$cmd"
    concat $P675, $P673, $P674
    concat $P676, $P675, "'"
    die $P676
  unless_671_end:
.annotate 'line', 772
    find_lex $P677, "$pipe"
    $P677."encoding"("utf8")
.annotate 'line', 773
    find_lex $P678, "$pipe"
    $P679 = $P678."readall"()
    store_lex "$output", $P679
.annotate 'line', 774
    find_lex $P680, "$pipe"
    $P680."close"()
.annotate 'line', 776
    find_lex $P681, "$pipe"
    $P682 = $P681."exit_status"()
    "store_dynlex_safely"("$!", $P682)
.annotate 'line', 778
    new $P683, "Exception"
    set $P683['type'], .CONTROL_RETURN
    find_lex $P684, "$output"
    setattribute $P683, 'payload', $P684
    throw $P683
.annotate 'line', 766
    .return ()
  control_659:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P685, exception, "payload"
    .return ($P685)
.end


.namespace []
.include "except_types.pasm"
.sub "eval"  :subid("50_1277245056.4363") :outer("10_1277245056.4363")
    .param pmc param_690
    .param pmc param_691
.annotate 'line', 801
    new $P689, 'ExceptionHandler'
    set_addr $P689, control_688
    $P689."handle_types"(.CONTROL_RETURN)
    push_eh $P689
    .lex "$source_code", param_690
    .lex "$language", param_691
.annotate 'line', 805
    new $P692, "Undef"
    .lex "$compiler", $P692
.annotate 'line', 802
    find_lex $P693, "$language"
    set $S694, $P693
    downcase $S695, $S694
    new $P696, 'String'
    set $P696, $S695
    store_lex "$language", $P696
.annotate 'line', 804
    find_lex $P697, "$language"
    set $S698, $P697
    load_language $S698
.annotate 'line', 805
    find_lex $P699, "$language"
    set $S700, $P699
    compreg $P701, $S700
    store_lex "$compiler", $P701
.annotate 'line', 807
    new $P702, "Exception"
    set $P702['type'], .CONTROL_RETURN
    find_lex $P703, "$compiler"
    find_lex $P704, "$source_code"
    $P705 = $P703."compile"($P704)
    $P706 = $P705()
    setattribute $P702, 'payload', $P706
    throw $P702
.annotate 'line', 801
    .return ()
  control_688:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P707, exception, "payload"
    .return ($P707)
.end


.namespace []
.include "except_types.pasm"
.sub "store_dynlex_safely"  :subid("51_1277245056.4363") :outer("10_1277245056.4363")
    .param pmc param_712
    .param pmc param_713
.annotate 'line', 831
    new $P711, 'ExceptionHandler'
    set_addr $P711, control_710
    $P711."handle_types"(.CONTROL_RETURN)
    push_eh $P711
    .lex "$var_name", param_712
    .lex "$value", param_713
.annotate 'line', 833
    find_lex $P716, "$var_name"
    set $S717, $P716
    find_dynamic_lex $P718, $S717
    isnull $I719, $P718
    unless $I719, unless_715
    new $P714, 'Integer'
    set $P714, $I719
    goto unless_715_end
  unless_715:
.annotate 'line', 832
    find_lex $P720, "$var_name"
    set $S721, $P720
    find_lex $P722, "$value"
    store_dynamic_lex $S721, $P722
  unless_715_end:
.annotate 'line', 831
    .return ($P714)
  control_710:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P723, exception, "payload"
    .return ($P723)
.end


.namespace ["Hash"]
.sub "_block725"  :subid("52_1277245056.4363") :outer("10_1277245056.4363")
.annotate 'line', 81
    .const 'Sub' $P776 = "58_1277245056.4363" 
    capture_lex $P776
    .const 'Sub' $P755 = "56_1277245056.4363" 
    capture_lex $P755
    .const 'Sub' $P734 = "54_1277245056.4363" 
    capture_lex $P734
    .const 'Sub' $P727 = "53_1277245056.4363" 
    capture_lex $P727
.annotate 'line', 144
    .const 'Sub' $P776 = "58_1277245056.4363" 
    newclosure $P800, $P776
.annotate 'line', 81
    .return ($P800)
.end


.namespace ["Hash"]
.include "except_types.pasm"
.sub "exists"  :subid("53_1277245056.4363") :method :outer("52_1277245056.4363")
    .param pmc param_730
.annotate 'line', 94
    new $P729, 'ExceptionHandler'
    set_addr $P729, control_728
    $P729."handle_types"(.CONTROL_RETURN)
    push_eh $P729
    .lex "self", self
    .lex "$key", param_730
.annotate 'line', 95
    new $P731, "Exception"
    set $P731['type'], .CONTROL_RETURN

            $P1 = find_lex '$key'
            $I0 = exists self[$P1]
            $P732  = box $I0
        
    setattribute $P731, 'payload', $P732
    throw $P731
.annotate 'line', 94
    .return ()
  control_728:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P733, exception, "payload"
    .return ($P733)
.end


.namespace ["Hash"]
.include "except_types.pasm"
.sub "keys"  :subid("54_1277245056.4363") :method :outer("52_1277245056.4363")
.annotate 'line', 111
    .const 'Sub' $P744 = "55_1277245056.4363" 
    capture_lex $P744
    new $P736, 'ExceptionHandler'
    set_addr $P736, control_735
    $P736."handle_types"(.CONTROL_RETURN)
    push_eh $P736
    .lex "self", self
.annotate 'line', 112
    $P737 = root_new ['parrot';'ResizablePMCArray']
    .lex "@keys", $P737
.annotate 'line', 111
    find_lex $P738, "@keys"
.annotate 'line', 113
    find_lex $P740, "self"
    defined $I741, $P740
    unless $I741, for_undef_112
    iter $P739, $P740
    new $P751, 'ExceptionHandler'
    set_addr $P751, loop750_handler
    $P751."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P751
  loop750_test:
    unless $P739, loop750_done
    shift $P742, $P739
  loop750_redo:
    .const 'Sub' $P744 = "55_1277245056.4363" 
    capture_lex $P744
    $P744($P742)
  loop750_next:
    goto loop750_test
  loop750_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P752, exception, 'type'
    eq $P752, .CONTROL_LOOP_NEXT, loop750_next
    eq $P752, .CONTROL_LOOP_REDO, loop750_redo
  loop750_done:
    pop_eh 
  for_undef_112:
    find_lex $P753, "@keys"
.annotate 'line', 111
    .return ($P753)
  control_735:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P754, exception, "payload"
    .return ($P754)
.end


.namespace ["Hash"]
.sub "_block743"  :anon :subid("55_1277245056.4363") :outer("54_1277245056.4363")
    .param pmc param_745
.annotate 'line', 113
    .lex "$_", param_745
    find_lex $P746, "@keys"
    find_lex $P747, "$_"
    $P748 = $P747."key"()
    $P749 = $P746."push"($P748)
    .return ($P749)
.end


.namespace ["Hash"]
.include "except_types.pasm"
.sub "values"  :subid("56_1277245056.4363") :method :outer("52_1277245056.4363")
.annotate 'line', 126
    .const 'Sub' $P765 = "57_1277245056.4363" 
    capture_lex $P765
    new $P757, 'ExceptionHandler'
    set_addr $P757, control_756
    $P757."handle_types"(.CONTROL_RETURN)
    push_eh $P757
    .lex "self", self
.annotate 'line', 127
    $P758 = root_new ['parrot';'ResizablePMCArray']
    .lex "@values", $P758
.annotate 'line', 126
    find_lex $P759, "@values"
.annotate 'line', 128
    find_lex $P761, "self"
    defined $I762, $P761
    unless $I762, for_undef_113
    iter $P760, $P761
    new $P772, 'ExceptionHandler'
    set_addr $P772, loop771_handler
    $P772."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P772
  loop771_test:
    unless $P760, loop771_done
    shift $P763, $P760
  loop771_redo:
    .const 'Sub' $P765 = "57_1277245056.4363" 
    capture_lex $P765
    $P765($P763)
  loop771_next:
    goto loop771_test
  loop771_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P773, exception, 'type'
    eq $P773, .CONTROL_LOOP_NEXT, loop771_next
    eq $P773, .CONTROL_LOOP_REDO, loop771_redo
  loop771_done:
    pop_eh 
  for_undef_113:
    find_lex $P774, "@values"
.annotate 'line', 126
    .return ($P774)
  control_756:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P775, exception, "payload"
    .return ($P775)
.end


.namespace ["Hash"]
.sub "_block764"  :anon :subid("57_1277245056.4363") :outer("56_1277245056.4363")
    .param pmc param_766
.annotate 'line', 128
    .lex "$_", param_766
    find_lex $P767, "@values"
    find_lex $P768, "$_"
    $P769 = $P768."value"()
    $P770 = $P767."push"($P769)
    .return ($P770)
.end


.namespace ["Hash"]
.include "except_types.pasm"
.sub "kv"  :subid("58_1277245056.4363") :method :outer("52_1277245056.4363")
.annotate 'line', 144
    .const 'Sub' $P786 = "59_1277245056.4363" 
    capture_lex $P786
    new $P778, 'ExceptionHandler'
    set_addr $P778, control_777
    $P778."handle_types"(.CONTROL_RETURN)
    push_eh $P778
    .lex "self", self
.annotate 'line', 145
    $P779 = root_new ['parrot';'ResizablePMCArray']
    .lex "@kv", $P779
.annotate 'line', 144
    find_lex $P780, "@kv"
.annotate 'line', 146
    find_lex $P782, "self"
    defined $I783, $P782
    unless $I783, for_undef_114
    iter $P781, $P782
    new $P796, 'ExceptionHandler'
    set_addr $P796, loop795_handler
    $P796."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P796
  loop795_test:
    unless $P781, loop795_done
    shift $P784, $P781
  loop795_redo:
    .const 'Sub' $P786 = "59_1277245056.4363" 
    capture_lex $P786
    $P786($P784)
  loop795_next:
    goto loop795_test
  loop795_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P797, exception, 'type'
    eq $P797, .CONTROL_LOOP_NEXT, loop795_next
    eq $P797, .CONTROL_LOOP_REDO, loop795_redo
  loop795_done:
    pop_eh 
  for_undef_114:
    find_lex $P798, "@kv"
.annotate 'line', 144
    .return ($P798)
  control_777:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P799, exception, "payload"
    .return ($P799)
.end


.namespace ["Hash"]
.sub "_block785"  :anon :subid("59_1277245056.4363") :outer("58_1277245056.4363")
    .param pmc param_787
.annotate 'line', 146
    .lex "$_", param_787
    find_lex $P788, "@kv"
    find_lex $P789, "$_"
    $P790 = $P789."key"()
    $P788."push"($P790)
    find_lex $P791, "@kv"
    find_lex $P792, "$_"
    $P793 = $P792."value"()
    $P794 = $P791."push"($P793)
    .return ($P794)
.end


.namespace ["Array"]
.sub "_block801"  :subid("60_1277245056.4363") :outer("10_1277245056.4363")
.annotate 'line', 169
    .const 'Sub' $P803 = "61_1277245056.4363" 
    capture_lex $P803
.annotate 'line', 182
    .const 'Sub' $P803 = "61_1277245056.4363" 
    newclosure $P823, $P803
.annotate 'line', 169
    .return ($P823)
.end


.namespace ["Array"]
.include "except_types.pasm"
.sub "reverse"  :subid("61_1277245056.4363") :method :outer("60_1277245056.4363")
.annotate 'line', 182
    .const 'Sub' $P813 = "62_1277245056.4363" 
    capture_lex $P813
    new $P805, 'ExceptionHandler'
    set_addr $P805, control_804
    $P805."handle_types"(.CONTROL_RETURN)
    push_eh $P805
    .lex "self", self
.annotate 'line', 183
    $P806 = root_new ['parrot';'ResizablePMCArray']
    .lex "@reversed", $P806
.annotate 'line', 182
    find_lex $P807, "@reversed"
.annotate 'line', 184
    find_lex $P809, "self"
    defined $I810, $P809
    unless $I810, for_undef_115
    iter $P808, $P809
    new $P819, 'ExceptionHandler'
    set_addr $P819, loop818_handler
    $P819."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P819
  loop818_test:
    unless $P808, loop818_done
    shift $P811, $P808
  loop818_redo:
    .const 'Sub' $P813 = "62_1277245056.4363" 
    capture_lex $P813
    $P813($P811)
  loop818_next:
    goto loop818_test
  loop818_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P820, exception, 'type'
    eq $P820, .CONTROL_LOOP_NEXT, loop818_next
    eq $P820, .CONTROL_LOOP_REDO, loop818_redo
  loop818_done:
    pop_eh 
  for_undef_115:
    find_lex $P821, "@reversed"
.annotate 'line', 182
    .return ($P821)
  control_804:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P822, exception, "payload"
    .return ($P822)
.end


.namespace ["Array"]
.sub "_block812"  :anon :subid("62_1277245056.4363") :outer("61_1277245056.4363")
    .param pmc param_814
.annotate 'line', 184
    .lex "$_", param_814
    find_lex $P815, "@reversed"
    find_lex $P816, "$_"
    $P817 = $P815."unshift"($P816)
    .return ($P817)
.end


.namespace []
.sub "_block849" :load :anon :subid("63_1277245056.4363")
.annotate 'line', 1
    .const 'Sub' $P851 = "10_1277245056.4363" 
    $P852 = $P851()
    .return ($P852)
.end

