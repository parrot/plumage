
.namespace []
.sub "_block11"  :anon :subid("10_1268956021.99384")
.annotate "line", 0
    .const 'Sub' $P810 = "63_1268956021.99384" 
    capture_lex $P810
    get_hll_global $P763, ["Array"], "_block762" 
    capture_lex $P763
    get_hll_global $P688, ["Hash"], "_block687" 
    capture_lex $P688
    .const 'Sub' $P672 = "51_1268956021.99384" 
    capture_lex $P672
    .const 'Sub' $P651 = "50_1268956021.99384" 
    capture_lex $P651
    .const 'Sub' $P623 = "49_1268956021.99384" 
    capture_lex $P623
    .const 'Sub' $P596 = "47_1268956021.99384" 
    capture_lex $P596
    .const 'Sub' $P586 = "46_1268956021.99384" 
    capture_lex $P586
    .const 'Sub' $P552 = "44_1268956021.99384" 
    capture_lex $P552
    .const 'Sub' $P485 = "41_1268956021.99384" 
    capture_lex $P485
    .const 'Sub' $P447 = "39_1268956021.99384" 
    capture_lex $P447
    .const 'Sub' $P419 = "37_1268956021.99384" 
    capture_lex $P419
    .const 'Sub' $P394 = "35_1268956021.99384" 
    capture_lex $P394
    .const 'Sub' $P377 = "34_1268956021.99384" 
    capture_lex $P377
    .const 'Sub' $P347 = "33_1268956021.99384" 
    capture_lex $P347
    .const 'Sub' $P334 = "32_1268956021.99384" 
    capture_lex $P334
    .const 'Sub' $P321 = "31_1268956021.99384" 
    capture_lex $P321
    .const 'Sub' $P306 = "30_1268956021.99384" 
    capture_lex $P306
    .const 'Sub' $P299 = "29_1268956021.99384" 
    capture_lex $P299
    .const 'Sub' $P283 = "27_1268956021.99384" 
    capture_lex $P283
    .const 'Sub' $P222 = "25_1268956021.99384" 
    capture_lex $P222
    .const 'Sub' $P195 = "24_1268956021.99384" 
    capture_lex $P195
    .const 'Sub' $P173 = "22_1268956021.99384" 
    capture_lex $P173
    .const 'Sub' $P166 = "21_1268956021.99384" 
    capture_lex $P166
    .const 'Sub' $P141 = "19_1268956021.99384" 
    capture_lex $P141
    .const 'Sub' $P66 = "15_1268956021.99384" 
    capture_lex $P66
    .const 'Sub' $P38 = "13_1268956021.99384" 
    capture_lex $P38
    .const 'Sub' $P13 = "11_1268956021.99384" 
    capture_lex $P13
.annotate "line", 216
    .const 'Sub' $P13 = "11_1268956021.99384" 
    capture_lex $P13
    .lex "map", $P13
.annotate "line", 236
    .const 'Sub' $P38 = "13_1268956021.99384" 
    capture_lex $P38
    .lex "grep", $P38
.annotate "line", 268
    .const 'Sub' $P66 = "15_1268956021.99384" 
    capture_lex $P66
    .lex "reduce", $P66
.annotate "line", 296
    .const 'Sub' $P141 = "19_1268956021.99384" 
    capture_lex $P141
    .lex "_reduce", $P141
.annotate "line", 324
    .const 'Sub' $P166 = "21_1268956021.99384" 
    capture_lex $P166
    .lex "hash", $P166
.annotate "line", 337
    .const 'Sub' $P173 = "22_1268956021.99384" 
    capture_lex $P173
    .lex "set_from_array", $P173
.annotate "line", 364
    .const 'Sub' $P195 = "24_1268956021.99384" 
    capture_lex $P195
    .lex "all_matches", $P195
.annotate "line", 391
    .const 'Sub' $P222 = "25_1268956021.99384" 
    capture_lex $P222
    .lex "subst", $P222
.annotate "line", 440
    .const 'Sub' $P283 = "27_1268956021.99384" 
    capture_lex $P283
    .lex "print", $P283
.annotate "line", 455
    .const 'Sub' $P299 = "29_1268956021.99384" 
    capture_lex $P299
    .lex "say", $P299
.annotate "line", 468
    .const 'Sub' $P306 = "30_1268956021.99384" 
    capture_lex $P306
    .lex "slurp", $P306
.annotate "line", 485
    .const 'Sub' $P321 = "31_1268956021.99384" 
    capture_lex $P321
    .lex "spew", $P321
.annotate "line", 500
    .const 'Sub' $P334 = "32_1268956021.99384" 
    capture_lex $P334
    .lex "append", $P334
.annotate "line", 528
    .const 'Sub' $P347 = "33_1268956021.99384" 
    capture_lex $P347
    .lex "fscat", $P347
.annotate "line", 548
    .const 'Sub' $P377 = "34_1268956021.99384" 
    capture_lex $P377
    .lex "user_home_dir", $P377
.annotate "line", 563
    .const 'Sub' $P394 = "35_1268956021.99384" 
    capture_lex $P394
    .lex "path_exists", $P394
.annotate "line", 582
    .const 'Sub' $P419 = "37_1268956021.99384" 
    capture_lex $P419
    .lex "is_dir", $P419
.annotate "line", 609
    .const 'Sub' $P447 = "39_1268956021.99384" 
    capture_lex $P447
    .lex "test_dir_writable", $P447
.annotate "line", 648
    .const 'Sub' $P485 = "41_1268956021.99384" 
    capture_lex $P485
    .lex "find_program", $P485
.annotate "line", 678
    .const 'Sub' $P552 = "44_1268956021.99384" 
    capture_lex $P552
    .lex "mkpath", $P552
.annotate "line", 713
    .const 'Sub' $P586 = "46_1268956021.99384" 
    capture_lex $P586
    .lex "run", $P586
.annotate "line", 731
    .const 'Sub' $P596 = "47_1268956021.99384" 
    capture_lex $P596
    .lex "do_run", $P596
.annotate "line", 755
    .const 'Sub' $P623 = "49_1268956021.99384" 
    capture_lex $P623
    .lex "qx", $P623
.annotate "line", 789
    .const 'Sub' $P651 = "50_1268956021.99384" 
    capture_lex $P651
    .lex "eval", $P651
.annotate "line", 819
    .const 'Sub' $P672 = "51_1268956021.99384" 
    capture_lex $P672
    .lex "store_dynlex_safely", $P672
.annotate "line", 81
    get_hll_global $P688, ["Hash"], "_block687" 
    capture_lex $P688
    $P688()
.annotate "line", 169
    get_hll_global $P763, ["Array"], "_block762" 
    capture_lex $P763
    $P763()
    find_lex $P784, "map"
    find_lex $P785, "grep"
    find_lex $P786, "reduce"
    find_lex $P787, "_reduce"
    find_lex $P788, "hash"
    find_lex $P789, "set_from_array"
    find_lex $P790, "all_matches"
    find_lex $P791, "subst"
    find_lex $P792, "print"
    find_lex $P793, "say"
    find_lex $P794, "slurp"
    find_lex $P795, "spew"
    find_lex $P796, "append"
    find_lex $P797, "fscat"
    find_lex $P798, "user_home_dir"
    find_lex $P799, "path_exists"
    find_lex $P800, "is_dir"
    find_lex $P801, "test_dir_writable"
    find_lex $P802, "find_program"
    find_lex $P803, "mkpath"
    find_lex $P804, "run"
    find_lex $P805, "do_run"
    find_lex $P806, "qx"
    find_lex $P807, "eval"
    find_lex $P808, "store_dynlex_safely"
.annotate "line", 1
    .return ()
.end


.namespace []
.sub "" :load :init :subid("post64") :outer("10_1268956021.99384")
.annotate "line", 0
    .const 'Sub' $P12 = "10_1268956021.99384" 
    .local pmc block
    set block, $P12
.annotate "line", 873
    .const 'Sub' $P810 = "63_1268956021.99384" 
    capture_lex $P810
    $P810()
.end


.namespace []
.sub "_block809"  :anon :subid("63_1268956021.99384") :outer("10_1268956021.99384")
.annotate "line", 878
    new $P811, "Undef"
    .lex "$interp", $P811
.annotate "line", 879
    $P812 = root_new ['parrot';'ResizablePMCArray']
    .lex "@argv", $P812
.annotate "line", 880
    new $P813, "Undef"
    .lex "$config", $P813
.annotate "line", 883
    $P814 = root_new ['parrot';'Hash']
    .lex "%vm", $P814
.annotate "line", 875
    load_bytecode "config.pbc"
.annotate "line", 876
    load_bytecode "P6Regex.pbc"
.annotate "line", 878
    getinterp $P815
    store_lex "$interp", $P815
.annotate "line", 879
    find_lex $P816, "$interp"
    unless_null $P816, vivify_65
    $P816 = root_new ['parrot';'ResizablePMCArray']
  vivify_65:
    set $P817, $P816[2]
    unless_null $P817, vivify_66
    new $P817, "Undef"
  vivify_66:
    store_lex "@argv", $P817
.annotate "line", 880
    find_lex $P818, "$interp"
    unless_null $P818, vivify_67
    $P818 = root_new ['parrot';'ResizablePMCArray']
  vivify_67:
    set $P819, $P818[6]
    unless_null $P819, vivify_68
    new $P819, "Undef"
  vivify_68:
    store_lex "$config", $P819
    find_lex $P820, "%vm"
.annotate "line", 884
    find_lex $P821, "$config"
    find_lex $P822, "%vm"
    unless_null $P822, vivify_69
    $P822 = root_new ['parrot';'Hash']
    store_lex "%vm", $P822
  vivify_69:
    set $P822["config"], $P821
.annotate "line", 885
    find_lex $P823, "%vm"
    "store_dynlex_safely"("%*VM", $P823)
.annotate "line", 888
    find_lex $P825, "@argv"
    if $P825, unless_824_end
    find_lex $P826, "@argv"
    $P826."unshift"("<anonymous>")
  unless_824_end:
.annotate "line", 889
    find_lex $P827, "@argv"
    $P828 = $P827."shift"()
    "store_dynlex_safely"("$*PROGRAM_NAME", $P828)
.annotate "line", 890
    find_lex $P829, "@argv"
    "store_dynlex_safely"("@*ARGS", $P829)
.annotate "line", 893
    interpinfo $S830, 19
    "store_dynlex_safely"("$*EXECUTABLE_NAME", $S830)
.annotate "line", 896
    sysinfo $S831, 4
    "store_dynlex_safely"("$*OSNAME", $S831)
.annotate "line", 897
    sysinfo $S832, 5
    "store_dynlex_safely"("%*OSVER", $S832)
.annotate "line", 900
    new $P833, "ResizablePMCArray"
    push $P833, "parrot"
    push $P833, "Env"
    root_new $P834, $P833
    "store_dynlex_safely"("%*ENV", $P834)
.annotate "line", 901
    new $P835, "ResizablePMCArray"
    push $P835, "parrot"
    push $P835, "OS"
    root_new $P836, $P835
    $P837 = "store_dynlex_safely"("$*OS", $P836)
.annotate "line", 873
    .return ($P837)
.end


.namespace []
.sub "map"  :subid("11_1268956021.99384") :outer("10_1268956021.99384")
    .param pmc param_16
    .param pmc param_17
.annotate "line", 216
    .const 'Sub' $P25 = "12_1268956021.99384" 
    capture_lex $P25
    new $P15, 'ExceptionHandler'
    set_addr $P15, control_14
    $P15."handle_types"(58)
    push_eh $P15
    .lex "&code", param_16
    .lex "@originals", param_17
.annotate "line", 217
    $P18 = root_new ['parrot';'ResizablePMCArray']
    .lex "@mapped", $P18
.annotate "line", 216
    find_lex $P19, "@mapped"
.annotate "line", 219
    find_lex $P21, "@originals"
    defined $I22, $P21
    unless $I22, for_undef_70
    iter $P20, $P21
    new $P33, 'ExceptionHandler'
    set_addr $P33, loop32_handler
    $P33."handle_types"(65, 67, 66)
    push_eh $P33
  loop32_test:
    unless $P20, loop32_done
    shift $P23, $P20
  loop32_redo:
    .const 'Sub' $P25 = "12_1268956021.99384" 
    capture_lex $P25
    $P25($P23)
  loop32_next:
    goto loop32_test
  loop32_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P34, exception, 'type'
    eq $P34, 65, loop32_next
    eq $P34, 67, loop32_redo
  loop32_done:
    pop_eh 
  for_undef_70:
.annotate "line", 223
    new $P35, "Exception"
    set $P35['type'], 58
    find_lex $P36, "@mapped"
    setattribute $P35, 'payload', $P36
    throw $P35
.annotate "line", 216
    .return ()
  control_14:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P37, exception, "payload"
    .return ($P37)
.end


.namespace []
.sub "_block24"  :anon :subid("12_1268956021.99384") :outer("11_1268956021.99384")
    .param pmc param_26
.annotate "line", 219
    .lex "$_", param_26
.annotate "line", 220
    find_lex $P27, "@mapped"
    find_lex $P28, "&code"
    find_lex $P29, "$_"
    $P30 = $P28($P29)
    $P31 = $P27."push"($P30)
.annotate "line", 219
    .return ($P31)
.end


.namespace []
.sub "grep"  :subid("13_1268956021.99384") :outer("10_1268956021.99384")
    .param pmc param_41
    .param pmc param_42
.annotate "line", 236
    .const 'Sub' $P50 = "14_1268956021.99384" 
    capture_lex $P50
    new $P40, 'ExceptionHandler'
    set_addr $P40, control_39
    $P40."handle_types"(58)
    push_eh $P40
    .lex "&code", param_41
    .lex "@all", param_42
.annotate "line", 237
    $P43 = root_new ['parrot';'ResizablePMCArray']
    .lex "@matches", $P43
.annotate "line", 236
    find_lex $P44, "@matches"
.annotate "line", 239
    find_lex $P46, "@all"
    defined $I47, $P46
    unless $I47, for_undef_71
    iter $P45, $P46
    new $P61, 'ExceptionHandler'
    set_addr $P61, loop60_handler
    $P61."handle_types"(65, 67, 66)
    push_eh $P61
  loop60_test:
    unless $P45, loop60_done
    shift $P48, $P45
  loop60_redo:
    .const 'Sub' $P50 = "14_1268956021.99384" 
    capture_lex $P50
    $P50($P48)
  loop60_next:
    goto loop60_test
  loop60_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P62, exception, 'type'
    eq $P62, 65, loop60_next
    eq $P62, 67, loop60_redo
  loop60_done:
    pop_eh 
  for_undef_71:
.annotate "line", 243
    new $P63, "Exception"
    set $P63['type'], 58
    find_lex $P64, "@matches"
    setattribute $P63, 'payload', $P64
    throw $P63
.annotate "line", 236
    .return ()
  control_39:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P65, exception, "payload"
    .return ($P65)
.end


.namespace []
.sub "_block49"  :anon :subid("14_1268956021.99384") :outer("13_1268956021.99384")
    .param pmc param_51
.annotate "line", 239
    .lex "$_", param_51
.annotate "line", 240
    find_lex $P54, "&code"
    find_lex $P55, "$_"
    $P56 = $P54($P55)
    if $P56, if_53
    set $P52, $P56
    goto if_53_end
  if_53:
    find_lex $P57, "@matches"
    find_lex $P58, "$_"
    $P59 = $P57."push"($P58)
    set $P52, $P59
  if_53_end:
.annotate "line", 239
    .return ($P52)
.end


.namespace []
.sub "reduce"  :subid("15_1268956021.99384") :outer("10_1268956021.99384")
    .param pmc param_69
    .param pmc param_70
    .param pmc param_71 :slurpy
.annotate "line", 268
    .const 'Sub' $P93 = "16_1268956021.99384" 
    capture_lex $P93
    new $P68, 'ExceptionHandler'
    set_addr $P68, control_67
    $P68."handle_types"(58)
    push_eh $P68
    .lex "&code", param_69
    .lex "@array", param_70
    .lex "@initial", param_71
.annotate "line", 269
    new $P72, "Undef"
    .lex "$init_elems", $P72
    find_lex $P73, "@initial"
    elements $I74, $P73
    new $P75, 'Integer'
    set $P75, $I74
    store_lex "$init_elems", $P75
.annotate "line", 270
    find_lex $P78, "$init_elems"
    set $N79, $P78
    isgt $I80, $N79, 1.0
    if $I80, if_77
.annotate "line", 273
    find_lex $P83, "$init_elems"
    set $N84, $P83
    iseq $I85, $N84, 1.0
    if $I85, if_82
.annotate "line", 276
    .const 'Sub' $P93 = "16_1268956021.99384" 
    capture_lex $P93
    $P139 = $P93()
    set $P81, $P139
.annotate "line", 273
    goto if_82_end
  if_82:
.annotate "line", 274
    new $P86, "Exception"
    set $P86['type'], 58
    find_lex $P87, "&code"
    find_lex $P88, "@array"
    find_lex $P89, "@initial"
    unless_null $P89, vivify_78
    $P89 = root_new ['parrot';'ResizablePMCArray']
  vivify_78:
    set $P90, $P89[0]
    unless_null $P90, vivify_79
    new $P90, "Undef"
  vivify_79:
    $P91 = "_reduce"($P87, $P88, $P90)
    setattribute $P86, 'payload', $P91
    throw $P86
  if_82_end:
.annotate "line", 273
    set $P76, $P81
.annotate "line", 270
    goto if_77_end
  if_77:
.annotate "line", 271
    die "Only one initial value allowed in reduce()"
  if_77_end:
.annotate "line", 268
    .return ($P76)
  control_67:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P140, exception, "payload"
    .return ($P140)
.end


.namespace []
.sub "_block92"  :anon :subid("16_1268956021.99384") :outer("15_1268956021.99384")
.annotate "line", 276
    .const 'Sub' $P118 = "18_1268956021.99384" 
    capture_lex $P118
    .const 'Sub' $P104 = "17_1268956021.99384" 
    capture_lex $P104
.annotate "line", 277
    new $P94, "Undef"
    .lex "$array_elems", $P94
    find_lex $P95, "@array"
    elements $I96, $P95
    new $P97, 'Integer'
    set $P97, $I96
    store_lex "$array_elems", $P97
.annotate "line", 278
    find_lex $P100, "$array_elems"
    set $N101, $P100
    iseq $I102, $N101, 0.0
    if $I102, if_99
.annotate "line", 281
    find_lex $P111, "$array_elems"
    set $N112, $P111
    iseq $I113, $N112, 1.0
    if $I113, if_110
.annotate "line", 284
    .const 'Sub' $P118 = "18_1268956021.99384" 
    capture_lex $P118
    $P138 = $P118()
    set $P109, $P138
.annotate "line", 281
    goto if_110_end
  if_110:
.annotate "line", 282
    new $P114, "Exception"
    set $P114['type'], 58
    find_lex $P115, "@array"
    unless_null $P115, vivify_76
    $P115 = root_new ['parrot';'ResizablePMCArray']
  vivify_76:
    set $P116, $P115[0]
    unless_null $P116, vivify_77
    new $P116, "Undef"
  vivify_77:
    setattribute $P114, 'payload', $P116
    throw $P114
  if_110_end:
.annotate "line", 281
    set $P98, $P109
.annotate "line", 278
    goto if_99_end
  if_99:
    .const 'Sub' $P104 = "17_1268956021.99384" 
    capture_lex $P104
    $P108 = $P104()
    set $P98, $P108
  if_99_end:
.annotate "line", 276
    .return ($P98)
.end


.namespace []
.sub "_block117"  :anon :subid("18_1268956021.99384") :outer("16_1268956021.99384")
.annotate "line", 285
    new $P119, "Undef"
    .lex "$initial", $P119
.annotate "line", 286
    new $P120, "Undef"
    .lex "$iter", $P120
.annotate "line", 285
    find_lex $P121, "&code"
    find_lex $P122, "@array"
    unless_null $P122, vivify_72
    $P122 = root_new ['parrot';'ResizablePMCArray']
  vivify_72:
    set $P123, $P122[0]
    unless_null $P123, vivify_73
    new $P123, "Undef"
  vivify_73:
    find_lex $P124, "@array"
    unless_null $P124, vivify_74
    $P124 = root_new ['parrot';'ResizablePMCArray']
  vivify_74:
    set $P125, $P124[1]
    unless_null $P125, vivify_75
    new $P125, "Undef"
  vivify_75:
    $P126 = $P121($P123, $P125)
    store_lex "$initial", $P126
.annotate "line", 286
    find_lex $P127, "@array"
    iter $P128, $P127
    store_lex "$iter", $P128
.annotate "line", 288
    find_lex $P129, "$iter"
    shift $P130, $P129
.annotate "line", 289
    find_lex $P131, "$iter"
    shift $P132, $P131
.annotate "line", 291
    new $P133, "Exception"
    set $P133['type'], 58
    find_lex $P134, "&code"
    find_lex $P135, "$iter"
    find_lex $P136, "$initial"
    $P137 = "_reduce"($P134, $P135, $P136)
    setattribute $P133, 'payload', $P137
    throw $P133
.annotate "line", 284
    .return ()
.end


.namespace []
.sub "_block103"  :anon :subid("17_1268956021.99384") :outer("16_1268956021.99384")
.annotate "line", 279
    new $P105, "Undef"
    .lex "$undef", $P105
    new $P106, "Exception"
    set $P106['type'], 58
    find_lex $P107, "$undef"
    setattribute $P106, 'payload', $P107
    throw $P106
.annotate "line", 278
    .return ()
.end


.namespace []
.sub "_reduce"  :subid("19_1268956021.99384") :outer("10_1268956021.99384")
    .param pmc param_144
    .param pmc param_145
    .param pmc param_146
.annotate "line", 296
    .const 'Sub' $P154 = "20_1268956021.99384" 
    capture_lex $P154
    new $P143, 'ExceptionHandler'
    set_addr $P143, control_142
    $P143."handle_types"(58)
    push_eh $P143
    .lex "&code", param_144
    .lex "$iter", param_145
    .lex "$initial", param_146
.annotate "line", 297
    new $P147, "Undef"
    .lex "$result", $P147
    find_lex $P148, "$initial"
    store_lex "$result", $P148
.annotate "line", 299
    find_lex $P150, "$iter"
    defined $I151, $P150
    unless $I151, for_undef_80
    iter $P149, $P150
    new $P161, 'ExceptionHandler'
    set_addr $P161, loop160_handler
    $P161."handle_types"(65, 67, 66)
    push_eh $P161
  loop160_test:
    unless $P149, loop160_done
    shift $P152, $P149
  loop160_redo:
    .const 'Sub' $P154 = "20_1268956021.99384" 
    capture_lex $P154
    $P154($P152)
  loop160_next:
    goto loop160_test
  loop160_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P162, exception, 'type'
    eq $P162, 65, loop160_next
    eq $P162, 67, loop160_redo
  loop160_done:
    pop_eh 
  for_undef_80:
.annotate "line", 303
    new $P163, "Exception"
    set $P163['type'], 58
    find_lex $P164, "$result"
    setattribute $P163, 'payload', $P164
    throw $P163
.annotate "line", 296
    .return ()
  control_142:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P165, exception, "payload"
    .return ($P165)
.end


.namespace []
.sub "_block153"  :anon :subid("20_1268956021.99384") :outer("19_1268956021.99384")
    .param pmc param_155
.annotate "line", 299
    .lex "$_", param_155
.annotate "line", 300
    find_lex $P156, "&code"
    find_lex $P157, "$result"
    find_lex $P158, "$_"
    $P159 = $P156($P157, $P158)
    store_lex "$result", $P159
.annotate "line", 299
    .return ($P159)
.end


.namespace []
.sub "hash"  :subid("21_1268956021.99384") :outer("10_1268956021.99384")
    .param pmc param_169 :slurpy :named
.annotate "line", 324
    new $P168, 'ExceptionHandler'
    set_addr $P168, control_167
    $P168."handle_types"(58)
    push_eh $P168
    .lex "%h", param_169
    new $P170, "Exception"
    set $P170['type'], 58
    find_lex $P171, "%h"
    setattribute $P170, 'payload', $P171
    throw $P170
    .return ()
  control_167:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P172, exception, "payload"
    .return ($P172)
.end


.namespace []
.sub "set_from_array"  :subid("22_1268956021.99384") :outer("10_1268956021.99384")
    .param pmc param_176
.annotate "line", 337
    .const 'Sub' $P184 = "23_1268956021.99384" 
    capture_lex $P184
    new $P175, 'ExceptionHandler'
    set_addr $P175, control_174
    $P175."handle_types"(58)
    push_eh $P175
    .lex "@array", param_176
.annotate "line", 338
    $P177 = root_new ['parrot';'Hash']
    .lex "%set", $P177
.annotate "line", 337
    find_lex $P178, "%set"
.annotate "line", 340
    find_lex $P180, "@array"
    defined $I181, $P180
    unless $I181, for_undef_81
    iter $P179, $P180
    new $P190, 'ExceptionHandler'
    set_addr $P190, loop189_handler
    $P190."handle_types"(65, 67, 66)
    push_eh $P190
  loop189_test:
    unless $P179, loop189_done
    shift $P182, $P179
  loop189_redo:
    .const 'Sub' $P184 = "23_1268956021.99384" 
    capture_lex $P184
    $P184($P182)
  loop189_next:
    goto loop189_test
  loop189_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P191, exception, 'type'
    eq $P191, 65, loop189_next
    eq $P191, 67, loop189_redo
  loop189_done:
    pop_eh 
  for_undef_81:
.annotate "line", 344
    new $P192, "Exception"
    set $P192['type'], 58
    find_lex $P193, "%set"
    setattribute $P192, 'payload', $P193
    throw $P192
.annotate "line", 337
    .return ()
  control_174:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P194, exception, "payload"
    .return ($P194)
.end


.namespace []
.sub "_block183"  :anon :subid("23_1268956021.99384") :outer("22_1268956021.99384")
    .param pmc param_185
.annotate "line", 340
    .lex "$_", param_185
.annotate "line", 341
    new $P186, "Integer"
    assign $P186, 1
    find_lex $P187, "$_"
    find_lex $P188, "%set"
    unless_null $P188, vivify_82
    $P188 = root_new ['parrot';'Hash']
    store_lex "%set", $P188
  vivify_82:
    set $P188[$P187], $P186
.annotate "line", 340
    .return ($P186)
.end


.namespace []
.sub "all_matches"  :subid("24_1268956021.99384") :outer("10_1268956021.99384")
    .param pmc param_198
    .param pmc param_199
.annotate "line", 364
    new $P197, 'ExceptionHandler'
    set_addr $P197, control_196
    $P197."handle_types"(58)
    push_eh $P197
    .lex "$regex", param_198
    .lex "$text", param_199
.annotate "line", 365
    $P200 = root_new ['parrot';'ResizablePMCArray']
    .lex "@matches", $P200
.annotate "line", 367
    new $P201, "Undef"
    .lex "$match", $P201
.annotate "line", 364
    find_lex $P202, "@matches"
.annotate "line", 367
    find_lex $P203, "$regex"
    find_lex $P204, "$text"
    $P205 = $P203."ACCEPTS"($P204)
    store_lex "$match", $P205
.annotate "line", 368
    new $P217, 'ExceptionHandler'
    set_addr $P217, loop216_handler
    $P217."handle_types"(65, 67, 66)
    push_eh $P217
  loop216_test:
    find_lex $P206, "$match"
    unless $P206, loop216_done
  loop216_redo:
.annotate "line", 369
    find_lex $P207, "@matches"
    find_lex $P208, "$match"
    $P207."push"($P208)
.annotate "line", 370
    find_lex $P209, "$match"
    $P210 = $P209."CURSOR"()
    find_lex $P211, "$text"
    find_lex $P212, "$regex"
    find_lex $P213, "$match"
    $P214 = $P213."to"()
    $P215 = $P210."parse"($P211, $P212 :named("rule"), $P214 :named("c"))
    store_lex "$match", $P215
  loop216_next:
.annotate "line", 368
    goto loop216_test
  loop216_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P218, exception, 'type'
    eq $P218, 65, loop216_next
    eq $P218, 67, loop216_redo
  loop216_done:
    pop_eh 
.annotate "line", 373
    new $P219, "Exception"
    set $P219['type'], 58
    find_lex $P220, "@matches"
    setattribute $P219, 'payload', $P220
    throw $P219
.annotate "line", 364
    .return ()
  control_196:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P221, exception, "payload"
    .return ($P221)
.end


.namespace []
.sub "subst"  :subid("25_1268956021.99384") :outer("10_1268956021.99384")
    .param pmc param_225
    .param pmc param_226
    .param pmc param_227
.annotate "line", 391
    .const 'Sub' $P246 = "26_1268956021.99384" 
    capture_lex $P246
    new $P224, 'ExceptionHandler'
    set_addr $P224, control_223
    $P224."handle_types"(58)
    push_eh $P224
    .lex "$original", param_225
    .lex "$regex", param_226
    .lex "$replacement", param_227
.annotate "line", 392
    $P228 = root_new ['parrot';'ResizablePMCArray']
    .lex "@matches", $P228
.annotate "line", 393
    new $P229, "Undef"
    .lex "$edited", $P229
.annotate "line", 394
    new $P230, "Undef"
    .lex "$is_sub", $P230
.annotate "line", 395
    new $P231, "Undef"
    .lex "$offset", $P231
.annotate "line", 392
    find_lex $P232, "$regex"
    find_lex $P233, "$original"
    $P234 = "all_matches"($P232, $P233)
    store_lex "@matches", $P234
.annotate "line", 393
    find_lex $P235, "$original"
    clone $P236, $P235
    store_lex "$edited", $P236
.annotate "line", 394
    find_lex $P237, "$replacement"
    isa $I238, $P237, "Sub"
    new $P239, 'Integer'
    set $P239, $I238
    store_lex "$is_sub", $P239
.annotate "line", 395
    new $P240, "Integer"
    assign $P240, 0
    store_lex "$offset", $P240
.annotate "line", 397
    find_lex $P242, "@matches"
    defined $I243, $P242
    unless $I243, for_undef_83
    iter $P241, $P242
    new $P278, 'ExceptionHandler'
    set_addr $P278, loop277_handler
    $P278."handle_types"(65, 67, 66)
    push_eh $P278
  loop277_test:
    unless $P241, loop277_done
    shift $P244, $P241
  loop277_redo:
    .const 'Sub' $P246 = "26_1268956021.99384" 
    capture_lex $P246
    $P246($P244)
  loop277_next:
    goto loop277_test
  loop277_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P279, exception, 'type'
    eq $P279, 65, loop277_next
    eq $P279, 67, loop277_redo
  loop277_done:
    pop_eh 
  for_undef_83:
.annotate "line", 419
    new $P280, "Exception"
    set $P280['type'], 58
    find_lex $P281, "$edited"
    setattribute $P280, 'payload', $P281
    throw $P280
.annotate "line", 391
    .return ()
  control_223:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P282, exception, "payload"
    .return ($P282)
.end


.namespace []
.sub "_block245"  :anon :subid("26_1268956021.99384") :outer("25_1268956021.99384")
    .param pmc param_247
.annotate "line", 397
    .lex "$match", param_247
.annotate "line", 398
    new $P248, "Undef"
    .lex "$replace_string", $P248
.annotate "line", 399
    new $P249, "Undef"
    .lex "$replace_len", $P249
.annotate "line", 400
    new $P250, "Undef"
    .lex "$match_len", $P250
.annotate "line", 401
    new $P251, "Undef"
    .lex "$real_from", $P251
.annotate "line", 398
    find_lex $P254, "$is_sub"
    if $P254, if_253
    find_lex $P258, "$replacement"
    set $P252, $P258
    goto if_253_end
  if_253:
    find_lex $P255, "$replacement"
    find_lex $P256, "$match"
    $P257 = $P255($P256)
    set $P252, $P257
  if_253_end:
    store_lex "$replace_string", $P252
.annotate "line", 399
    find_lex $P259, "$replace_string"
    set $S260, $P259
    length $I261, $S260
    new $P262, 'Integer'
    set $P262, $I261
    store_lex "$replace_len", $P262
.annotate "line", 400
    find_lex $P263, "$match"
    $P264 = $P263."to"()
    find_lex $P265, "$match"
    $N266 = $P265."from"()
    sub $P267, $P264, $N266
    store_lex "$match_len", $P267
.annotate "line", 401
    find_lex $P268, "$match"
    $P269 = $P268."from"()
    find_lex $P270, "$offset"
    add $P271, $P269, $P270
    store_lex "$real_from", $P271
.annotate "line", 403

             $P0 = find_lex '$edited'
	     $S0 = $P0
	     $P1 = find_lex '$real_from'
	     $I0 = $P1
	     $P2 = find_lex '$match_len'
	     $I1 = $P2
	     $P3 = find_lex '$replace_string'
	     $S1 = $P3
	     substr $S0, $I0, $I1, $S1
	     $P0 = $S0
	
.annotate "line", 416
    find_lex $P272, "$offset"
    find_lex $P273, "$match_len"
    sub $P274, $P272, $P273
    find_lex $P275, "$replace_len"
    add $P276, $P274, $P275
    store_lex "$offset", $P276
.annotate "line", 397
    .return ($P276)
.end


.namespace []
.sub "print"  :subid("27_1268956021.99384") :outer("10_1268956021.99384")
    .param pmc param_286 :slurpy
.annotate "line", 440
    .const 'Sub' $P292 = "28_1268956021.99384" 
    capture_lex $P292
    new $P285, 'ExceptionHandler'
    set_addr $P285, control_284
    $P285."handle_types"(58)
    push_eh $P285
    .lex "@strings", param_286
.annotate "line", 441
    find_lex $P288, "@strings"
    defined $I289, $P288
    unless $I289, for_undef_84
    iter $P287, $P288
    new $P296, 'ExceptionHandler'
    set_addr $P296, loop295_handler
    $P296."handle_types"(65, 67, 66)
    push_eh $P296
  loop295_test:
    unless $P287, loop295_done
    shift $P290, $P287
  loop295_redo:
    .const 'Sub' $P292 = "28_1268956021.99384" 
    capture_lex $P292
    $P292($P290)
  loop295_next:
    goto loop295_test
  loop295_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P297, exception, 'type'
    eq $P297, 65, loop295_next
    eq $P297, 67, loop295_redo
  loop295_done:
    pop_eh 
  for_undef_84:
.annotate "line", 440
    .return ($P287)
  control_284:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P298, exception, "payload"
    .return ($P298)
.end


.namespace []
.sub "_block291"  :anon :subid("28_1268956021.99384") :outer("27_1268956021.99384")
    .param pmc param_293
.annotate "line", 441
    .lex "$_", param_293
.annotate "line", 442
    find_lex $P294, "$_"
    print $P294
.annotate "line", 441
    .return ()
.end


.namespace []
.sub "say"  :subid("29_1268956021.99384") :outer("10_1268956021.99384")
    .param pmc param_302 :slurpy
.annotate "line", 455
    new $P301, 'ExceptionHandler'
    set_addr $P301, control_300
    $P301."handle_types"(58)
    push_eh $P301
    .lex "@strings", param_302
.annotate "line", 456
    find_lex $P303, "@strings"
    $P304 = "print"($P303 :flat, "\n")
.annotate "line", 455
    .return ($P304)
  control_300:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P305, exception, "payload"
    .return ($P305)
.end


.namespace []
.sub "slurp"  :subid("30_1268956021.99384") :outer("10_1268956021.99384")
    .param pmc param_309
.annotate "line", 468
    new $P308, 'ExceptionHandler'
    set_addr $P308, control_307
    $P308."handle_types"(58)
    push_eh $P308
    .lex "$filename", param_309
.annotate "line", 469
    new $P310, "Undef"
    .lex "$fh", $P310
.annotate "line", 470
    new $P311, "Undef"
    .lex "$contents", $P311
.annotate "line", 469
    find_lex $P312, "$filename"
    set $S313, $P312
    open $P314, $S313, "r"
    store_lex "$fh", $P314
.annotate "line", 470
    find_lex $P315, "$fh"
    $P316 = $P315."readall"()
    store_lex "$contents", $P316
.annotate "line", 471
    find_lex $P317, "$fh"
    close $P317
.annotate "line", 473
    new $P318, "Exception"
    set $P318['type'], 58
    find_lex $P319, "$contents"
    setattribute $P318, 'payload', $P319
    throw $P318
.annotate "line", 468
    .return ()
  control_307:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P320, exception, "payload"
    .return ($P320)
.end


.namespace []
.sub "spew"  :subid("31_1268956021.99384") :outer("10_1268956021.99384")
    .param pmc param_324
    .param pmc param_325
.annotate "line", 485
    new $P323, 'ExceptionHandler'
    set_addr $P323, control_322
    $P323."handle_types"(58)
    push_eh $P323
    .lex "$filename", param_324
    .lex "$contents", param_325
.annotate "line", 486
    new $P326, "Undef"
    .lex "$fh", $P326
    find_lex $P327, "$filename"
    set $S328, $P327
    open $P329, $S328, "w"
    store_lex "$fh", $P329
.annotate "line", 487
    find_lex $P330, "$fh"
    find_lex $P331, "$contents"
    $P330."print"($P331)
.annotate "line", 488
    find_lex $P332, "$fh"
    close $P332
.annotate "line", 485
    .return ()
  control_322:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P333, exception, "payload"
    .return ($P333)
.end


.namespace []
.sub "append"  :subid("32_1268956021.99384") :outer("10_1268956021.99384")
    .param pmc param_337
    .param pmc param_338
.annotate "line", 500
    new $P336, 'ExceptionHandler'
    set_addr $P336, control_335
    $P336."handle_types"(58)
    push_eh $P336
    .lex "$filename", param_337
    .lex "$contents", param_338
.annotate "line", 501
    new $P339, "Undef"
    .lex "$fh", $P339
    find_lex $P340, "$filename"
    set $S341, $P340
    open $P342, $S341, "a"
    store_lex "$fh", $P342
.annotate "line", 502
    find_lex $P343, "$fh"
    find_lex $P344, "$contents"
    $P343."print"($P344)
.annotate "line", 503
    find_lex $P345, "$fh"
    close $P345
.annotate "line", 500
    .return ()
  control_335:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P346, exception, "payload"
    .return ($P346)
.end


.namespace []
.sub "fscat"  :subid("33_1268956021.99384") :outer("10_1268956021.99384")
    .param pmc param_350
    .param pmc param_351 :slurpy
.annotate "line", 528
    new $P349, 'ExceptionHandler'
    set_addr $P349, control_348
    $P349."handle_types"(58)
    push_eh $P349
    .lex "@path_parts", param_350
    .lex "@filename", param_351
.annotate "line", 532
    new $P352, "Undef"
    .lex "$sep", $P352
.annotate "line", 533
    new $P353, "Undef"
    .lex "$joined", $P353
.annotate "line", 530
    find_lex $P355, "@filename"
    set $N356, $P355
    isgt $I357, $N356, 1.0
    unless $I357, if_354_end
.annotate "line", 529
    die "Only one filename allowed in fscat()"
  if_354_end:
.annotate "line", 532
    getinterp $P358
    set $P359, $P358[6]
    unless_null $P359, vivify_85
    $P359 = root_new ['parrot';'Hash']
  vivify_85:
    set $P360, $P359["slash"]
    unless_null $P360, vivify_86
    new $P360, "Undef"
  vivify_86:
    store_lex "$sep", $P360
.annotate "line", 533
    find_lex $P361, "$sep"
    set $S362, $P361
    find_lex $P363, "@path_parts"
    join $S364, $S362, $P363
    new $P365, 'String'
    set $P365, $S364
    store_lex "$joined", $P365
.annotate "line", 534
    find_lex $P367, "@filename"
    unless $P367, if_366_end
    find_lex $P368, "$joined"
    find_lex $P369, "$sep"
    concat $P370, $P368, $P369
    find_lex $P371, "@filename"
    unless_null $P371, vivify_87
    $P371 = root_new ['parrot';'ResizablePMCArray']
  vivify_87:
    set $P372, $P371[0]
    unless_null $P372, vivify_88
    new $P372, "Undef"
  vivify_88:
    concat $P373, $P370, $P372
    store_lex "$joined", $P373
  if_366_end:
.annotate "line", 536
    new $P374, "Exception"
    set $P374['type'], 58
    find_lex $P375, "$joined"
    setattribute $P374, 'payload', $P375
    throw $P374
.annotate "line", 528
    .return ()
  control_348:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P376, exception, "payload"
    .return ($P376)
.end


.namespace []
.sub "user_home_dir"  :subid("34_1268956021.99384") :outer("10_1268956021.99384")
.annotate "line", 548
    new $P379, 'ExceptionHandler'
    set_addr $P379, control_378
    $P379."handle_types"(58)
    push_eh $P379
.annotate "line", 549
    $P380 = root_new ['parrot';'Hash']
    .lex "%env", $P380
    new $P381, "ResizablePMCArray"
    push $P381, "parrot"
    push $P381, "Env"
    root_new $P382, $P381
    store_lex "%env", $P382
.annotate "line", 550
    new $P383, "Exception"
    set $P383['type'], 58
    find_lex $P385, "%env"
    unless_null $P385, vivify_89
    $P385 = root_new ['parrot';'Hash']
  vivify_89:
    set $P386, $P385["HOMEDRIVE"]
    unless_null $P386, vivify_90
    new $P386, "Undef"
  vivify_90:
    set $P384, $P386
    defined $I388, $P384
    if $I388, default_387
    new $P389, "String"
    assign $P389, ""
    set $P384, $P389
  default_387:
    find_lex $P390, "%env"
    unless_null $P390, vivify_91
    $P390 = root_new ['parrot';'Hash']
  vivify_91:
    set $P391, $P390["HOME"]
    unless_null $P391, vivify_92
    new $P391, "Undef"
  vivify_92:
    concat $P392, $P384, $P391
    setattribute $P383, 'payload', $P392
    throw $P383
.annotate "line", 548
    .return ()
  control_378:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P393, exception, "payload"
    .return ($P393)
.end


.namespace []
.sub "path_exists"  :subid("35_1268956021.99384") :outer("10_1268956021.99384")
    .param pmc param_397
.annotate "line", 563
    .const 'Sub' $P411 = "36_1268956021.99384" 
    capture_lex $P411
    new $P396, 'ExceptionHandler'
    set_addr $P396, control_395
    $P396."handle_types"(58)
    push_eh $P396
    new $P407, 'ExceptionHandler'
    set_addr $P407, control_406
    $P407."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P407
    .lex "$path", param_397
.annotate "line", 564
    $P398 = root_new ['parrot';'ResizablePMCArray']
    .lex "@stat", $P398
    new $P399, "ResizablePMCArray"
    push $P399, "parrot"
    push $P399, "OS"
    root_new $P400, $P399
    find_lex $P401, "$path"
    $P402 = $P400."stat"($P401)
    store_lex "@stat", $P402
.annotate "line", 565
    new $P403, "Exception"
    set $P403['type'], 58
    new $P404, "Integer"
    assign $P404, 1
    setattribute $P403, 'payload', $P404
    throw $P403
.annotate "line", 563
    pop_eh 
    goto skip_handler_405
  control_406:
.annotate "line", 567
    .local pmc exception 
    .get_results (exception) 
    .const 'Sub' $P411 = "36_1268956021.99384" 
    capture_lex $P411
    $P411(exception)
    new $P416, 'Integer'
    set $P416, 1
    set exception["handled"], $P416
    set $I417, exception["handled"]
    ne $I417, 1, nothandled_409
  handled_408:
    .return (exception)
  nothandled_409:
    rethrow exception
  skip_handler_405:
.annotate "line", 563
    .return ()
  control_395:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P418, exception, "payload"
    .return ($P418)
.end


.namespace []
.sub "_block410"  :anon :subid("36_1268956021.99384") :outer("35_1268956021.99384")
    .param pmc param_412
.annotate "line", 567
    .lex "$_", param_412
    find_lex $P413, "$_"
    .lex "$!", $P413
.annotate "line", 568
    new $P414, "Exception"
    set $P414['type'], 58
    new $P415, "Integer"
    assign $P415, 0
    setattribute $P414, 'payload', $P415
    throw $P414
.annotate "line", 567
    .return ()
.end


.namespace []
.sub "is_dir"  :subid("37_1268956021.99384") :outer("10_1268956021.99384")
    .param pmc param_422
.annotate "line", 582
    .const 'Sub' $P439 = "38_1268956021.99384" 
    capture_lex $P439
    new $P421, 'ExceptionHandler'
    set_addr $P421, control_420
    $P421."handle_types"(58)
    push_eh $P421
    new $P435, 'ExceptionHandler'
    set_addr $P435, control_434
    $P435."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P435
    .lex "$path", param_422
.annotate "line", 583
    $P423 = root_new ['parrot';'ResizablePMCArray']
    .lex "@stat", $P423
    new $P424, "ResizablePMCArray"
    push $P424, "parrot"
    push $P424, "OS"
    root_new $P425, $P424
    find_lex $P426, "$path"
    $P427 = $P425."stat"($P426)
    store_lex "@stat", $P427
.annotate "line", 584
    new $P428, "Exception"
    set $P428['type'], 58
    find_lex $P429, "$path"
    set $S430, $P429
    stat $I431, $S430, 2
    new $P432, 'Integer'
    set $P432, $I431
    setattribute $P428, 'payload', $P432
    throw $P428
.annotate "line", 582
    pop_eh 
    goto skip_handler_433
  control_434:
.annotate "line", 586
    .local pmc exception 
    .get_results (exception) 
    .const 'Sub' $P439 = "38_1268956021.99384" 
    capture_lex $P439
    $P439(exception)
    new $P444, 'Integer'
    set $P444, 1
    set exception["handled"], $P444
    set $I445, exception["handled"]
    ne $I445, 1, nothandled_437
  handled_436:
    .return (exception)
  nothandled_437:
    rethrow exception
  skip_handler_433:
.annotate "line", 582
    .return ()
  control_420:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P446, exception, "payload"
    .return ($P446)
.end


.namespace []
.sub "_block438"  :anon :subid("38_1268956021.99384") :outer("37_1268956021.99384")
    .param pmc param_440
.annotate "line", 586
    .lex "$_", param_440
    find_lex $P441, "$_"
    .lex "$!", $P441
.annotate "line", 587
    new $P442, "Exception"
    set $P442['type'], 58
    new $P443, "Integer"
    assign $P443, 0
    setattribute $P442, 'payload', $P443
    throw $P442
.annotate "line", 586
    .return ()
.end


.namespace []
.sub "test_dir_writable"  :subid("39_1268956021.99384") :outer("10_1268956021.99384")
    .param pmc param_450
.annotate "line", 609
    .const 'Sub' $P463 = "40_1268956021.99384" 
    capture_lex $P463
    new $P449, 'ExceptionHandler'
    set_addr $P449, control_448
    $P449."handle_types"(58)
    push_eh $P449
    .lex "$dir", param_450
.annotate "line", 610
    new $P451, "Undef"
    .lex "$test_file", $P451
    find_lex $P452, "$dir"
    new $P453, "ResizablePMCArray"
    push $P453, $P452
    $P454 = "fscat"($P453, "WrItAbLe.UtL")
    store_lex "$test_file", $P454
.annotate "line", 613
    find_lex $P456, "$test_file"
    $P457 = "path_exists"($P456)
    unless $P457, if_455_end
.annotate "line", 612
    new $P458, 'String'
    set $P458, "Test file '"
    find_lex $P459, "$test_file"
    concat $P460, $P458, $P459
    concat $P461, $P460, "'\nthat should never exist already does."
    die $P461
  if_455_end:
.annotate "line", 615
    .const 'Sub' $P463 = "40_1268956021.99384" 
    capture_lex $P463
    $P463()
.annotate "line", 619
    find_lex $P475, "$test_file"
    $P476 = "path_exists"($P475)
    if $P476, if_474
.annotate "line", 624
    new $P482, "Exception"
    set $P482['type'], 58
    new $P483, "Integer"
    assign $P483, 0
    setattribute $P482, 'payload', $P483
    throw $P482
.annotate "line", 623
    goto if_474_end
  if_474:
.annotate "line", 620
    new $P477, "ResizablePMCArray"
    push $P477, "parrot"
    push $P477, "OS"
    root_new $P478, $P477
    find_lex $P479, "$test_file"
    $P478."rm"($P479)
.annotate "line", 621
    new $P480, "Exception"
    set $P480['type'], 58
    new $P481, "Integer"
    assign $P481, 1
    setattribute $P480, 'payload', $P481
    throw $P480
  if_474_end:
.annotate "line", 609
    .return ($P473)
  control_448:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P484, exception, "payload"
    .return ($P484)
.end


.namespace []
.sub "_block462"  :anon :subid("40_1268956021.99384") :outer("39_1268956021.99384")
.annotate "line", 615
    new $P468, 'ExceptionHandler'
    set_addr $P468, control_467
    $P468."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P468
.annotate "line", 616
    find_lex $P464, "$test_file"
    $P465 = "spew"($P464, "test_dir_writable() test file.\n")
.annotate "line", 615
    pop_eh 
    goto skip_handler_466
  control_467:
    .local pmc exception 
    .get_results (exception) 
    new $P471, 'Integer'
    set $P471, 1
    set exception["handled"], $P471
    set $I472, exception["handled"]
    ne $I472, 1, nothandled_470
  handled_469:
    .return (exception)
  nothandled_470:
    rethrow exception
  skip_handler_466:
    .return ($P465)
.end


.namespace []
.sub "find_program"  :subid("41_1268956021.99384") :outer("10_1268956021.99384")
    .param pmc param_488
.annotate "line", 648
    .const 'Sub' $P519 = "42_1268956021.99384" 
    capture_lex $P519
    new $P487, 'ExceptionHandler'
    set_addr $P487, control_486
    $P487."handle_types"(58)
    push_eh $P487
    .lex "$program", param_488
.annotate "line", 649
    new $P489, "Undef"
    .lex "$path_sep", $P489
.annotate "line", 650
    $P490 = root_new ['parrot';'Hash']
    .lex "%env", $P490
.annotate "line", 651
    $P491 = root_new ['parrot';'ResizablePMCArray']
    .lex "@paths", $P491
.annotate "line", 652
    $P492 = root_new ['parrot';'ResizablePMCArray']
    .lex "@exts", $P492
.annotate "line", 649
    sysinfo $S495, 4
    iseq $I496, $S495, "MSWin32"
    if $I496, if_494
    new $P498, "String"
    assign $P498, ":"
    set $P493, $P498
    goto if_494_end
  if_494:
    new $P497, "String"
    assign $P497, ";"
    set $P493, $P497
  if_494_end:
    store_lex "$path_sep", $P493
.annotate "line", 650
    new $P499, "ResizablePMCArray"
    push $P499, "parrot"
    push $P499, "Env"
    root_new $P500, $P499
    store_lex "%env", $P500
.annotate "line", 651
    find_lex $P501, "$path_sep"
    set $S502, $P501
    find_lex $P503, "%env"
    unless_null $P503, vivify_93
    $P503 = root_new ['parrot';'Hash']
  vivify_93:
    set $P504, $P503["PATH"]
    unless_null $P504, vivify_94
    new $P504, "Undef"
  vivify_94:
    set $S505, $P504
    split $P506, $S502, $S505
    store_lex "@paths", $P506
.annotate "line", 652
    find_lex $P507, "$path_sep"
    set $S508, $P507
    find_lex $P509, "%env"
    unless_null $P509, vivify_95
    $P509 = root_new ['parrot';'Hash']
  vivify_95:
    set $P510, $P509["PATHEXT"]
    unless_null $P510, vivify_96
    new $P510, "Undef"
  vivify_96:
    set $S511, $P510
    split $P512, $S508, $S511
    store_lex "@exts", $P512
.annotate "line", 654
    find_lex $P513, "@exts"
    $P513."unshift"("")
.annotate "line", 656
    find_lex $P515, "@paths"
    defined $I516, $P515
    unless $I516, for_undef_97
    iter $P514, $P515
    new $P547, 'ExceptionHandler'
    set_addr $P547, loop546_handler
    $P547."handle_types"(65, 67, 66)
    push_eh $P547
  loop546_test:
    unless $P514, loop546_done
    shift $P517, $P514
  loop546_redo:
    .const 'Sub' $P519 = "42_1268956021.99384" 
    capture_lex $P519
    $P519($P517)
  loop546_next:
    goto loop546_test
  loop546_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P548, exception, 'type'
    eq $P548, 65, loop546_next
    eq $P548, 67, loop546_redo
  loop546_done:
    pop_eh 
  for_undef_97:
.annotate "line", 665
    new $P549, "Exception"
    set $P549['type'], 58
    new $P550, "String"
    assign $P550, ""
    setattribute $P549, 'payload', $P550
    throw $P549
.annotate "line", 648
    .return ()
  control_486:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P551, exception, "payload"
    .return ($P551)
.end


.namespace []
.sub "_block518"  :anon :subid("42_1268956021.99384") :outer("41_1268956021.99384")
    .param pmc param_520
.annotate "line", 656
    .const 'Sub' $P531 = "43_1268956021.99384" 
    capture_lex $P531
    .lex "$dir", param_520
.annotate "line", 657
    new $P521, "Undef"
    .lex "$path", $P521
    find_lex $P522, "$dir"
    new $P523, "ResizablePMCArray"
    push $P523, $P522
    find_lex $P524, "$program"
    $P525 = "fscat"($P523, $P524)
    store_lex "$path", $P525
.annotate "line", 659
    find_lex $P527, "@exts"
    defined $I528, $P527
    unless $I528, for_undef_98
    iter $P526, $P527
    new $P544, 'ExceptionHandler'
    set_addr $P544, loop543_handler
    $P544."handle_types"(65, 67, 66)
    push_eh $P544
  loop543_test:
    unless $P526, loop543_done
    shift $P529, $P526
  loop543_redo:
    .const 'Sub' $P531 = "43_1268956021.99384" 
    capture_lex $P531
    $P531($P529)
  loop543_next:
    goto loop543_test
  loop543_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P545, exception, 'type'
    eq $P545, 65, loop543_next
    eq $P545, 67, loop543_redo
  loop543_done:
    pop_eh 
  for_undef_98:
.annotate "line", 656
    .return ($P526)
.end


.namespace []
.sub "_block530"  :anon :subid("43_1268956021.99384") :outer("42_1268956021.99384")
    .param pmc param_532
.annotate "line", 659
    .lex "$ext", param_532
.annotate "line", 660
    new $P533, "Undef"
    .lex "$pathext", $P533
    find_lex $P534, "$path"
    find_lex $P535, "$ext"
    concat $P536, $P534, $P535
    store_lex "$pathext", $P536
.annotate "line", 661
    find_lex $P539, "$pathext"
    $P540 = "path_exists"($P539)
    if $P540, if_538
    set $P537, $P540
    goto if_538_end
  if_538:
    new $P541, "Exception"
    set $P541['type'], 58
    find_lex $P542, "$pathext"
    setattribute $P541, 'payload', $P542
    throw $P541
  if_538_end:
.annotate "line", 659
    .return ($P537)
.end


.namespace []
.sub "mkpath"  :subid("44_1268956021.99384") :outer("10_1268956021.99384")
    .param pmc param_555
.annotate "line", 678
    .const 'Sub' $P568 = "45_1268956021.99384" 
    capture_lex $P568
    new $P554, 'ExceptionHandler'
    set_addr $P554, control_553
    $P554."handle_types"(58)
    push_eh $P554
    .lex "$path", param_555
.annotate "line", 679
    $P556 = root_new ['parrot';'ResizablePMCArray']
    .lex "@path", $P556
.annotate "line", 680
    new $P557, "Undef"
    .lex "$cur", $P557
.annotate "line", 679
    find_lex $P558, "$path"
    set $S559, $P558
    split $P560, "/", $S559
    store_lex "@path", $P560
.annotate "line", 680
    find_lex $P561, "@path"
    $P562 = $P561."shift"()
    store_lex "$cur", $P562
.annotate "line", 682
    find_lex $P564, "@path"
    defined $I565, $P564
    unless $I565, for_undef_99
    iter $P563, $P564
    new $P583, 'ExceptionHandler'
    set_addr $P583, loop582_handler
    $P583."handle_types"(65, 67, 66)
    push_eh $P583
  loop582_test:
    unless $P563, loop582_done
    shift $P566, $P563
  loop582_redo:
    .const 'Sub' $P568 = "45_1268956021.99384" 
    capture_lex $P568
    $P568($P566)
  loop582_next:
    goto loop582_test
  loop582_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P584, exception, 'type'
    eq $P584, 65, loop582_next
    eq $P584, 67, loop582_redo
  loop582_done:
    pop_eh 
  for_undef_99:
.annotate "line", 678
    .return ($P563)
  control_553:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P585, exception, "payload"
    .return ($P585)
.end


.namespace []
.sub "_block567"  :anon :subid("45_1268956021.99384") :outer("44_1268956021.99384")
    .param pmc param_569
.annotate "line", 682
    .lex "$dir", param_569
.annotate "line", 683
    find_lex $P570, "$cur"
    find_lex $P571, "$dir"
    new $P572, "ResizablePMCArray"
    push $P572, $P570
    push $P572, $P571
    $P573 = "fscat"($P572)
    store_lex "$cur", $P573
.annotate "line", 685
    find_lex $P576, "$cur"
    $P577 = "path_exists"($P576)
    unless $P577, unless_575
    set $P574, $P577
    goto unless_575_end
  unless_575:
.annotate "line", 686
    new $P578, "ResizablePMCArray"
    push $P578, "parrot"
    push $P578, "OS"
    root_new $P579, $P578
    find_lex $P580, "$cur"
    $P581 = $P579."mkdir"($P580, 511)
.annotate "line", 685
    set $P574, $P581
  unless_575_end:
.annotate "line", 682
    .return ($P574)
.end


.namespace []
.sub "run"  :subid("46_1268956021.99384") :outer("10_1268956021.99384")
    .param pmc param_589 :slurpy
.annotate "line", 713
    new $P588, 'ExceptionHandler'
    set_addr $P588, control_587
    $P588."handle_types"(58)
    push_eh $P588
    .lex "@command_and_args", param_589
.annotate "line", 714
    new $P590, "Exception"
    set $P590['type'], 58
    find_lex $P591, "@command_and_args"
    spawnw $I592, $P591
    new $P593, 'Integer'
    set $P593, $I592
    shr $P594, $P593, 8
    setattribute $P590, 'payload', $P594
    throw $P590
.annotate "line", 713
    .return ()
  control_587:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P595, exception, "payload"
    .return ($P595)
.end


.namespace []
.sub "do_run"  :subid("47_1268956021.99384") :outer("10_1268956021.99384")
    .param pmc param_599 :slurpy
.annotate "line", 731
    .const 'Sub' $P615 = "48_1268956021.99384" 
    capture_lex $P615
    new $P598, 'ExceptionHandler'
    set_addr $P598, control_597
    $P598."handle_types"(58)
    push_eh $P598
    new $P611, 'ExceptionHandler'
    set_addr $P611, control_610
    $P611."handle_types_except"(58, 59, 60, 61, 63, 64, 65, 66, 67)
    push_eh $P611
    .lex "@command_and_args", param_599
.annotate "line", 732
    find_lex $P600, "@command_and_args"
    join $S601, " ", $P600
    "say"($S601)
.annotate "line", 734
    new $P602, "Exception"
    set $P602['type'], 58
    find_lex $P605, "@command_and_args"
    spawnw $I606, $P605
    if $I606, if_604
    new $P608, "Integer"
    assign $P608, 1
    set $P603, $P608
    goto if_604_end
  if_604:
    new $P607, "Integer"
    assign $P607, 0
    set $P603, $P607
  if_604_end:
    setattribute $P602, 'payload', $P603
    throw $P602
.annotate "line", 731
    pop_eh 
    goto skip_handler_609
  control_610:
.annotate "line", 736
    .local pmc exception 
    .get_results (exception) 
    .const 'Sub' $P615 = "48_1268956021.99384" 
    capture_lex $P615
    $P615(exception)
    new $P620, 'Integer'
    set $P620, 1
    set exception["handled"], $P620
    set $I621, exception["handled"]
    ne $I621, 1, nothandled_613
  handled_612:
    .return (exception)
  nothandled_613:
    rethrow exception
  skip_handler_609:
.annotate "line", 731
    .return ()
  control_597:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P622, exception, "payload"
    .return ($P622)
.end


.namespace []
.sub "_block614"  :anon :subid("48_1268956021.99384") :outer("47_1268956021.99384")
    .param pmc param_616
.annotate "line", 736
    .lex "$_", param_616
    find_lex $P617, "$_"
    .lex "$!", $P617
.annotate "line", 737
    new $P618, "Exception"
    set $P618['type'], 58
    new $P619, "Integer"
    assign $P619, 0
    setattribute $P618, 'payload', $P619
    throw $P618
.annotate "line", 736
    .return ()
.end


.namespace []
.sub "qx"  :subid("49_1268956021.99384") :outer("10_1268956021.99384")
    .param pmc param_626 :slurpy
.annotate "line", 755
    new $P625, 'ExceptionHandler'
    set_addr $P625, control_624
    $P625."handle_types"(58)
    push_eh $P625
    .lex "@command_and_args", param_626
.annotate "line", 756
    new $P627, "Undef"
    .lex "$cmd", $P627
.annotate "line", 757
    new $P628, "Undef"
    .lex "$pipe", $P628
.annotate "line", 761
    new $P629, "Undef"
    .lex "$output", $P629
.annotate "line", 756
    find_lex $P630, "@command_and_args"
    join $S631, " ", $P630
    new $P632, 'String'
    set $P632, $S631
    store_lex "$cmd", $P632
.annotate "line", 757
    find_lex $P633, "$cmd"
    set $S634, $P633
    open $P635, $S634, "rp"
    store_lex "$pipe", $P635
.annotate "line", 758
    find_lex $P637, "$pipe"
    if $P637, unless_636_end
    new $P638, 'String'
    set $P638, "Unable to execute '"
    find_lex $P639, "$cmd"
    concat $P640, $P638, $P639
    concat $P641, $P640, "'"
    die $P641
  unless_636_end:
.annotate "line", 760
    find_lex $P642, "$pipe"
    $P642."encoding"("utf8")
.annotate "line", 761
    find_lex $P643, "$pipe"
    $P644 = $P643."readall"()
    store_lex "$output", $P644
.annotate "line", 762
    find_lex $P645, "$pipe"
    $P645."close"()
.annotate "line", 764
    find_lex $P646, "$pipe"
    $P647 = $P646."exit_status"()
    "store_dynlex_safely"("$!", $P647)
.annotate "line", 766
    new $P648, "Exception"
    set $P648['type'], 58
    find_lex $P649, "$output"
    setattribute $P648, 'payload', $P649
    throw $P648
.annotate "line", 755
    .return ()
  control_624:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P650, exception, "payload"
    .return ($P650)
.end


.namespace []
.sub "eval"  :subid("50_1268956021.99384") :outer("10_1268956021.99384")
    .param pmc param_654
    .param pmc param_655
.annotate "line", 789
    new $P653, 'ExceptionHandler'
    set_addr $P653, control_652
    $P653."handle_types"(58)
    push_eh $P653
    .lex "$source_code", param_654
    .lex "$language", param_655
.annotate "line", 793
    new $P656, "Undef"
    .lex "$compiler", $P656
.annotate "line", 790
    find_lex $P657, "$language"
    set $S658, $P657
    downcase $S659, $S658
    new $P660, 'String'
    set $P660, $S659
    store_lex "$language", $P660
.annotate "line", 792
    find_lex $P661, "$language"
    set $S662, $P661
    load_language $S662
.annotate "line", 793
    find_lex $P663, "$language"
    set $S664, $P663
    compreg $P665, $S664
    store_lex "$compiler", $P665
.annotate "line", 795
    new $P666, "Exception"
    set $P666['type'], 58
    find_lex $P667, "$compiler"
    find_lex $P668, "$source_code"
    $P669 = $P667."compile"($P668)
    $P670 = $P669()
    setattribute $P666, 'payload', $P670
    throw $P666
.annotate "line", 789
    .return ()
  control_652:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P671, exception, "payload"
    .return ($P671)
.end


.namespace []
.sub "store_dynlex_safely"  :subid("51_1268956021.99384") :outer("10_1268956021.99384")
    .param pmc param_675
    .param pmc param_676
.annotate "line", 819
    new $P674, 'ExceptionHandler'
    set_addr $P674, control_673
    $P674."handle_types"(58)
    push_eh $P674
    .lex "$var_name", param_675
    .lex "$value", param_676
.annotate "line", 821
    find_lex $P679, "$var_name"
    set $S680, $P679
    find_dynamic_lex $P681, $S680
    isnull $I682, $P681
    unless $I682, unless_678
    new $P677, 'Integer'
    set $P677, $I682
    goto unless_678_end
  unless_678:
.annotate "line", 820
    find_lex $P683, "$var_name"
    set $S684, $P683
    find_lex $P685, "$value"
    store_dynamic_lex $S684, $P685
  unless_678_end:
.annotate "line", 819
    .return ($P677)
  control_673:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P686, exception, "payload"
    .return ($P686)
.end


.namespace ["Hash"]
.sub "_block687"  :subid("52_1268956021.99384") :outer("10_1268956021.99384")
.annotate "line", 81
    .const 'Sub' $P738 = "58_1268956021.99384" 
    capture_lex $P738
    .const 'Sub' $P717 = "56_1268956021.99384" 
    capture_lex $P717
    .const 'Sub' $P696 = "54_1268956021.99384" 
    capture_lex $P696
    .const 'Sub' $P689 = "53_1268956021.99384" 
    capture_lex $P689
.annotate "line", 144
    .const 'Sub' $P738 = "58_1268956021.99384" 
    capture_lex $P738
.annotate "line", 81
    .return ($P738)
.end


.namespace ["Hash"]
.sub "exists"  :subid("53_1268956021.99384") :method :outer("52_1268956021.99384")
    .param pmc param_692
.annotate "line", 94
    new $P691, 'ExceptionHandler'
    set_addr $P691, control_690
    $P691."handle_types"(58)
    push_eh $P691
    .lex "self", self
    .lex "$key", param_692
.annotate "line", 95
    new $P693, "Exception"
    set $P693['type'], 58

            $P1 = find_lex '$key'
            $I0 = exists self[$P1]
            $P694  = box $I0
        
    setattribute $P693, 'payload', $P694
    throw $P693
.annotate "line", 94
    .return ()
  control_690:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P695, exception, "payload"
    .return ($P695)
.end


.namespace ["Hash"]
.sub "keys"  :subid("54_1268956021.99384") :method :outer("52_1268956021.99384")
.annotate "line", 111
    .const 'Sub' $P706 = "55_1268956021.99384" 
    capture_lex $P706
    new $P698, 'ExceptionHandler'
    set_addr $P698, control_697
    $P698."handle_types"(58)
    push_eh $P698
    .lex "self", self
.annotate "line", 112
    $P699 = root_new ['parrot';'ResizablePMCArray']
    .lex "@keys", $P699
.annotate "line", 111
    find_lex $P700, "@keys"
.annotate "line", 113
    find_lex $P702, "self"
    defined $I703, $P702
    unless $I703, for_undef_100
    iter $P701, $P702
    new $P713, 'ExceptionHandler'
    set_addr $P713, loop712_handler
    $P713."handle_types"(65, 67, 66)
    push_eh $P713
  loop712_test:
    unless $P701, loop712_done
    shift $P704, $P701
  loop712_redo:
    .const 'Sub' $P706 = "55_1268956021.99384" 
    capture_lex $P706
    $P706($P704)
  loop712_next:
    goto loop712_test
  loop712_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P714, exception, 'type'
    eq $P714, 65, loop712_next
    eq $P714, 67, loop712_redo
  loop712_done:
    pop_eh 
  for_undef_100:
    find_lex $P715, "@keys"
.annotate "line", 111
    .return ($P715)
  control_697:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P716, exception, "payload"
    .return ($P716)
.end


.namespace ["Hash"]
.sub "_block705"  :anon :subid("55_1268956021.99384") :outer("54_1268956021.99384")
    .param pmc param_707
.annotate "line", 113
    .lex "$_", param_707
    find_lex $P708, "@keys"
    find_lex $P709, "$_"
    $P710 = $P709."key"()
    $P711 = $P708."push"($P710)
    .return ($P711)
.end


.namespace ["Hash"]
.sub "values"  :subid("56_1268956021.99384") :method :outer("52_1268956021.99384")
.annotate "line", 126
    .const 'Sub' $P727 = "57_1268956021.99384" 
    capture_lex $P727
    new $P719, 'ExceptionHandler'
    set_addr $P719, control_718
    $P719."handle_types"(58)
    push_eh $P719
    .lex "self", self
.annotate "line", 127
    $P720 = root_new ['parrot';'ResizablePMCArray']
    .lex "@values", $P720
.annotate "line", 126
    find_lex $P721, "@values"
.annotate "line", 128
    find_lex $P723, "self"
    defined $I724, $P723
    unless $I724, for_undef_101
    iter $P722, $P723
    new $P734, 'ExceptionHandler'
    set_addr $P734, loop733_handler
    $P734."handle_types"(65, 67, 66)
    push_eh $P734
  loop733_test:
    unless $P722, loop733_done
    shift $P725, $P722
  loop733_redo:
    .const 'Sub' $P727 = "57_1268956021.99384" 
    capture_lex $P727
    $P727($P725)
  loop733_next:
    goto loop733_test
  loop733_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P735, exception, 'type'
    eq $P735, 65, loop733_next
    eq $P735, 67, loop733_redo
  loop733_done:
    pop_eh 
  for_undef_101:
    find_lex $P736, "@values"
.annotate "line", 126
    .return ($P736)
  control_718:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P737, exception, "payload"
    .return ($P737)
.end


.namespace ["Hash"]
.sub "_block726"  :anon :subid("57_1268956021.99384") :outer("56_1268956021.99384")
    .param pmc param_728
.annotate "line", 128
    .lex "$_", param_728
    find_lex $P729, "@values"
    find_lex $P730, "$_"
    $P731 = $P730."value"()
    $P732 = $P729."push"($P731)
    .return ($P732)
.end


.namespace ["Hash"]
.sub "kv"  :subid("58_1268956021.99384") :method :outer("52_1268956021.99384")
.annotate "line", 144
    .const 'Sub' $P748 = "59_1268956021.99384" 
    capture_lex $P748
    new $P740, 'ExceptionHandler'
    set_addr $P740, control_739
    $P740."handle_types"(58)
    push_eh $P740
    .lex "self", self
.annotate "line", 145
    $P741 = root_new ['parrot';'ResizablePMCArray']
    .lex "@kv", $P741
.annotate "line", 144
    find_lex $P742, "@kv"
.annotate "line", 146
    find_lex $P744, "self"
    defined $I745, $P744
    unless $I745, for_undef_102
    iter $P743, $P744
    new $P758, 'ExceptionHandler'
    set_addr $P758, loop757_handler
    $P758."handle_types"(65, 67, 66)
    push_eh $P758
  loop757_test:
    unless $P743, loop757_done
    shift $P746, $P743
  loop757_redo:
    .const 'Sub' $P748 = "59_1268956021.99384" 
    capture_lex $P748
    $P748($P746)
  loop757_next:
    goto loop757_test
  loop757_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P759, exception, 'type'
    eq $P759, 65, loop757_next
    eq $P759, 67, loop757_redo
  loop757_done:
    pop_eh 
  for_undef_102:
    find_lex $P760, "@kv"
.annotate "line", 144
    .return ($P760)
  control_739:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P761, exception, "payload"
    .return ($P761)
.end


.namespace ["Hash"]
.sub "_block747"  :anon :subid("59_1268956021.99384") :outer("58_1268956021.99384")
    .param pmc param_749
.annotate "line", 146
    .lex "$_", param_749
    find_lex $P750, "@kv"
    find_lex $P751, "$_"
    $P752 = $P751."key"()
    $P750."push"($P752)
    find_lex $P753, "@kv"
    find_lex $P754, "$_"
    $P755 = $P754."value"()
    $P756 = $P753."push"($P755)
    .return ($P756)
.end


.namespace ["Array"]
.sub "_block762"  :subid("60_1268956021.99384") :outer("10_1268956021.99384")
.annotate "line", 169
    .const 'Sub' $P764 = "61_1268956021.99384" 
    capture_lex $P764
.annotate "line", 182
    .const 'Sub' $P764 = "61_1268956021.99384" 
    capture_lex $P764
.annotate "line", 169
    .return ($P764)
.end


.namespace ["Array"]
.sub "reverse"  :subid("61_1268956021.99384") :method :outer("60_1268956021.99384")
.annotate "line", 182
    .const 'Sub' $P774 = "62_1268956021.99384" 
    capture_lex $P774
    new $P766, 'ExceptionHandler'
    set_addr $P766, control_765
    $P766."handle_types"(58)
    push_eh $P766
    .lex "self", self
.annotate "line", 183
    $P767 = root_new ['parrot';'ResizablePMCArray']
    .lex "@reversed", $P767
.annotate "line", 182
    find_lex $P768, "@reversed"
.annotate "line", 184
    find_lex $P770, "self"
    defined $I771, $P770
    unless $I771, for_undef_103
    iter $P769, $P770
    new $P780, 'ExceptionHandler'
    set_addr $P780, loop779_handler
    $P780."handle_types"(65, 67, 66)
    push_eh $P780
  loop779_test:
    unless $P769, loop779_done
    shift $P772, $P769
  loop779_redo:
    .const 'Sub' $P774 = "62_1268956021.99384" 
    capture_lex $P774
    $P774($P772)
  loop779_next:
    goto loop779_test
  loop779_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P781, exception, 'type'
    eq $P781, 65, loop779_next
    eq $P781, 67, loop779_redo
  loop779_done:
    pop_eh 
  for_undef_103:
    find_lex $P782, "@reversed"
.annotate "line", 182
    .return ($P782)
  control_765:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P783, exception, "payload"
    .return ($P783)
.end


.namespace ["Array"]
.sub "_block773"  :anon :subid("62_1268956021.99384") :outer("61_1268956021.99384")
    .param pmc param_775
.annotate "line", 184
    .lex "$_", param_775
    find_lex $P776, "@reversed"
    find_lex $P777, "$_"
    $P778 = $P776."unshift"($P777)
    .return ($P778)
.end

